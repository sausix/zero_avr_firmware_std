   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	_crc8_ccitt_update:
  12               	.LVL0:
  13               	.LFB4:
  14               		.file 1 "/usr/avr/include/util/crc16.h"
   1:/usr/avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/avr/include/util/crc16.h ****    Copyright (c) 2013 Dave Hylands
   4:/usr/avr/include/util/crc16.h ****    Copyright (c) 2013 Frederic Nadeau
   5:/usr/avr/include/util/crc16.h ****    All rights reserved.
   6:/usr/avr/include/util/crc16.h **** 
   7:/usr/avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   8:/usr/avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   9:/usr/avr/include/util/crc16.h **** 
  10:/usr/avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
  11:/usr/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  12:/usr/avr/include/util/crc16.h **** 
  13:/usr/avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  14:/usr/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  15:/usr/avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  16:/usr/avr/include/util/crc16.h ****      distribution.
  17:/usr/avr/include/util/crc16.h **** 
  18:/usr/avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  19:/usr/avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  20:/usr/avr/include/util/crc16.h ****      from this software without specific prior written permission.
  21:/usr/avr/include/util/crc16.h **** 
  22:/usr/avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  23:/usr/avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  24:/usr/avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  25:/usr/avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  26:/usr/avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  27:/usr/avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  28:/usr/avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  29:/usr/avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  30:/usr/avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  31:/usr/avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  32:/usr/avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  33:/usr/avr/include/util/crc16.h **** 
  34:/usr/avr/include/util/crc16.h **** /* $Id: crc16.h 2398 2013-05-08 11:45:54Z joerg_wunsch $ */
  35:/usr/avr/include/util/crc16.h **** 
  36:/usr/avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  37:/usr/avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  38:/usr/avr/include/util/crc16.h **** 
  39:/usr/avr/include/util/crc16.h **** #include <stdint.h>
  40:/usr/avr/include/util/crc16.h **** 
  41:/usr/avr/include/util/crc16.h **** /** \file */
  42:/usr/avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  43:/usr/avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  44:/usr/avr/include/util/crc16.h **** 
  45:/usr/avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  46:/usr/avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  47:/usr/avr/include/util/crc16.h **** 
  48:/usr/avr/include/util/crc16.h ****     \par References:
  49:/usr/avr/include/util/crc16.h **** 
  50:/usr/avr/include/util/crc16.h ****     \par
  51:/usr/avr/include/util/crc16.h **** 
  52:/usr/avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  53:/usr/avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  54:/usr/avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  55:/usr/avr/include/util/crc16.h **** 
  56:/usr/avr/include/util/crc16.h ****     \par
  57:/usr/avr/include/util/crc16.h **** 
  58:/usr/avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  59:/usr/avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  60:/usr/avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  61:/usr/avr/include/util/crc16.h ****     obtain a copy.
  62:/usr/avr/include/util/crc16.h **** 
  63:/usr/avr/include/util/crc16.h ****     A typical application would look like:
  64:/usr/avr/include/util/crc16.h **** 
  65:/usr/avr/include/util/crc16.h ****     \code
  66:/usr/avr/include/util/crc16.h ****     // Dallas iButton test vector.
  67:/usr/avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  68:/usr/avr/include/util/crc16.h **** 
  69:/usr/avr/include/util/crc16.h ****     int
  70:/usr/avr/include/util/crc16.h ****     checkcrc(void)
  71:/usr/avr/include/util/crc16.h ****     {
  72:/usr/avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  73:/usr/avr/include/util/crc16.h **** 
  74:/usr/avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  75:/usr/avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  76:/usr/avr/include/util/crc16.h **** 
  77:/usr/avr/include/util/crc16.h **** 	return crc; // must be 0
  78:/usr/avr/include/util/crc16.h ****     }
  79:/usr/avr/include/util/crc16.h ****     \endcode
  80:/usr/avr/include/util/crc16.h **** */
  81:/usr/avr/include/util/crc16.h **** 
  82:/usr/avr/include/util/crc16.h **** /** \ingroup util_crc
  83:/usr/avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  84:/usr/avr/include/util/crc16.h **** 
  85:/usr/avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  86:/usr/avr/include/util/crc16.h ****     Initial value: 0xffff
  87:/usr/avr/include/util/crc16.h **** 
  88:/usr/avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  89:/usr/avr/include/util/crc16.h **** 
  90:/usr/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  91:/usr/avr/include/util/crc16.h **** 
  92:/usr/avr/include/util/crc16.h ****     \code
  93:/usr/avr/include/util/crc16.h ****     uint16_t
  94:/usr/avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  95:/usr/avr/include/util/crc16.h ****     {
  96:/usr/avr/include/util/crc16.h **** 	int i;
  97:/usr/avr/include/util/crc16.h **** 
  98:/usr/avr/include/util/crc16.h **** 	crc ^= a;
  99:/usr/avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
 100:/usr/avr/include/util/crc16.h **** 	{
 101:/usr/avr/include/util/crc16.h **** 	    if (crc & 1)
 102:/usr/avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 103:/usr/avr/include/util/crc16.h **** 	    else
 104:/usr/avr/include/util/crc16.h **** 		crc = (crc >> 1);
 105:/usr/avr/include/util/crc16.h **** 	}
 106:/usr/avr/include/util/crc16.h **** 
 107:/usr/avr/include/util/crc16.h **** 	return crc;
 108:/usr/avr/include/util/crc16.h ****     }
 109:/usr/avr/include/util/crc16.h **** 
 110:/usr/avr/include/util/crc16.h ****     \endcode */
 111:/usr/avr/include/util/crc16.h **** 
 112:/usr/avr/include/util/crc16.h **** static __inline__ uint16_t
 113:/usr/avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 114:/usr/avr/include/util/crc16.h **** {
 115:/usr/avr/include/util/crc16.h **** 	uint8_t __tmp;
 116:/usr/avr/include/util/crc16.h **** 	uint16_t __ret;
 117:/usr/avr/include/util/crc16.h **** 
 118:/usr/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 119:/usr/avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 120:/usr/avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 121:/usr/avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 122:/usr/avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 123:/usr/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 124:/usr/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 125:/usr/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 126:/usr/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 127:/usr/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 128:/usr/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 129:/usr/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 130:/usr/avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 131:/usr/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 132:/usr/avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 133:/usr/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 134:/usr/avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 135:/usr/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 136:/usr/avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 137:/usr/avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 138:/usr/avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 139:/usr/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 140:/usr/avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 141:/usr/avr/include/util/crc16.h **** 		"eor %A0,%1"
 142:/usr/avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 143:/usr/avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 144:/usr/avr/include/util/crc16.h **** 		: "r0"
 145:/usr/avr/include/util/crc16.h **** 	);
 146:/usr/avr/include/util/crc16.h **** 	return __ret;
 147:/usr/avr/include/util/crc16.h **** }
 148:/usr/avr/include/util/crc16.h **** 
 149:/usr/avr/include/util/crc16.h **** /** \ingroup util_crc
 150:/usr/avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 151:/usr/avr/include/util/crc16.h **** 
 152:/usr/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 153:/usr/avr/include/util/crc16.h ****     Initial value: 0x0
 154:/usr/avr/include/util/crc16.h **** 
 155:/usr/avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 156:/usr/avr/include/util/crc16.h **** 
 157:/usr/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 158:/usr/avr/include/util/crc16.h **** 
 159:/usr/avr/include/util/crc16.h ****     \code
 160:/usr/avr/include/util/crc16.h ****     uint16_t
 161:/usr/avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 162:/usr/avr/include/util/crc16.h ****     {
 163:/usr/avr/include/util/crc16.h ****         int i;
 164:/usr/avr/include/util/crc16.h **** 
 165:/usr/avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 166:/usr/avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 167:/usr/avr/include/util/crc16.h ****         {
 168:/usr/avr/include/util/crc16.h ****             if (crc & 0x8000)
 169:/usr/avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 170:/usr/avr/include/util/crc16.h ****             else
 171:/usr/avr/include/util/crc16.h ****                 crc <<= 1;
 172:/usr/avr/include/util/crc16.h ****         }
 173:/usr/avr/include/util/crc16.h **** 
 174:/usr/avr/include/util/crc16.h ****         return crc;
 175:/usr/avr/include/util/crc16.h ****     }
 176:/usr/avr/include/util/crc16.h ****     \endcode */
 177:/usr/avr/include/util/crc16.h **** 
 178:/usr/avr/include/util/crc16.h **** static __inline__ uint16_t
 179:/usr/avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 180:/usr/avr/include/util/crc16.h **** {
 181:/usr/avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 182:/usr/avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 183:/usr/avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 184:/usr/avr/include/util/crc16.h ****                                 /* %3  __data */
 185:/usr/avr/include/util/crc16.h **** 
 186:/usr/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 187:/usr/avr/include/util/crc16.h ****         "eor    %B0,%3"          "\n\t" /* crc.hi ^ data */
 188:/usr/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 189:/usr/avr/include/util/crc16.h ****         "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */
 190:/usr/avr/include/util/crc16.h **** 
 191:/usr/avr/include/util/crc16.h ****         /* Calculate the ret.lo of the CRC. */
 192:/usr/avr/include/util/crc16.h ****         "mov    %1,__tmp_reg__"  "\n\t"
 193:/usr/avr/include/util/crc16.h ****         "andi   %1,0x0f"         "\n\t"
 194:/usr/avr/include/util/crc16.h ****         "eor    %1,%B0"          "\n\t"
 195:/usr/avr/include/util/crc16.h ****         "mov    %2,%B0"          "\n\t"
 196:/usr/avr/include/util/crc16.h ****         "eor    %2,__tmp_reg__"  "\n\t"
 197:/usr/avr/include/util/crc16.h ****         "lsl    %2"              "\n\t"
 198:/usr/avr/include/util/crc16.h ****         "andi   %2,0xe0"         "\n\t"
 199:/usr/avr/include/util/crc16.h ****         "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */
 200:/usr/avr/include/util/crc16.h **** 
 201:/usr/avr/include/util/crc16.h ****         /* Calculate the ret.hi of the CRC. */
 202:/usr/avr/include/util/crc16.h ****         "mov    %2,__tmp_reg__"  "\n\t"
 203:/usr/avr/include/util/crc16.h ****         "eor    %2,%B0"          "\n\t"
 204:/usr/avr/include/util/crc16.h ****         "andi   %2,0xf0"         "\n\t"
 205:/usr/avr/include/util/crc16.h ****         "lsr    %2"              "\n\t"
 206:/usr/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 207:/usr/avr/include/util/crc16.h ****         "lsl    __tmp_reg__"     "\n\t"
 208:/usr/avr/include/util/crc16.h ****         "rol    %2"              "\n\t"
 209:/usr/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 210:/usr/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 211:/usr/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 212:/usr/avr/include/util/crc16.h ****         "andi   %B0,0x1f"        "\n\t"
 213:/usr/avr/include/util/crc16.h ****         "eor    %B0,%2"          "\n\t"
 214:/usr/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
 215:/usr/avr/include/util/crc16.h ****         "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
 216:/usr/avr/include/util/crc16.h ****         : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
 217:/usr/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 218:/usr/avr/include/util/crc16.h ****         : "r0"
 219:/usr/avr/include/util/crc16.h ****     );
 220:/usr/avr/include/util/crc16.h ****     return __ret;
 221:/usr/avr/include/util/crc16.h **** }
 222:/usr/avr/include/util/crc16.h **** 
 223:/usr/avr/include/util/crc16.h **** /** \ingroup util_crc
 224:/usr/avr/include/util/crc16.h ****     Optimized CRC-CCITT calculation.
 225:/usr/avr/include/util/crc16.h **** 
 226:/usr/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x8408)<br>
 227:/usr/avr/include/util/crc16.h ****     Initial value: 0xffff
 228:/usr/avr/include/util/crc16.h **** 
 229:/usr/avr/include/util/crc16.h ****     This is the CRC used by PPP and IrDA.
 230:/usr/avr/include/util/crc16.h **** 
 231:/usr/avr/include/util/crc16.h ****     See RFC1171 (PPP protocol) and IrDA IrLAP 1.1
 232:/usr/avr/include/util/crc16.h **** 
 233:/usr/avr/include/util/crc16.h ****     \note Although the CCITT polynomial is the same as that used by the Xmodem
 234:/usr/avr/include/util/crc16.h ****     protocol, they are quite different. The difference is in how the bits are
 235:/usr/avr/include/util/crc16.h ****     shifted through the alorgithm. Xmodem shifts the MSB of the CRC and the
 236:/usr/avr/include/util/crc16.h ****     input first, while CCITT shifts the LSB of the CRC and the input first.
 237:/usr/avr/include/util/crc16.h **** 
 238:/usr/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 239:/usr/avr/include/util/crc16.h **** 
 240:/usr/avr/include/util/crc16.h ****     \code
 241:/usr/avr/include/util/crc16.h ****     uint16_t
 242:/usr/avr/include/util/crc16.h ****     crc_ccitt_update (uint16_t crc, uint8_t data)
 243:/usr/avr/include/util/crc16.h ****     {
 244:/usr/avr/include/util/crc16.h ****         data ^= lo8 (crc);
 245:/usr/avr/include/util/crc16.h ****         data ^= data << 4;
 246:/usr/avr/include/util/crc16.h **** 
 247:/usr/avr/include/util/crc16.h ****         return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
 248:/usr/avr/include/util/crc16.h ****                 ^ ((uint16_t)data << 3));
 249:/usr/avr/include/util/crc16.h ****     }
 250:/usr/avr/include/util/crc16.h ****     \endcode */
 251:/usr/avr/include/util/crc16.h **** 
 252:/usr/avr/include/util/crc16.h **** static __inline__ uint16_t
 253:/usr/avr/include/util/crc16.h **** _crc_ccitt_update (uint16_t __crc, uint8_t __data)
 254:/usr/avr/include/util/crc16.h **** {
 255:/usr/avr/include/util/crc16.h ****     uint16_t __ret;
 256:/usr/avr/include/util/crc16.h **** 
 257:/usr/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 258:/usr/avr/include/util/crc16.h ****         "eor    %A0,%1"          "\n\t"
 259:/usr/avr/include/util/crc16.h **** 
 260:/usr/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%A0" "\n\t"
 261:/usr/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 262:/usr/avr/include/util/crc16.h ****         "andi   %A0,0xf0"        "\n\t"
 263:/usr/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__" "\n\t"
 264:/usr/avr/include/util/crc16.h **** 
 265:/usr/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 266:/usr/avr/include/util/crc16.h **** 
 267:/usr/avr/include/util/crc16.h ****         "mov    %B0,%A0"         "\n\t"
 268:/usr/avr/include/util/crc16.h **** 
 269:/usr/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 270:/usr/avr/include/util/crc16.h ****         "andi   %A0,0x0f"        "\n\t"
 271:/usr/avr/include/util/crc16.h ****         "eor    __tmp_reg__,%A0" "\n\t"
 272:/usr/avr/include/util/crc16.h **** 
 273:/usr/avr/include/util/crc16.h ****         "lsr    %A0"             "\n\t"
 274:/usr/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t"
 275:/usr/avr/include/util/crc16.h **** 
 276:/usr/avr/include/util/crc16.h ****         "eor    %A0,%B0"         "\n\t"
 277:/usr/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 278:/usr/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 279:/usr/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 280:/usr/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__"
 281:/usr/avr/include/util/crc16.h **** 
 282:/usr/avr/include/util/crc16.h ****         : "=d" (__ret)
 283:/usr/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 284:/usr/avr/include/util/crc16.h ****         : "r0"
 285:/usr/avr/include/util/crc16.h ****     );
 286:/usr/avr/include/util/crc16.h ****     return __ret;
 287:/usr/avr/include/util/crc16.h **** }
 288:/usr/avr/include/util/crc16.h **** 
 289:/usr/avr/include/util/crc16.h **** /** \ingroup util_crc
 290:/usr/avr/include/util/crc16.h ****     Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.
 291:/usr/avr/include/util/crc16.h **** 
 292:/usr/avr/include/util/crc16.h ****     Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)<br>
 293:/usr/avr/include/util/crc16.h ****     Initial value: 0x0
 294:/usr/avr/include/util/crc16.h **** 
 295:/usr/avr/include/util/crc16.h ****     See http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
 296:/usr/avr/include/util/crc16.h **** 
 297:/usr/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 298:/usr/avr/include/util/crc16.h **** 
 299:/usr/avr/include/util/crc16.h ****     \code
 300:/usr/avr/include/util/crc16.h ****     uint8_t
 301:/usr/avr/include/util/crc16.h ****     _crc_ibutton_update(uint8_t crc, uint8_t data)
 302:/usr/avr/include/util/crc16.h ****     {
 303:/usr/avr/include/util/crc16.h **** 	uint8_t i;
 304:/usr/avr/include/util/crc16.h **** 
 305:/usr/avr/include/util/crc16.h **** 	crc = crc ^ data;
 306:/usr/avr/include/util/crc16.h **** 	for (i = 0; i < 8; i++)
 307:/usr/avr/include/util/crc16.h **** 	{
 308:/usr/avr/include/util/crc16.h **** 	    if (crc & 0x01)
 309:/usr/avr/include/util/crc16.h **** 	        crc = (crc >> 1) ^ 0x8C;
 310:/usr/avr/include/util/crc16.h **** 	    else
 311:/usr/avr/include/util/crc16.h **** 	        crc >>= 1;
 312:/usr/avr/include/util/crc16.h **** 	}
 313:/usr/avr/include/util/crc16.h **** 
 314:/usr/avr/include/util/crc16.h **** 	return crc;
 315:/usr/avr/include/util/crc16.h ****     }
 316:/usr/avr/include/util/crc16.h ****     \endcode
 317:/usr/avr/include/util/crc16.h **** */
 318:/usr/avr/include/util/crc16.h **** 
 319:/usr/avr/include/util/crc16.h **** static __inline__ uint8_t
 320:/usr/avr/include/util/crc16.h **** _crc_ibutton_update(uint8_t __crc, uint8_t __data)
 321:/usr/avr/include/util/crc16.h **** {
 322:/usr/avr/include/util/crc16.h **** 	uint8_t __i, __pattern;
 323:/usr/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 324:/usr/avr/include/util/crc16.h **** 		"	eor	%0, %4" "\n\t"
 325:/usr/avr/include/util/crc16.h **** 		"	ldi	%1, 8" "\n\t"
 326:/usr/avr/include/util/crc16.h **** 		"	ldi	%2, 0x8C" "\n\t"
 327:/usr/avr/include/util/crc16.h **** 		"1:	lsr	%0" "\n\t"
 328:/usr/avr/include/util/crc16.h **** 		"	brcc	2f" "\n\t"
 329:/usr/avr/include/util/crc16.h **** 		"	eor	%0, %2" "\n\t"
 330:/usr/avr/include/util/crc16.h **** 		"2:	dec	%1" "\n\t"
 331:/usr/avr/include/util/crc16.h **** 		"	brne	1b" "\n\t"
 332:/usr/avr/include/util/crc16.h **** 		: "=r" (__crc), "=d" (__i), "=d" (__pattern)
 333:/usr/avr/include/util/crc16.h **** 		: "0" (__crc), "r" (__data));
 334:/usr/avr/include/util/crc16.h **** 	return __crc;
 335:/usr/avr/include/util/crc16.h **** }
 336:/usr/avr/include/util/crc16.h **** 
 337:/usr/avr/include/util/crc16.h **** /** \ingroup util_crc
 338:/usr/avr/include/util/crc16.h ****     Optimized CRC-8-CCITT calculation.
 339:/usr/avr/include/util/crc16.h **** 
 340:/usr/avr/include/util/crc16.h ****     Polynomial: x^8 + x^2 + x + 1 (0xE0)<br>
 341:/usr/avr/include/util/crc16.h ****     
 342:/usr/avr/include/util/crc16.h ****     For use with simple CRC-8<br>
 343:/usr/avr/include/util/crc16.h ****     Initial value: 0x0
 344:/usr/avr/include/util/crc16.h ****     
 345:/usr/avr/include/util/crc16.h ****     For use with CRC-8-ROHC<br>
 346:/usr/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 347:/usr/avr/include/util/crc16.h ****     Reference: http://tools.ietf.org/html/rfc3095#section-5.9.1
 348:/usr/avr/include/util/crc16.h ****     
 349:/usr/avr/include/util/crc16.h ****     For use with CRC-8-ATM/ITU<br>
 350:/usr/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 351:/usr/avr/include/util/crc16.h ****     Final XOR value: 0x55<br>
 352:/usr/avr/include/util/crc16.h ****     Reference: http://www.itu.int/rec/T-REC-I.432.1-199902-I/en
 353:/usr/avr/include/util/crc16.h ****     
 354:/usr/avr/include/util/crc16.h ****     The C equivalent has been originally written by Dave Hylands.
 355:/usr/avr/include/util/crc16.h ****     Assembly code is based on _crc_ibutton_update optimization.
 356:/usr/avr/include/util/crc16.h **** 
 357:/usr/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 358:/usr/avr/include/util/crc16.h **** 
 359:/usr/avr/include/util/crc16.h ****     \code
 360:/usr/avr/include/util/crc16.h ****     uint8_t
 361:/usr/avr/include/util/crc16.h ****     _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
 362:/usr/avr/include/util/crc16.h ****     {
 363:/usr/avr/include/util/crc16.h ****         uint8_t   i;
 364:/usr/avr/include/util/crc16.h ****         uint8_t   data;
 365:/usr/avr/include/util/crc16.h **** 
 366:/usr/avr/include/util/crc16.h ****         data = inCrc ^ inData;
 367:/usr/avr/include/util/crc16.h **** 
 368:/usr/avr/include/util/crc16.h ****         for ( i = 0; i < 8; i++ )
 369:/usr/avr/include/util/crc16.h ****         {
 370:/usr/avr/include/util/crc16.h ****             if (( data & 0x80 ) != 0 )
 371:/usr/avr/include/util/crc16.h ****             {
 372:/usr/avr/include/util/crc16.h ****                 data <<= 1;
 373:/usr/avr/include/util/crc16.h ****                 data ^= 0x07;
 374:/usr/avr/include/util/crc16.h ****             }
 375:/usr/avr/include/util/crc16.h ****             else
 376:/usr/avr/include/util/crc16.h ****             {
 377:/usr/avr/include/util/crc16.h ****                 data <<= 1;
 378:/usr/avr/include/util/crc16.h ****             }
 379:/usr/avr/include/util/crc16.h ****         }
 380:/usr/avr/include/util/crc16.h ****         return data;
 381:/usr/avr/include/util/crc16.h ****     }
 382:/usr/avr/include/util/crc16.h ****     \endcode
 383:/usr/avr/include/util/crc16.h **** */
 384:/usr/avr/include/util/crc16.h **** 
 385:/usr/avr/include/util/crc16.h **** static __inline__ uint8_t
 386:/usr/avr/include/util/crc16.h **** _crc8_ccitt_update(uint8_t __crc, uint8_t __data)
 387:/usr/avr/include/util/crc16.h **** {
  15               		.loc 1 387 1 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 388:/usr/avr/include/util/crc16.h ****     uint8_t __i, __pattern;
  21               		.loc 1 388 5 view .LVU1
 389:/usr/avr/include/util/crc16.h ****     __asm__ __volatile__ (
  22               		.loc 1 389 5 view .LVU2
  23               	/* #APP */
  24               	 ;  389 "/usr/avr/include/util/crc16.h" 1
  25 0000 8627      		    eor    r24, r22
  26 0002 68E0      		    ldi    r22, 8
  27 0004 97E0      		    ldi    r25, 0x07
  28 0006 880F      		1:  lsl    r24
  29 0008 00F4      		    brcc   2f
  30 000a 8927      		    eor    r24, r25
  31 000c 6A95      		2:  dec    r22
  32 000e 01F4      		    brne   1b
  33               		
  34               	 ;  0 "" 2
  35               	.LVL1:
 390:/usr/avr/include/util/crc16.h ****         "    eor    %0, %4" "\n\t"
 391:/usr/avr/include/util/crc16.h ****         "    ldi    %1, 8" "\n\t"
 392:/usr/avr/include/util/crc16.h ****         "    ldi    %2, 0x07" "\n\t"
 393:/usr/avr/include/util/crc16.h ****         "1:  lsl    %0" "\n\t"
 394:/usr/avr/include/util/crc16.h ****         "    brcc   2f" "\n\t"
 395:/usr/avr/include/util/crc16.h ****         "    eor    %0, %2" "\n\t"
 396:/usr/avr/include/util/crc16.h ****         "2:  dec    %1" "\n\t"
 397:/usr/avr/include/util/crc16.h ****         "    brne   1b" "\n\t"
 398:/usr/avr/include/util/crc16.h ****         : "=r" (__crc), "=d" (__i), "=d" (__pattern)
 399:/usr/avr/include/util/crc16.h ****         : "0" (__crc), "r" (__data));
 400:/usr/avr/include/util/crc16.h ****     return __crc;
  36               		.loc 1 400 5 view .LVU3
  37               	/* #NOAPP */
  38               	/* epilogue start */
 401:/usr/avr/include/util/crc16.h **** }
  39               		.loc 1 401 1 is_stmt 0 view .LVU4
  40 0010 0895      		ret
  41               		.cfi_endproc
  42               	.LFE4:
  44               	.global	ws2812_sendarray_mask
  46               	ws2812_sendarray_mask:
  47               	.LVL2:
  48               	.LFB19:
  49               		.file 2 "light_ws2812.c"
   1:light_ws2812.c **** /*
   2:light_ws2812.c **** * light weight WS2812 lib V2.0b
   3:light_ws2812.c **** *
   4:light_ws2812.c **** * Controls WS2811/WS2812/WS2812B RGB-LEDs
   5:light_ws2812.c **** * Author: Tim (cpldcpu@gmail.com)
   6:light_ws2812.c **** *
   7:light_ws2812.c **** * Jan 18th, 2014  v2.0b Initial Version
   8:light_ws2812.c **** *
   9:light_ws2812.c **** *
  10:light_ws2812.c **** * Jun 2019, modified for SHPI by Lutz Harder
  11:light_ws2812.c **** * License: GNU GPL v2+ (see License.txt)
  12:light_ws2812.c **** */
  13:light_ws2812.c **** 
  14:light_ws2812.c **** #include "light_ws2812.h"
  15:light_ws2812.c **** #include <avr/interrupt.h>
  16:light_ws2812.c **** #include <avr/io.h>
  17:light_ws2812.c **** #include <util/delay.h>
  18:light_ws2812.c ****  
  19:light_ws2812.c **** // Setleds for standard RGB 
  20:light_ws2812.c **** void inline ws2812_setleds(struct cRGB *ledarray, uint16_t leds)
  21:light_ws2812.c **** {
  22:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
  23:light_ws2812.c **** }
  24:light_ws2812.c **** 
  25:light_ws2812.c **** void inline ws2812_setleds_pin(struct cRGB *ledarray, uint16_t leds, uint8_t pinmask)
  26:light_ws2812.c **** {
  27:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
  28:light_ws2812.c ****   _delay_us(ws2812_resettime);
  29:light_ws2812.c **** }
  30:light_ws2812.c **** 
  31:light_ws2812.c **** 
  32:light_ws2812.c **** 
  33:light_ws2812.c **** void ws2812_sendarray(uint8_t *data,uint16_t datlen)
  34:light_ws2812.c **** {
  35:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
  36:light_ws2812.c **** }
  37:light_ws2812.c **** 
  38:light_ws2812.c **** /*
  39:light_ws2812.c ****   This routine writes an array of bytes with RGB values to the Dataout pin
  40:light_ws2812.c ****   using the fast 800kHz clockless WS2811/2812 protocol.
  41:light_ws2812.c **** */
  42:light_ws2812.c **** 
  43:light_ws2812.c **** // Timing in ns
  44:light_ws2812.c **** #define w_zeropulse   350
  45:light_ws2812.c **** #define w_onepulse    900
  46:light_ws2812.c **** #define w_totalperiod 120
  47:light_ws2812.c **** 
  48:light_ws2812.c **** // Fixed cycles used by the inner loop
  49:light_ws2812.c **** #define w_fixedlow    2
  50:light_ws2812.c **** #define w_fixedhigh   4
  51:light_ws2812.c **** #define w_fixedtotal  8   
  52:light_ws2812.c **** 
  53:light_ws2812.c **** // Insert NOPs to match the timing, if possible
  54:light_ws2812.c **** #define w_zerocycles    (((F_CPU/1000)*w_zeropulse          )/1000000)
  55:light_ws2812.c **** #define w_onecycles     (((F_CPU/1000)*w_onepulse    +500000)/1000000)
  56:light_ws2812.c **** #define w_totalcycles   (((F_CPU/1000)*w_totalperiod +500000)/1000000)
  57:light_ws2812.c **** 
  58:light_ws2812.c **** // w1 - nops between rising edge and falling edge - low
  59:light_ws2812.c **** #define w1 (w_zerocycles-w_fixedlow)
  60:light_ws2812.c **** // w2   nops between fe low and fe high
  61:light_ws2812.c **** #define w2 (w_onecycles-w_fixedhigh-w1)
  62:light_ws2812.c **** // w3   nops to complete loop
  63:light_ws2812.c **** #define w3 (w_totalcycles-w_fixedtotal-w1-w2)
  64:light_ws2812.c **** 
  65:light_ws2812.c **** #if w1>0
  66:light_ws2812.c ****   #define w1_nops w1
  67:light_ws2812.c **** #else
  68:light_ws2812.c ****   #define w1_nops  0
  69:light_ws2812.c **** #endif
  70:light_ws2812.c **** 
  71:light_ws2812.c **** // The only critical timing parameter is the minimum pulse length of the "0"
  72:light_ws2812.c **** // Warn or throw error if this timing can not be met with current F_CPU settings.
  73:light_ws2812.c **** #define w_lowtime ((w1_nops+w_fixedlow)*1000000)/(F_CPU/1000)
  74:light_ws2812.c **** #if w_lowtime>550
  75:light_ws2812.c ****    #error "Light_ws2812: Sorry, the clock speed is too low. Did you set F_CPU correctly?"
  76:light_ws2812.c **** #elif w_lowtime>450
  77:light_ws2812.c ****    #warning "Light_ws2812: The timing is critical and may only work on WS2812B, not on WS2812(S)."
  78:light_ws2812.c ****    #warning "Please consider a higher clockspeed, if possible"
  79:light_ws2812.c **** #endif   
  80:light_ws2812.c **** 
  81:light_ws2812.c **** #if w2>0
  82:light_ws2812.c **** #define w2_nops w2
  83:light_ws2812.c **** #else
  84:light_ws2812.c **** #define w2_nops  0
  85:light_ws2812.c **** #endif
  86:light_ws2812.c **** 
  87:light_ws2812.c **** #if w3>0
  88:light_ws2812.c **** #define w3_nops w3
  89:light_ws2812.c **** #else
  90:light_ws2812.c **** #define w3_nops  0
  91:light_ws2812.c **** #endif
  92:light_ws2812.c **** 
  93:light_ws2812.c **** #define w_nop1  "nop      \n\t"
  94:light_ws2812.c **** #define w_nop2  "rjmp .+0 \n\t"
  95:light_ws2812.c **** #define w_nop4  w_nop2 w_nop2
  96:light_ws2812.c **** #define w_nop8  w_nop4 w_nop4
  97:light_ws2812.c **** #define w_nop16 w_nop8 w_nop8
  98:light_ws2812.c **** 
  99:light_ws2812.c **** void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
 100:light_ws2812.c **** {
  50               		.loc 2 100 1 is_stmt 1 view -0
  51               		.cfi_startproc
  52               	/* prologue: function */
  53               	/* frame size = 0 */
  54               	/* stack size = 0 */
  55               	.L__stack_usage = 0
  56               		.loc 2 100 1 is_stmt 0 view .LVU6
  57 0012 9C01      		movw r18,r24
  58 0014 CB01      		movw r24,r22
  59               	.LVL3:
 101:light_ws2812.c ****   uint8_t curbyte,ctr,masklo;
  60               		.loc 2 101 3 is_stmt 1 view .LVU7
 102:light_ws2812.c ****   uint8_t sreg_prev;
  61               		.loc 2 102 3 view .LVU8
 103:light_ws2812.c ****   
 104:light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
  62               		.loc 2 104 3 view .LVU9
  63               		.loc 2 104 17 is_stmt 0 view .LVU10
  64 0016 5AB1      		in r21,0xa
  65 0018 542B      		or r21,r20
  66 001a 5AB9      		out 0xa,r21
 105:light_ws2812.c ****   
 106:light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
  67               		.loc 2 106 3 is_stmt 1 view .LVU11
  68               		.loc 2 106 19 is_stmt 0 view .LVU12
  69 001c 6BB1      		in r22,0xb
  70               	.LVL4:
  71               		.loc 2 106 18 view .LVU13
  72 001e 542F      		mov r21,r20
  73 0020 5095      		com r21
  74 0022 5623      		and r21,r22
  75               	.LVL5:
 107:light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
  76               		.loc 2 107 3 is_stmt 1 view .LVU14
  77               		.loc 2 107 20 is_stmt 0 view .LVU15
  78 0024 6BB1      		in r22,0xb
  79               		.loc 2 107 10 view .LVU16
  80 0026 462B      		or r20,r22
  81               	.LVL6:
 108:light_ws2812.c ****   
 109:light_ws2812.c ****   sreg_prev=SREG;
  82               		.loc 2 109 3 is_stmt 1 view .LVU17
  83               		.loc 2 109 12 is_stmt 0 view .LVU18
  84 0028 6FB7      		in r22,__SREG__
  85               	.LVL7:
 110:light_ws2812.c ****   cli();  
  86               		.loc 2 110 3 is_stmt 1 view .LVU19
  87               	/* #APP */
  88               	 ;  110 "light_ws2812.c" 1
  89 002a F894      		cli
  90               	 ;  0 "" 2
 111:light_ws2812.c **** 
 112:light_ws2812.c ****   while (datlen--) {
  91               		.loc 2 112 3 view .LVU20
  92               	/* #NOAPP */
  93 002c 820F      		add r24,r18
  94 002e 931F      		adc r25,r19
  95               	.LVL8:
  96               	.L3:
  97               		.loc 2 112 9 view .LVU21
  98               		.loc 2 112 9 is_stmt 0 view .LVU22
  99 0030 2817      		cp r18,r24
 100 0032 3907      		cpc r19,r25
 101 0034 01F4      		brne .L4
 113:light_ws2812.c ****     curbyte=*data++;
 114:light_ws2812.c ****     
 115:light_ws2812.c ****     asm volatile(
 116:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 117:light_ws2812.c ****     "loop%=:            \n\t"
 118:light_ws2812.c ****     "       out   %2,%3 \n\t"    
 119:light_ws2812.c **** #if (w1_nops&1)
 120:light_ws2812.c **** w_nop1
 121:light_ws2812.c **** #endif
 122:light_ws2812.c **** #if (w1_nops&2)
 123:light_ws2812.c **** w_nop2
 124:light_ws2812.c **** #endif
 125:light_ws2812.c **** #if (w1_nops&4)
 126:light_ws2812.c **** w_nop4
 127:light_ws2812.c **** #endif
 128:light_ws2812.c **** #if (w1_nops&8)
 129:light_ws2812.c **** w_nop8
 130:light_ws2812.c **** #endif
 131:light_ws2812.c **** #if (w1_nops&16)
 132:light_ws2812.c **** w_nop16
 133:light_ws2812.c **** #endif
 134:light_ws2812.c ****     "       sbrs  %1,7  \n\t"   
 135:light_ws2812.c ****     "       out   %2,%4 \n\t"  
 136:light_ws2812.c ****     "       lsl   %1    \n\t"   
 137:light_ws2812.c **** #if (w2_nops&1)
 138:light_ws2812.c ****   w_nop1
 139:light_ws2812.c **** #endif
 140:light_ws2812.c **** #if (w2_nops&2)
 141:light_ws2812.c ****   w_nop2
 142:light_ws2812.c **** #endif
 143:light_ws2812.c **** #if (w2_nops&4)
 144:light_ws2812.c ****   w_nop4
 145:light_ws2812.c **** #endif
 146:light_ws2812.c **** #if (w2_nops&8)
 147:light_ws2812.c ****   w_nop8
 148:light_ws2812.c **** #endif
 149:light_ws2812.c **** #if (w2_nops&16)
 150:light_ws2812.c ****   w_nop16 
 151:light_ws2812.c **** #endif
 152:light_ws2812.c ****     "       out   %2,%4 \n\t"   
 153:light_ws2812.c **** #if (w3_nops&1)
 154:light_ws2812.c **** w_nop1
 155:light_ws2812.c **** #endif
 156:light_ws2812.c **** #if (w3_nops&2)
 157:light_ws2812.c **** w_nop2
 158:light_ws2812.c **** #endif
 159:light_ws2812.c **** #if (w3_nops&4)
 160:light_ws2812.c **** w_nop4
 161:light_ws2812.c **** #endif
 162:light_ws2812.c **** #if (w3_nops&8)
 163:light_ws2812.c **** w_nop8
 164:light_ws2812.c **** #endif
 165:light_ws2812.c **** #if (w3_nops&16)
 166:light_ws2812.c **** w_nop16
 167:light_ws2812.c **** #endif
 168:light_ws2812.c **** 
 169:light_ws2812.c ****     "       dec   %0    \n\t"   
 170:light_ws2812.c ****     "       brne  loop%=\n\t"   
 171:light_ws2812.c ****     :	"=&d" (ctr)
 172:light_ws2812.c ****     :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
 173:light_ws2812.c ****     );
 174:light_ws2812.c ****   }
 175:light_ws2812.c ****   
 176:light_ws2812.c ****   SREG=sreg_prev;
 102               		.loc 2 176 3 is_stmt 1 view .LVU23
 103               		.loc 2 176 7 is_stmt 0 view .LVU24
 104 0036 6FBF      		out __SREG__,r22
 105               	/* epilogue start */
 177:light_ws2812.c **** }
 106               		.loc 2 177 1 view .LVU25
 107 0038 0895      		ret
 108               	.L4:
 113:light_ws2812.c ****     curbyte=*data++;
 109               		.loc 2 113 5 is_stmt 1 view .LVU26
 110               	.LVL9:
 115:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 111               		.loc 2 115 5 view .LVU27
 112 003a F901      		movw r30,r18
 113 003c 7191      		ld r23,Z+
 114               	.LVL10:
 115:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 115               		.loc 2 115 5 is_stmt 0 view .LVU28
 116 003e 9F01      		movw r18,r30
 117               	.LVL11:
 115:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 118               		.loc 2 115 5 view .LVU29
 119               	/* #APP */
 120               	 ;  115 "light_ws2812.c" 1
 121 0040 E8E0      		       ldi   r30,8  
 122               		loop88:            
 123 0042 4BB9      		       out   11,r20 
 124 0044 0000      		nop      
 125 0046 00C0      		rjmp .+0 
 126 0048 77FF      		       sbrs  r23,7  
 127 004a 5BB9      		       out   11,r21 
 128 004c 770F      		       lsl   r23    
 129 004e 0000      		nop      
 130 0050 00C0      		rjmp .+0 
 131 0052 00C0      		rjmp .+0 
 132 0054 00C0      		rjmp .+0 
 133 0056 5BB9      		       out   11,r21 
 134 0058 00C0      		rjmp .+0 
 135 005a 00C0      		rjmp .+0 
 136 005c 00C0      		rjmp .+0 
 137 005e 00C0      		rjmp .+0 
 138 0060 00C0      		rjmp .+0 
 139 0062 00C0      		rjmp .+0 
 140 0064 00C0      		rjmp .+0 
 141 0066 00C0      		rjmp .+0 
 142 0068 EA95      		       dec   r30    
 143 006a 01F4      		       brne  loop88
 144               		
 145               	 ;  0 "" 2
 146               	.LVL12:
 115:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 147               		.loc 2 115 5 view .LVU30
 148               	/* #NOAPP */
 149 006c 00C0      		rjmp .L3
 150               		.cfi_endproc
 151               	.LFE19:
 153               	.global	ws2812_setleds_pin
 155               	ws2812_setleds_pin:
 156               	.LVL13:
 157               	.LFB17:
  26:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
 158               		.loc 2 26 1 is_stmt 1 view -0
 159               		.cfi_startproc
 160               	/* prologue: function */
 161               	/* frame size = 0 */
 162               	/* stack size = 0 */
 163               	.L__stack_usage = 0
  27:light_ws2812.c ****   _delay_us(ws2812_resettime);
 164               		.loc 2 27 3 view .LVU32
 165 006e 9B01      		movw r18,r22
 166 0070 220F      		lsl r18
 167 0072 331F      		rol r19
 168 0074 620F      		add r22,r18
 169 0076 731F      		adc r23,r19
 170               	.LVL14:
  27:light_ws2812.c ****   _delay_us(ws2812_resettime);
 171               		.loc 2 27 3 is_stmt 0 view .LVU33
 172 0078 0E94 0000 		call ws2812_sendarray_mask
 173               	.LVL15:
  28:light_ws2812.c **** }
 174               		.loc 2 28 3 is_stmt 1 view .LVU34
 175               	.LBB46:
 176               	.LBI46:
 177               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 178               		.loc 3 255 1 view .LVU35
 179               	.LBB47:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 180               		.loc 3 257 2 view .LVU36
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 181               		.loc 3 261 2 view .LVU37
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 182               		.loc 3 262 2 view .LVU38
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 183               		.loc 3 263 2 view .LVU39
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 184               		.loc 3 273 3 view .LVU40
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 185               		.loc 3 276 2 view .LVU41
 186 007c 8FEA      		ldi r24,lo8(1199)
 187 007e 94E0      		ldi r25,hi8(1199)
 188 0080 0197      	1:	sbiw r24,1
 189 0082 01F4      		brne 1b
 190 0084 00C0      		rjmp .
 191 0086 0000      		nop
 192               	.LVL16:
 193               	/* epilogue start */
 194               		.loc 3 276 2 is_stmt 0 view .LVU42
 195               	.LBE47:
 196               	.LBE46:
  29:light_ws2812.c **** 
 197               		.loc 2 29 1 view .LVU43
 198 0088 0895      		ret
 199               		.cfi_endproc
 200               	.LFE17:
 202               	.global	ws2812_setleds
 204               	ws2812_setleds:
 205               	.LVL17:
 206               	.LFB16:
  21:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
 207               		.loc 2 21 1 is_stmt 1 view -0
 208               		.cfi_startproc
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 211               	/* stack size = 0 */
 212               	.L__stack_usage = 0
  22:light_ws2812.c **** }
 213               		.loc 2 22 4 view .LVU45
 214 008a 40E2      		ldi r20,lo8(32)
 215 008c 0C94 0000 		jmp ws2812_setleds_pin
 216               	.LVL18:
  22:light_ws2812.c **** }
 217               		.loc 2 22 4 is_stmt 0 view .LVU46
 218               		.cfi_endproc
 219               	.LFE16:
 221               	.global	ws2812_sendarray
 223               	ws2812_sendarray:
 224               	.LVL19:
 225               	.LFB18:
  34:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
 226               		.loc 2 34 1 is_stmt 1 view -0
 227               		.cfi_startproc
 228               	/* prologue: function */
 229               	/* frame size = 0 */
 230               	/* stack size = 0 */
 231               	.L__stack_usage = 0
  35:light_ws2812.c **** }
 232               		.loc 2 35 3 view .LVU48
 233 0090 40E2      		ldi r20,lo8(32)
 234 0092 0C94 0000 		jmp ws2812_sendarray_mask
 235               	.LVL20:
  35:light_ws2812.c **** }
 236               		.loc 2 35 3 is_stmt 0 view .LVU49
 237               		.cfi_endproc
 238               	.LFE18:
 240               	.global	writebl
 242               	writebl:
 243               	.LVL21:
 244               	.LFB20:
 245               		.file 4 "main.c"
   1:main.c        **** /*
   2:main.c        **** * SHPI.zero Basic Firmware v1.2 BETA
   3:main.c        **** *
   4:main.c        **** * Author: Lutz Harder, Adrian Sausenthaler
   5:main.c        **** * License: GNU GPL
   6:main.c        **** *
   7:main.c        **** * Basic Firmware for ATmega32u4 slave,  no radio module support included
   8:main.c        **** *
   9:main.c        **** * Jul    15th, 2019  [00] v 1.1b initial Version (LH)
  10:main.c        **** *
  11:main.c        **** * October 4th, 2019  [00] v 1.2  Beta (LH)
  12:main.c        **** *    NEW: implemented CRC Check via CRC8  CCITT
  13:main.c        **** *
  14:main.c        **** * May    04th, 2020  [01] v 2.0  Beta (AS)
  15:main.c        **** *    NEW: Flash-Version check. Speed improvements.
  16:main.c        **** *
  17:main.c        **** */
  18:main.c        **** #define FW_VERSION  0x01
  19:main.c        **** #define I2C_ADDR 0x2A
  20:main.c        **** 
  21:main.c        **** 
  22:main.c        **** #include <util/crc16.h>
  23:main.c        **** #include <avr/wdt.h>
  24:main.c        **** #include <avr/power.h>
  25:main.c        **** #include <avr/io.h>
  26:main.c        **** #define DELAY 100
  27:main.c        **** #define WAIT 120
  28:main.c        **** #include <util/delay.h>
  29:main.c        **** #include <avr/interrupt.h>
  30:main.c        **** #include <stdint.h>
  31:main.c        **** #include <util/twi.h>
  32:main.c        **** 
  33:main.c        **** #define ws2812_resettime 300
  34:main.c        **** #define ws2812_port D
  35:main.c        **** #define ws2812_pin 5
  36:main.c        **** #include "light_ws2812.c"
  37:main.c        **** struct cRGB led[1];
  38:main.c        **** 
  39:main.c        **** 
  40:main.c        **** #define SDA_LINE  (PIND & (1<<PD1))
  41:main.c        **** 
  42:main.c        **** uint8_t commandbyte=0xFF, twdrbuffer, buffer_address, a7count=0, count, bllevel = 31, newbllevel = 
  43:main.c        **** uint16_t a0, a1, a2, a3, a4, a5, a7, a7avg, a7max, a7min, vcc, temp, rpm, fanspin, isrtimer, i2cbuf
  44:main.c        **** uint8_t fanlevel=254;
  45:main.c        **** 
  46:main.c        **** 
  47:main.c        **** 
  48:main.c        **** uint16_t commands[] =  {0x0080, 0x01F8,  0x0246, 0x0305, 0x0440,  0x0540, 0x0640,0x0740, 0x0840,  0
  49:main.c        **** 
  50:main.c        **** uint16_t commands2[]=  {0x0011,0x0000,0x0001,0x0000,0x00C1,0x01A8,0x01B1,0x0145,0x0104,0x0C5,0x0180
  51:main.c        ****                        0x01BD,0x0184,0x00C7,0x01BD,0x0184,0x00BD,0x0102,0x0011,0x0000,0x00F2,0x0100
  52:main.c        ****                        0x0026,0x0108,0x00E0,0x0100,0x0104,0x0108,0x010B,0x010C,0x0111,0x010D,0x010E
  53:main.c        ****                        0x0108,0x0113,0x0114,0x012F,0x0129,0x0124,0x00E1,0x0100,0x0104,0x0108,0x010B
  54:main.c        ****                        0x010D,0x010E,0x0100,0x0104,0x0108,0x0113,0x0114,0x012F,0x0129,0x0124,0x0026
  55:main.c        ****                        0x0100,0x0108,0x0029};             
  56:main.c        **** 
  57:main.c        **** 
  58:main.c        **** void writebl(uint8_t data) { // set single wire brightness  AL3050 
 246               		.loc 4 58 28 is_stmt 1 view -0
 247               		.cfi_startproc
 248               	/* prologue: function */
 249               	/* frame size = 0 */
 250               	/* stack size = 0 */
 251               	.L__stack_usage = 0
  59:main.c        ****   uint8_t count = 8;
 252               		.loc 4 59 3 view .LVU51
  58:main.c        ****   uint8_t count = 8;
 253               		.loc 4 58 28 is_stmt 0 view .LVU52
 254 0096 27E0      		ldi r18,lo8(7)
 255 0098 30E0      		ldi r19,0
  60:main.c        ****   do {
  61:main.c        ****     PORTD &= ~_BV(PD4);
  62:main.c        ****     _delay_us(100);
  63:main.c        ****     if (!(data & (1 << (count - 1)))) {
 256               		.loc 4 63 9 view .LVU53
 257 009a 90E0      		ldi r25,0
 258               	.LVL22:
 259               	.L11:
  60:main.c        ****   do {
 260               		.loc 4 60 3 is_stmt 1 view .LVU54
  61:main.c        ****     _delay_us(100);
 261               		.loc 4 61 5 view .LVU55
  61:main.c        ****     _delay_us(100);
 262               		.loc 4 61 11 is_stmt 0 view .LVU56
 263 009c 5C98      		cbi 0xb,4
  62:main.c        ****     if (!(data & (1 << (count - 1)))) {
 264               		.loc 4 62 5 is_stmt 1 view .LVU57
 265               	.LVL23:
 266               	.LBB48:
 267               	.LBI48:
 255:/usr/avr/include/util/delay.h **** {
 268               		.loc 3 255 1 view .LVU58
 269               	.LBB49:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 270               		.loc 3 257 2 view .LVU59
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 271               		.loc 3 261 2 view .LVU60
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 272               		.loc 3 262 2 view .LVU61
 263:/usr/avr/include/util/delay.h **** 
 273               		.loc 3 263 2 view .LVU62
 273:/usr/avr/include/util/delay.h **** 	#endif
 274               		.loc 3 273 3 view .LVU63
 275               		.loc 3 276 2 view .LVU64
 276 009e EFE8      		ldi r30,lo8(399)
 277 00a0 F1E0      		ldi r31,hi8(399)
 278 00a2 3197      	1:	sbiw r30,1
 279 00a4 01F4      		brne 1b
 280 00a6 00C0      		rjmp .
 281 00a8 0000      		nop
 282               	.LVL24:
 283               		.loc 3 276 2 is_stmt 0 view .LVU65
 284               	.LBE49:
 285               	.LBE48:
 286               		.loc 4 63 5 is_stmt 1 view .LVU66
 287               		.loc 4 63 9 is_stmt 0 view .LVU67
 288 00aa AC01      		movw r20,r24
 289 00ac 022E      		mov r0,r18
 290 00ae 00C0      		rjmp 2f
 291               		1:
 292 00b0 5595      		asr r21
 293 00b2 4795      		ror r20
 294               		2:
 295 00b4 0A94      		dec r0
 296 00b6 02F4      		brpl 1b
 297               		.loc 4 63 8 view .LVU68
 298 00b8 BA01      		movw r22,r20
 299 00ba 6170      		andi r22,1
 300 00bc 7727      		clr r23
 301 00be 40FD      		sbrc r20,0
 302 00c0 00C0      		rjmp .L9
  64:main.c        ****       _delay_us(100);
 303               		.loc 4 64 7 is_stmt 1 view .LVU69
 304               	.LVL25:
 305               	.LBB50:
 306               	.LBI50:
 255:/usr/avr/include/util/delay.h **** {
 307               		.loc 3 255 1 view .LVU70
 308               	.LBB51:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 309               		.loc 3 257 2 view .LVU71
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 310               		.loc 3 261 2 view .LVU72
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 311               		.loc 3 262 2 view .LVU73
 263:/usr/avr/include/util/delay.h **** 
 312               		.loc 3 263 2 view .LVU74
 273:/usr/avr/include/util/delay.h **** 	#endif
 313               		.loc 3 273 3 view .LVU75
 314               		.loc 3 276 2 view .LVU76
 315 00c2 EFE8      		ldi r30,lo8(399)
 316 00c4 F1E0      		ldi r31,hi8(399)
 317 00c6 3197      	1:	sbiw r30,1
 318 00c8 01F4      		brne 1b
 319 00ca 00C0      		rjmp .
 320 00cc 0000      		nop
 321               	.LVL26:
 322               	.L9:
 323               		.loc 3 276 2 is_stmt 0 view .LVU77
 324               	.LBE51:
 325               	.LBE50:
  65:main.c        ****     }
  66:main.c        ****     PORTD |= _BV(PD4);
 326               		.loc 4 66 5 is_stmt 1 view .LVU78
 327               		.loc 4 66 11 is_stmt 0 view .LVU79
 328 00ce 5C9A      		sbi 0xb,4
  67:main.c        ****     _delay_us(100);
 329               		.loc 4 67 5 is_stmt 1 view .LVU80
 330               	.LVL27:
 331               	.LBB52:
 332               	.LBI52:
 255:/usr/avr/include/util/delay.h **** {
 333               		.loc 3 255 1 view .LVU81
 334               	.LBB53:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 335               		.loc 3 257 2 view .LVU82
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 336               		.loc 3 261 2 view .LVU83
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 337               		.loc 3 262 2 view .LVU84
 263:/usr/avr/include/util/delay.h **** 
 338               		.loc 3 263 2 view .LVU85
 273:/usr/avr/include/util/delay.h **** 	#endif
 339               		.loc 3 273 3 view .LVU86
 340               		.loc 3 276 2 view .LVU87
 341 00d0 EFE8      		ldi r30,lo8(399)
 342 00d2 F1E0      		ldi r31,hi8(399)
 343 00d4 3197      	1:	sbiw r30,1
 344 00d6 01F4      		brne 1b
 345 00d8 00C0      		rjmp .
 346 00da 0000      		nop
 347               	.LVL28:
 348               		.loc 3 276 2 is_stmt 0 view .LVU88
 349               	.LBE53:
 350               	.LBE52:
  68:main.c        ****     if ((data & (1 << (count - 1))) != 0) {
 351               		.loc 4 68 5 is_stmt 1 view .LVU89
 352               		.loc 4 68 8 is_stmt 0 view .LVU90
 353 00dc 672B      		or r22,r23
 354 00de 01F0      		breq .L10
  69:main.c        ****       _delay_us(100);
 355               		.loc 4 69 7 is_stmt 1 view .LVU91
 356               	.LVL29:
 357               	.LBB54:
 358               	.LBI54:
 255:/usr/avr/include/util/delay.h **** {
 359               		.loc 3 255 1 view .LVU92
 360               	.LBB55:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 361               		.loc 3 257 2 view .LVU93
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 362               		.loc 3 261 2 view .LVU94
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 363               		.loc 3 262 2 view .LVU95
 263:/usr/avr/include/util/delay.h **** 
 364               		.loc 3 263 2 view .LVU96
 273:/usr/avr/include/util/delay.h **** 	#endif
 365               		.loc 3 273 3 view .LVU97
 366               		.loc 3 276 2 view .LVU98
 367 00e0 EFE8      		ldi r30,lo8(399)
 368 00e2 F1E0      		ldi r31,hi8(399)
 369 00e4 3197      	1:	sbiw r30,1
 370 00e6 01F4      		brne 1b
 371 00e8 00C0      		rjmp .
 372 00ea 0000      		nop
 373               	.LVL30:
 374               	.L10:
 375               		.loc 3 276 2 is_stmt 0 view .LVU99
 376               	.LBE55:
 377               	.LBE54:
  70:main.c        ****     }
  71:main.c        ****     count--;
 378               		.loc 4 71 5 is_stmt 1 view .LVU100
  72:main.c        ****   } while (count);
 379               		.loc 4 72 11 view .LVU101
 380               	.LVL31:
 381 00ec 2150      		subi r18,1
 382 00ee 3109      		sbc r19,__zero_reg__
 383 00f0 00F4      		brcc .L11
  73:main.c        **** 
  74:main.c        ****   PORTD &= ~_BV(PD4);
 384               		.loc 4 74 3 view .LVU102
 385               		.loc 4 74 9 is_stmt 0 view .LVU103
 386 00f2 5C98      		cbi 0xb,4
  75:main.c        ****   _delay_us(100);
 387               		.loc 4 75 3 is_stmt 1 view .LVU104
 388               	.LVL32:
 389               	.LBB56:
 390               	.LBI56:
 255:/usr/avr/include/util/delay.h **** {
 391               		.loc 3 255 1 view .LVU105
 392               	.LBB57:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 393               		.loc 3 257 2 view .LVU106
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 394               		.loc 3 261 2 view .LVU107
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 395               		.loc 3 262 2 view .LVU108
 263:/usr/avr/include/util/delay.h **** 
 396               		.loc 3 263 2 view .LVU109
 273:/usr/avr/include/util/delay.h **** 	#endif
 397               		.loc 3 273 3 view .LVU110
 398               		.loc 3 276 2 view .LVU111
 399 00f4 8FE8      		ldi r24,lo8(399)
 400 00f6 91E0      		ldi r25,hi8(399)
 401 00f8 0197      	1:	sbiw r24,1
 402 00fa 01F4      		brne 1b
 403               	.LVL33:
 404               		.loc 3 276 2 is_stmt 0 view .LVU112
 405 00fc 00C0      		rjmp .
 406 00fe 0000      		nop
 407               	.LVL34:
 408               		.loc 3 276 2 view .LVU113
 409               	.LBE57:
 410               	.LBE56:
  76:main.c        ****   PORTD |= _BV(PD4);
 411               		.loc 4 76 3 is_stmt 1 view .LVU114
 412               		.loc 4 76 9 is_stmt 0 view .LVU115
 413 0100 5C9A      		sbi 0xb,4
  77:main.c        ****   _delay_us(100);
 414               		.loc 4 77 3 is_stmt 1 view .LVU116
 415               	.LVL35:
 416               	.LBB58:
 417               	.LBI58:
 255:/usr/avr/include/util/delay.h **** {
 418               		.loc 3 255 1 view .LVU117
 419               	.LBB59:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 420               		.loc 3 257 2 view .LVU118
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 421               		.loc 3 261 2 view .LVU119
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 422               		.loc 3 262 2 view .LVU120
 263:/usr/avr/include/util/delay.h **** 
 423               		.loc 3 263 2 view .LVU121
 273:/usr/avr/include/util/delay.h **** 	#endif
 424               		.loc 3 273 3 view .LVU122
 425               		.loc 3 276 2 view .LVU123
 426 0102 EFE8      		ldi r30,lo8(399)
 427 0104 F1E0      		ldi r31,hi8(399)
 428 0106 3197      	1:	sbiw r30,1
 429 0108 01F4      		brne 1b
 430 010a 00C0      		rjmp .
 431 010c 0000      		nop
 432               	.LVL36:
 433               	/* epilogue start */
 434               		.loc 3 276 2 is_stmt 0 view .LVU124
 435               	.LBE59:
 436               	.LBE58:
  78:main.c        **** }
 437               		.loc 4 78 1 view .LVU125
 438 010e 0895      		ret
 439               		.cfi_endproc
 440               	.LFE20:
 442               	.global	initbl
 444               	initbl:
 445               	.LFB21:
  79:main.c        **** 
  80:main.c        **** void initbl(void) { // init AL3050 single wire dimming
 446               		.loc 4 80 19 is_stmt 1 view -0
 447               		.cfi_startproc
 448               	/* prologue: function */
 449               	/* frame size = 0 */
 450               	/* stack size = 0 */
 451               	.L__stack_usage = 0
  81:main.c        ****   PORTD &= ~_BV(PD4);
 452               		.loc 4 81 3 view .LVU127
 453               		.loc 4 81 9 is_stmt 0 view .LVU128
 454 0110 5C98      		cbi 0xb,4
  82:main.c        ****   _delay_us(3000);
 455               		.loc 4 82 3 is_stmt 1 view .LVU129
 456               	.LVL37:
 457               	.LBB60:
 458               	.LBI60:
 255:/usr/avr/include/util/delay.h **** {
 459               		.loc 3 255 1 view .LVU130
 460               	.LBB61:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 461               		.loc 3 257 2 view .LVU131
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 462               		.loc 3 261 2 view .LVU132
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 463               		.loc 3 262 2 view .LVU133
 263:/usr/avr/include/util/delay.h **** 
 464               		.loc 3 263 2 view .LVU134
 273:/usr/avr/include/util/delay.h **** 	#endif
 465               		.loc 3 273 3 view .LVU135
 466               		.loc 3 276 2 view .LVU136
 467 0112 8FED      		ldi r24,lo8(11999)
 468 0114 9EE2      		ldi r25,hi8(11999)
 469 0116 0197      	1:	sbiw r24,1
 470 0118 01F4      		brne 1b
 471 011a 00C0      		rjmp .
 472 011c 0000      		nop
 473               	.LVL38:
 474               		.loc 3 276 2 is_stmt 0 view .LVU137
 475               	.LBE61:
 476               	.LBE60:
  83:main.c        ****   PORTD |= _BV(PD4);
 477               		.loc 4 83 3 is_stmt 1 view .LVU138
 478               		.loc 4 83 9 is_stmt 0 view .LVU139
 479 011e 5C9A      		sbi 0xb,4
  84:main.c        ****   _delay_us(120);
 480               		.loc 4 84 3 is_stmt 1 view .LVU140
 481               	.LVL39:
 482               	.LBB62:
 483               	.LBI62:
 255:/usr/avr/include/util/delay.h **** {
 484               		.loc 3 255 1 view .LVU141
 485               	.LBB63:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 486               		.loc 3 257 2 view .LVU142
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 487               		.loc 3 261 2 view .LVU143
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 488               		.loc 3 262 2 view .LVU144
 263:/usr/avr/include/util/delay.h **** 
 489               		.loc 3 263 2 view .LVU145
 273:/usr/avr/include/util/delay.h **** 	#endif
 490               		.loc 3 273 3 view .LVU146
 491               		.loc 3 276 2 view .LVU147
 492 0120 8FED      		ldi r24,lo8(479)
 493 0122 91E0      		ldi r25,hi8(479)
 494 0124 0197      	1:	sbiw r24,1
 495 0126 01F4      		brne 1b
 496 0128 00C0      		rjmp .
 497 012a 0000      		nop
 498               	.LVL40:
 499               		.loc 3 276 2 is_stmt 0 view .LVU148
 500               	.LBE63:
 501               	.LBE62:
  85:main.c        ****   PORTD &= ~_BV(PD4);
 502               		.loc 4 85 3 is_stmt 1 view .LVU149
 503               		.loc 4 85 9 is_stmt 0 view .LVU150
 504 012c 5C98      		cbi 0xb,4
  86:main.c        ****   _delay_us(500);
 505               		.loc 4 86 3 is_stmt 1 view .LVU151
 506               	.LVL41:
 507               	.LBB64:
 508               	.LBI64:
 255:/usr/avr/include/util/delay.h **** {
 509               		.loc 3 255 1 view .LVU152
 510               	.LBB65:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 511               		.loc 3 257 2 view .LVU153
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 512               		.loc 3 261 2 view .LVU154
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 513               		.loc 3 262 2 view .LVU155
 263:/usr/avr/include/util/delay.h **** 
 514               		.loc 3 263 2 view .LVU156
 273:/usr/avr/include/util/delay.h **** 	#endif
 515               		.loc 3 273 3 view .LVU157
 516               		.loc 3 276 2 view .LVU158
 517 012e 8FEC      		ldi r24,lo8(1999)
 518 0130 97E0      		ldi r25,hi8(1999)
 519 0132 0197      	1:	sbiw r24,1
 520 0134 01F4      		brne 1b
 521 0136 00C0      		rjmp .
 522 0138 0000      		nop
 523               	.LVL42:
 524               		.loc 3 276 2 is_stmt 0 view .LVU159
 525               	.LBE65:
 526               	.LBE64:
  87:main.c        ****   PORTD |= _BV(PD4);
 527               		.loc 4 87 3 is_stmt 1 view .LVU160
 528               		.loc 4 87 9 is_stmt 0 view .LVU161
 529 013a 5C9A      		sbi 0xb,4
  88:main.c        ****   _delay_us(5);
 530               		.loc 4 88 3 is_stmt 1 view .LVU162
 531               	.LVL43:
 532               	.LBB66:
 533               	.LBI66:
 255:/usr/avr/include/util/delay.h **** {
 534               		.loc 3 255 1 view .LVU163
 535               	.LBB67:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 536               		.loc 3 257 2 view .LVU164
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 537               		.loc 3 261 2 view .LVU165
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 538               		.loc 3 262 2 view .LVU166
 263:/usr/avr/include/util/delay.h **** 
 539               		.loc 3 263 2 view .LVU167
 273:/usr/avr/include/util/delay.h **** 	#endif
 540               		.loc 3 273 3 view .LVU168
 541               		.loc 3 276 2 view .LVU169
 542 013c 9AE1      		ldi r25,lo8(26)
 543 013e 9A95      	1:	dec r25
 544 0140 01F4      		brne 1b
 545 0142 00C0      		rjmp .
 546               	.LVL44:
 547               	/* epilogue start */
 548               		.loc 3 276 2 is_stmt 0 view .LVU170
 549               	.LBE67:
 550               	.LBE66:
  89:main.c        **** }
 551               		.loc 4 89 1 view .LVU171
 552 0144 0895      		ret
 553               		.cfi_endproc
 554               	.LFE21:
 556               	.global	write
 558               	write:
 559               	.LVL45:
 560               	.LFB22:
  90:main.c        **** 
  91:main.c        **** void write(uint16_t data, uint8_t count) { //  write routine for LCD setup
 561               		.loc 4 91 42 is_stmt 1 view -0
 562               		.cfi_startproc
 563               	/* prologue: function */
 564               	/* frame size = 0 */
 565               	/* stack size = 0 */
 566               	.L__stack_usage = 0
 567               		.loc 4 91 42 is_stmt 0 view .LVU173
 568 0146 9C01      		movw r18,r24
  92:main.c        ****   PORTD &= ~_BV(PD4);
 569               		.loc 4 92 3 is_stmt 1 view .LVU174
 570               		.loc 4 92 9 is_stmt 0 view .LVU175
 571 0148 5C98      		cbi 0xb,4
  93:main.c        ****   do {
  94:main.c        ****     PORTB &= ~_BV(PB2);
  95:main.c        ****     PORTB |= (((data & (1 << (count - 1))) != 0) << 2); // BITWISE AND -> PB2           
 572               		.loc 4 95 27 view .LVU176
 573 014a E1E0      		ldi r30,lo8(1)
 574 014c F0E0      		ldi r31,0
 575               	.LVL46:
 576               	.L19:
  93:main.c        ****   do {
 577               		.loc 4 93 3 is_stmt 1 view .LVU177
  94:main.c        ****     PORTB |= (((data & (1 << (count - 1))) != 0) << 2); // BITWISE AND -> PB2           
 578               		.loc 4 94 5 view .LVU178
  94:main.c        ****     PORTB |= (((data & (1 << (count - 1))) != 0) << 2); // BITWISE AND -> PB2           
 579               		.loc 4 94 11 is_stmt 0 view .LVU179
 580 014e 2A98      		cbi 0x5,2
 581               		.loc 4 95 5 is_stmt 1 view .LVU180
 582               		.loc 4 95 11 is_stmt 0 view .LVU181
 583 0150 85B1      		in r24,0x5
 584               		.loc 4 95 37 view .LVU182
 585 0152 A62F      		mov r26,r22
 586 0154 A150      		subi r26,1
 587 0156 BB0B      		sbc r27,r27
 588 0158 AD01      		movw r20,r26
 589               		.loc 4 95 27 view .LVU183
 590 015a DF01      		movw r26,r30
 591 015c 00C0      		rjmp 2f
 592               		1:
 593 015e AA0F      		lsl r26
 594 0160 BB1F      		rol r27
 595               		2:
 596 0162 4A95      		dec r20
 597 0164 02F4      		brpl 1b
 598 0166 AD01      		movw r20,r26
 599               		.loc 4 95 22 view .LVU184
 600 0168 4223      		and r20,r18
 601 016a 5323      		and r21,r19
 602               		.loc 4 95 11 view .LVU185
 603 016c 90E0      		ldi r25,0
 604 016e 452B      		or r20,r21
 605 0170 01F0      		breq .L18
 606               		.loc 4 95 11 view .LVU186
 607 0172 94E0      		ldi r25,lo8(4)
 608               	.L18:
 609               		.loc 4 95 11 discriminator 4 view .LVU187
 610 0174 892B      		or r24,r25
 611 0176 85B9      		out 0x5,r24
  96:main.c        ****     PORTB &= ~_BV(PB1);
 612               		.loc 4 96 5 is_stmt 1 discriminator 4 view .LVU188
 613               		.loc 4 96 11 is_stmt 0 discriminator 4 view .LVU189
 614 0178 2998      		cbi 0x5,1
  97:main.c        ****     _delay_us(DELAY);
 615               		.loc 4 97 5 is_stmt 1 discriminator 4 view .LVU190
 616               	.LVL47:
 617               	.LBB68:
 618               	.LBI68:
 255:/usr/avr/include/util/delay.h **** {
 619               		.loc 3 255 1 discriminator 4 view .LVU191
 620               	.LBB69:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 621               		.loc 3 257 2 discriminator 4 view .LVU192
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 622               		.loc 3 261 2 discriminator 4 view .LVU193
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 623               		.loc 3 262 2 discriminator 4 view .LVU194
 263:/usr/avr/include/util/delay.h **** 
 624               		.loc 3 263 2 discriminator 4 view .LVU195
 273:/usr/avr/include/util/delay.h **** 	#endif
 625               		.loc 3 273 3 discriminator 4 view .LVU196
 626               		.loc 3 276 2 discriminator 4 view .LVU197
 627 017a 8FE8      		ldi r24,lo8(399)
 628 017c 91E0      		ldi r25,hi8(399)
 629 017e 0197      	1:	sbiw r24,1
 630 0180 01F4      		brne 1b
 631 0182 00C0      		rjmp .
 632 0184 0000      		nop
 633               	.LVL48:
 634               		.loc 3 276 2 is_stmt 0 discriminator 4 view .LVU198
 635               	.LBE69:
 636               	.LBE68:
  98:main.c        ****     PORTB |= _BV(PB1);
 637               		.loc 4 98 5 is_stmt 1 discriminator 4 view .LVU199
 638               		.loc 4 98 11 is_stmt 0 discriminator 4 view .LVU200
 639 0186 299A      		sbi 0x5,1
  99:main.c        ****     _delay_us(DELAY);
 640               		.loc 4 99 5 is_stmt 1 discriminator 4 view .LVU201
 641               	.LVL49:
 642               	.LBB70:
 643               	.LBI70:
 255:/usr/avr/include/util/delay.h **** {
 644               		.loc 3 255 1 discriminator 4 view .LVU202
 645               	.LBB71:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 646               		.loc 3 257 2 discriminator 4 view .LVU203
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 647               		.loc 3 261 2 discriminator 4 view .LVU204
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 648               		.loc 3 262 2 discriminator 4 view .LVU205
 263:/usr/avr/include/util/delay.h **** 
 649               		.loc 3 263 2 discriminator 4 view .LVU206
 273:/usr/avr/include/util/delay.h **** 	#endif
 650               		.loc 3 273 3 discriminator 4 view .LVU207
 651               		.loc 3 276 2 discriminator 4 view .LVU208
 652 0188 AFE8      		ldi r26,lo8(399)
 653 018a B1E0      		ldi r27,hi8(399)
 654 018c 1197      	1:	sbiw r26,1
 655 018e 01F4      		brne 1b
 656 0190 00C0      		rjmp .
 657 0192 0000      		nop
 658               	.LVL50:
 659               		.loc 3 276 2 is_stmt 0 discriminator 4 view .LVU209
 660               	.LBE71:
 661               	.LBE70:
 100:main.c        ****     count--;
 662               		.loc 4 100 5 is_stmt 1 discriminator 4 view .LVU210
 663               		.loc 4 100 10 is_stmt 0 discriminator 4 view .LVU211
 664 0194 6150      		subi r22,lo8(-(-1))
 665               	.LVL51:
 101:main.c        ****   } while (count);
 666               		.loc 4 101 11 is_stmt 1 discriminator 4 view .LVU212
 667               		.loc 4 101 3 is_stmt 0 discriminator 4 view .LVU213
 668 0196 01F4      		brne .L19
 102:main.c        ****   PORTB &= ~_BV(PB2);
 669               		.loc 4 102 3 is_stmt 1 view .LVU214
 670               		.loc 4 102 9 is_stmt 0 view .LVU215
 671 0198 2A98      		cbi 0x5,2
 103:main.c        ****   PORTD |= _BV(PD4);
 672               		.loc 4 103 3 is_stmt 1 view .LVU216
 673               		.loc 4 103 9 is_stmt 0 view .LVU217
 674 019a 5C9A      		sbi 0xb,4
 675               	/* epilogue start */
 104:main.c        **** }
 676               		.loc 4 104 1 view .LVU218
 677 019c 0895      		ret
 678               		.cfi_endproc
 679               	.LFE22:
 681               	.global	setup_lcd
 683               	setup_lcd:
 684               	.LFB23:
 105:main.c        **** 
 106:main.c        **** void setup_lcd(void) {
 685               		.loc 4 106 22 is_stmt 1 view -0
 686               		.cfi_startproc
 687 019e CF93      		push r28
 688               	.LCFI0:
 689               		.cfi_def_cfa_offset 3
 690               		.cfi_offset 28, -2
 691 01a0 DF93      		push r29
 692               	.LCFI1:
 693               		.cfi_def_cfa_offset 4
 694               		.cfi_offset 29, -3
 695               	/* prologue: function */
 696               	/* frame size = 0 */
 697               	/* stack size = 2 */
 698               	.L__stack_usage = 2
 107:main.c        ****   for (int x = 0; x < 11; x++) {
 699               		.loc 4 107 3 view .LVU220
 700               	.LBB72:
 701               		.loc 4 107 8 view .LVU221
 702               	.LVL52:
 703               		.loc 4 107 19 view .LVU222
 704 01a2 C0E0      		ldi r28,lo8(commands)
 705 01a4 D0E0      		ldi r29,hi8(commands)
 706               	.LVL53:
 707               	.L23:
 108:main.c        ****     write(commands[x], 16);
 708               		.loc 4 108 5 discriminator 3 view .LVU223
 709 01a6 60E1      		ldi r22,lo8(16)
 710 01a8 8991      		ld r24,Y+
 711 01aa 9991      		ld r25,Y+
 712 01ac 0E94 0000 		call write
 713               	.LVL54:
 107:main.c        ****   for (int x = 0; x < 11; x++) {
 714               		.loc 4 107 27 discriminator 3 view .LVU224
 107:main.c        ****   for (int x = 0; x < 11; x++) {
 715               		.loc 4 107 19 discriminator 3 view .LVU225
 107:main.c        ****   for (int x = 0; x < 11; x++) {
 716               		.loc 4 107 3 is_stmt 0 discriminator 3 view .LVU226
 717 01b0 20E0      		ldi r18,hi8(commands+22)
 718 01b2 C030      		cpi r28,lo8(commands+22)
 719 01b4 D207      		cpc r29,r18
 720 01b6 01F4      		brne .L23
 721 01b8 C0E0      		ldi r28,lo8(commands2)
 722 01ba D0E0      		ldi r29,hi8(commands2)
 723               	.L26:
 724               	.LBE72:
 725               	.LBB73:
 109:main.c        ****   } //only for A035VW01
 110:main.c        ****   for (int x = 0; x < (sizeof(commands2) / sizeof(uint16_t)); x++) {
 111:main.c        ****     if (commands2[x] == 0x0000) {
 726               		.loc 4 111 5 is_stmt 1 view .LVU227
 727               		.loc 4 111 18 is_stmt 0 view .LVU228
 728 01bc 8991      		ld r24,Y+
 729 01be 9991      		ld r25,Y+
 730               		.loc 4 111 8 view .LVU229
 731 01c0 0097      		sbiw r24,0
 732 01c2 01F4      		brne .L24
 112:main.c        ****       _delay_ms(WAIT);
 733               		.loc 4 112 7 is_stmt 1 view .LVU230
 734               	.LVL55:
 735               	.LBB74:
 736               	.LBI74:
 166:/usr/avr/include/util/delay.h **** {
 737               		.loc 3 166 1 view .LVU231
 738               	.LBB75:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 739               		.loc 3 168 2 view .LVU232
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 740               		.loc 3 172 2 view .LVU233
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 741               		.loc 3 173 2 view .LVU234
 174:/usr/avr/include/util/delay.h **** 
 742               		.loc 3 174 2 view .LVU235
 184:/usr/avr/include/util/delay.h **** 	#endif
 743               		.loc 3 184 3 view .LVU236
 187:/usr/avr/include/util/delay.h **** 
 744               		.loc 3 187 2 view .LVU237
 745 01c4 8FEF      		ldi r24,lo8(383999)
 746 01c6 9BED      		ldi r25,hi8(383999)
 747 01c8 25E0      		ldi r18,hlo8(383999)
 748 01ca 8150      	1:	subi r24,1
 749 01cc 9040      		sbci r25,0
 750 01ce 2040      		sbci r18,0
 751 01d0 01F4      		brne 1b
 752 01d2 00C0      		rjmp .
 753 01d4 0000      		nop
 754               	.LVL56:
 187:/usr/avr/include/util/delay.h **** 
 755               		.loc 3 187 2 is_stmt 0 view .LVU238
 756               	.LBE75:
 757               	.LBE74:
 113:main.c        ****       continue;
 758               		.loc 4 113 7 is_stmt 1 view .LVU239
 759               	.L25:
 110:main.c        ****     if (commands2[x] == 0x0000) {
 760               		.loc 4 110 63 discriminator 2 view .LVU240
 110:main.c        ****     if (commands2[x] == 0x0000) {
 761               		.loc 4 110 19 discriminator 2 view .LVU241
 110:main.c        ****     if (commands2[x] == 0x0000) {
 762               		.loc 4 110 3 is_stmt 0 discriminator 2 view .LVU242
 763 01d6 80E0      		ldi r24,hi8(commands2+136)
 764 01d8 C030      		cpi r28,lo8(commands2+136)
 765 01da D807      		cpc r29,r24
 766 01dc 01F4      		brne .L26
 767               	/* epilogue start */
 768               	.LBE73:
 114:main.c        ****     }
 115:main.c        ****     write(commands2[x], 9);
 116:main.c        ****   } //only for A035VL01
 117:main.c        **** 
 118:main.c        **** }
 769               		.loc 4 118 1 view .LVU243
 770 01de DF91      		pop r29
 771 01e0 CF91      		pop r28
 772 01e2 0895      		ret
 773               	.L24:
 774               	.LBB76:
 115:main.c        ****   } //only for A035VL01
 775               		.loc 4 115 5 is_stmt 1 view .LVU244
 776 01e4 69E0      		ldi r22,lo8(9)
 777 01e6 0E94 0000 		call write
 778               	.LVL57:
 779 01ea 00C0      		rjmp .L25
 780               	.LBE76:
 781               		.cfi_endproc
 782               	.LFE23:
 784               	.global	readAna
 786               	readAna:
 787               	.LVL58:
 788               	.LFB24:
 119:main.c        **** 
 120:main.c        **** uint16_t readAna(uint8_t channel) {
 789               		.loc 4 120 35 view -0
 790               		.cfi_startproc
 791               	/* prologue: function */
 792               	/* frame size = 0 */
 793               	/* stack size = 0 */
 794               	.L__stack_usage = 0
 121:main.c        ****   uint8_t low, high;
 795               		.loc 4 121 3 view .LVU246
 122:main.c        ****   ADCSRA |= _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
 796               		.loc 4 122 3 view .LVU247
 797               		.loc 4 122 10 is_stmt 0 view .LVU248
 798 01ec 9091 7A00 		lds r25,122
 799 01f0 9760      		ori r25,lo8(7)
 800 01f2 9093 7A00 		sts 122,r25
 123:main.c        ****   ADCSRB = 0x40;
 801               		.loc 4 123 3 is_stmt 1 view .LVU249
 802               		.loc 4 123 10 is_stmt 0 view .LVU250
 803 01f6 90E4      		ldi r25,lo8(64)
 804 01f8 9093 7B00 		sts 123,r25
 124:main.c        ****   ADMUX = ((0 << REFS1) | (1 << REFS0) | (0 << ADLAR));
 805               		.loc 4 124 3 is_stmt 1 view .LVU251
 806               		.loc 4 124 9 is_stmt 0 view .LVU252
 807 01fc 9093 7C00 		sts 124,r25
 125:main.c        **** 
 126:main.c        ****   if (channel >= 8) //
 808               		.loc 4 126 3 is_stmt 1 view .LVU253
 809               		.loc 4 126 6 is_stmt 0 view .LVU254
 810 0200 8830      		cpi r24,lo8(8)
 811 0202 00F0      		brlo .L30
 127:main.c        ****   {
 128:main.c        ****     channel -= 0x08; // ch - 8
 812               		.loc 4 128 5 is_stmt 1 view .LVU255
 813               		.loc 4 128 13 is_stmt 0 view .LVU256
 814 0204 8850      		subi r24,lo8(-(-8))
 815               	.LVL59:
 129:main.c        ****     ADCSRB |= (1 << MUX5); // set MUX5 on ADCSRB to read upper bit ADC8-ADC13
 816               		.loc 4 129 5 is_stmt 1 view .LVU257
 817               		.loc 4 129 12 is_stmt 0 view .LVU258
 818 0206 9091 7B00 		lds r25,123
 819 020a 9062      		ori r25,lo8(32)
 820               	.L34:
 130:main.c        ****   } else {
 131:main.c        ****     ADCSRB &= ~(1 << MUX5); // clear MUX 5 
 821               		.loc 4 131 12 view .LVU259
 822 020c 9093 7B00 		sts 123,r25
 132:main.c        ****   }
 133:main.c        ****   channel &= 0x07;
 823               		.loc 4 133 3 is_stmt 1 view .LVU260
 824               	.LVL60:
 134:main.c        ****   ADMUX |= channel; // selecting channel
 825               		.loc 4 134 3 view .LVU261
 826               		.loc 4 134 9 is_stmt 0 view .LVU262
 827 0210 9091 7C00 		lds r25,124
 133:main.c        ****   ADMUX |= channel; // selecting channel
 828               		.loc 4 133 11 view .LVU263
 829 0214 8770      		andi r24,lo8(7)
 830               	.LVL61:
 831               		.loc 4 134 9 view .LVU264
 832 0216 892B      		or r24,r25
 833               	.LVL62:
 834               		.loc 4 134 9 view .LVU265
 835 0218 8093 7C00 		sts 124,r24
 135:main.c        **** 
 136:main.c        ****   ADCSRA |= _BV(ADEN);
 836               		.loc 4 136 3 is_stmt 1 view .LVU266
 837               		.loc 4 136 10 is_stmt 0 view .LVU267
 838 021c 8091 7A00 		lds r24,122
 839 0220 8068      		ori r24,lo8(-128)
 840 0222 8093 7A00 		sts 122,r24
 137:main.c        ****   _delay_ms(2);
 841               		.loc 4 137 3 is_stmt 1 view .LVU268
 842               	.LVL63:
 843               	.LBB77:
 844               	.LBI77:
 166:/usr/avr/include/util/delay.h **** {
 845               		.loc 3 166 1 view .LVU269
 846               	.LBB78:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 847               		.loc 3 168 2 view .LVU270
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 848               		.loc 3 172 2 view .LVU271
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 849               		.loc 3 173 2 view .LVU272
 174:/usr/avr/include/util/delay.h **** 
 850               		.loc 3 174 2 view .LVU273
 184:/usr/avr/include/util/delay.h **** 	#endif
 851               		.loc 3 184 3 view .LVU274
 187:/usr/avr/include/util/delay.h **** 
 852               		.loc 3 187 2 view .LVU275
 853 0226 8FE3      		ldi r24,lo8(7999)
 854 0228 9FE1      		ldi r25,hi8(7999)
 855 022a 0197      	1:	sbiw r24,1
 856 022c 01F4      		brne 1b
 857 022e 00C0      		rjmp .
 858 0230 0000      		nop
 859               	.LVL64:
 187:/usr/avr/include/util/delay.h **** 
 860               		.loc 3 187 2 is_stmt 0 view .LVU276
 861               	.LBE78:
 862               	.LBE77:
 138:main.c        ****   ADCSRA |= (1 << ADSC);
 863               		.loc 4 138 3 is_stmt 1 view .LVU277
 864               		.loc 4 138 10 is_stmt 0 view .LVU278
 865 0232 8091 7A00 		lds r24,122
 866 0236 8064      		ori r24,lo8(64)
 867 0238 8093 7A00 		sts 122,r24
 139:main.c        **** 
 140:main.c        ****   while ((ADCSRA & _BV(ADSC))); // measuring 
 868               		.loc 4 140 3 is_stmt 1 view .LVU279
 869               	.L32:
 870               		.loc 4 140 31 discriminator 1 view .LVU280
 871               		.loc 4 140 9 discriminator 1 view .LVU281
 872               		.loc 4 140 11 is_stmt 0 discriminator 1 view .LVU282
 873 023c 8091 7A00 		lds r24,122
 874               		.loc 4 140 9 discriminator 1 view .LVU283
 875 0240 86FD      		sbrc r24,6
 876 0242 00C0      		rjmp .L32
 141:main.c        ****   low = ADCL;
 877               		.loc 4 141 3 is_stmt 1 view .LVU284
 878               		.loc 4 141 7 is_stmt 0 view .LVU285
 879 0244 8091 7800 		lds r24,120
 880               	.LVL65:
 142:main.c        ****   high = ADCH;
 881               		.loc 4 142 3 is_stmt 1 view .LVU286
 882               		.loc 4 142 8 is_stmt 0 view .LVU287
 883 0248 9091 7900 		lds r25,121
 884               	.LVL66:
 143:main.c        ****   return (high << 8) | low;
 885               		.loc 4 143 3 is_stmt 1 view .LVU288
 886               	/* epilogue start */
 144:main.c        **** }
 887               		.loc 4 144 1 is_stmt 0 view .LVU289
 888 024c 0895      		ret
 889               	.LVL67:
 890               	.L30:
 131:main.c        ****   }
 891               		.loc 4 131 5 is_stmt 1 view .LVU290
 131:main.c        ****   }
 892               		.loc 4 131 12 is_stmt 0 view .LVU291
 893 024e 9091 7B00 		lds r25,123
 894 0252 9F7D      		andi r25,lo8(-33)
 895 0254 00C0      		rjmp .L34
 896               		.cfi_endproc
 897               	.LFE24:
 899               	.global	readVcc
 901               	readVcc:
 902               	.LFB25:
 145:main.c        **** 
 146:main.c        **** uint16_t readVcc(void) {
 903               		.loc 4 146 24 is_stmt 1 view -0
 904               		.cfi_startproc
 905               	/* prologue: function */
 906               	/* frame size = 0 */
 907               	/* stack size = 0 */
 908               	.L__stack_usage = 0
 147:main.c        ****   ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
 909               		.loc 4 147 3 view .LVU293
 910               		.loc 4 147 9 is_stmt 0 view .LVU294
 911 0256 8EE5      		ldi r24,lo8(94)
 912 0258 8093 7C00 		sts 124,r24
 148:main.c        ****   ADCSRA |= _BV(ADEN);
 913               		.loc 4 148 3 is_stmt 1 view .LVU295
 914               		.loc 4 148 10 is_stmt 0 view .LVU296
 915 025c 8091 7A00 		lds r24,122
 916 0260 8068      		ori r24,lo8(-128)
 917 0262 8093 7A00 		sts 122,r24
 149:main.c        ****   ADCSRB &= ~_BV(MUX5);
 918               		.loc 4 149 3 is_stmt 1 view .LVU297
 919               		.loc 4 149 10 is_stmt 0 view .LVU298
 920 0266 8091 7B00 		lds r24,123
 921 026a 8F7D      		andi r24,lo8(-33)
 922 026c 8093 7B00 		sts 123,r24
 150:main.c        ****   _delay_ms(2);
 923               		.loc 4 150 3 is_stmt 1 view .LVU299
 924               	.LVL68:
 925               	.LBB79:
 926               	.LBI79:
 166:/usr/avr/include/util/delay.h **** {
 927               		.loc 3 166 1 view .LVU300
 928               	.LBB80:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 929               		.loc 3 168 2 view .LVU301
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 930               		.loc 3 172 2 view .LVU302
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 931               		.loc 3 173 2 view .LVU303
 174:/usr/avr/include/util/delay.h **** 
 932               		.loc 3 174 2 view .LVU304
 184:/usr/avr/include/util/delay.h **** 	#endif
 933               		.loc 3 184 3 view .LVU305
 187:/usr/avr/include/util/delay.h **** 
 934               		.loc 3 187 2 view .LVU306
 935 0270 8FE3      		ldi r24,lo8(7999)
 936 0272 9FE1      		ldi r25,hi8(7999)
 937 0274 0197      	1:	sbiw r24,1
 938 0276 01F4      		brne 1b
 939 0278 00C0      		rjmp .
 940 027a 0000      		nop
 941               	.LVL69:
 187:/usr/avr/include/util/delay.h **** 
 942               		.loc 3 187 2 is_stmt 0 view .LVU307
 943               	.LBE80:
 944               	.LBE79:
 151:main.c        ****   ADCSRA |= 1 << ADSC;
 945               		.loc 4 151 3 is_stmt 1 view .LVU308
 946               		.loc 4 151 10 is_stmt 0 view .LVU309
 947 027c 8091 7A00 		lds r24,122
 948 0280 8064      		ori r24,lo8(64)
 949 0282 8093 7A00 		sts 122,r24
 152:main.c        ****   while ((ADCSRA & _BV(ADSC))); // measuring
 950               		.loc 4 152 3 is_stmt 1 view .LVU310
 951               	.L36:
 952               		.loc 4 152 31 discriminator 1 view .LVU311
 953               		.loc 4 152 9 discriminator 1 view .LVU312
 954               		.loc 4 152 11 is_stmt 0 discriminator 1 view .LVU313
 955 0286 8091 7A00 		lds r24,122
 956               		.loc 4 152 9 discriminator 1 view .LVU314
 957 028a 86FD      		sbrc r24,6
 958 028c 00C0      		rjmp .L36
 153:main.c        ****   ADCSRA |= 1 << ADSC;
 959               		.loc 4 153 3 is_stmt 1 view .LVU315
 960               		.loc 4 153 10 is_stmt 0 view .LVU316
 961 028e 8091 7A00 		lds r24,122
 962 0292 8064      		ori r24,lo8(64)
 963 0294 8093 7A00 		sts 122,r24
 154:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 964               		.loc 4 154 3 is_stmt 1 view .LVU317
 965               	.L37:
 966               		.loc 4 154 31 discriminator 1 view .LVU318
 967               		.loc 4 154 9 discriminator 1 view .LVU319
 968               		.loc 4 154 11 is_stmt 0 discriminator 1 view .LVU320
 969 0298 8091 7A00 		lds r24,122
 970               		.loc 4 154 9 discriminator 1 view .LVU321
 971 029c 86FD      		sbrc r24,6
 972 029e 00C0      		rjmp .L37
 155:main.c        ****   return 1125300L / (ADCL | (ADCH<<8));
 973               		.loc 4 155 3 is_stmt 1 view .LVU322
 974               		.loc 4 155 22 is_stmt 0 view .LVU323
 975 02a0 2091 7800 		lds r18,120
 976               		.loc 4 155 30 view .LVU324
 977 02a4 8091 7900 		lds r24,121
 978               		.loc 4 155 27 view .LVU325
 979 02a8 382F      		mov r19,r24
 980 02aa 032E      		mov __tmp_reg__,r19
 981 02ac 000C      		lsl r0
 982 02ae 440B      		sbc r20,r20
 983 02b0 550B      		sbc r21,r21
 984               		.loc 4 155 19 view .LVU326
 985 02b2 64EB      		ldi r22,lo8(-76)
 986 02b4 7BE2      		ldi r23,lo8(43)
 987 02b6 81E1      		ldi r24,lo8(17)
 988 02b8 90E0      		ldi r25,0
 989 02ba 0E94 0000 		call __divmodsi4
 156:main.c        **** }
 990               		.loc 4 156 1 view .LVU327
 991 02be C901      		movw r24,r18
 992               	/* epilogue start */
 993 02c0 0895      		ret
 994               		.cfi_endproc
 995               	.LFE25:
 997               	.global	GetTemp
 999               	GetTemp:
 1000               	.LFB26:
 157:main.c        **** 
 158:main.c        **** uint16_t GetTemp(void) {
 1001               		.loc 4 158 24 is_stmt 1 view -0
 1002               		.cfi_startproc
 1003               	/* prologue: function */
 1004               	/* frame size = 0 */
 1005               	/* stack size = 0 */
 1006               	.L__stack_usage = 0
 159:main.c        ****   ADMUX = _BV(REFS1) | _BV(REFS0) | 7; // Set internal V reference, temperature reading
 1007               		.loc 4 159 3 view .LVU329
 1008               		.loc 4 159 9 is_stmt 0 view .LVU330
 1009 02c2 87EC      		ldi r24,lo8(-57)
 1010 02c4 8093 7C00 		sts 124,r24
 160:main.c        ****   ADCSRB = 0x20; // ref  24.6
 1011               		.loc 4 160 3 is_stmt 1 view .LVU331
 1012               		.loc 4 160 10 is_stmt 0 view .LVU332
 1013 02c8 80E2      		ldi r24,lo8(32)
 1014 02ca 8093 7B00 		sts 123,r24
 161:main.c        ****   ADCSRA &= ~(_BV(ADATE) | _BV(ADIE)); // Clear auto trigger and interrupt enable
 1015               		.loc 4 161 3 is_stmt 1 view .LVU333
 1016               		.loc 4 161 10 is_stmt 0 view .LVU334
 1017 02ce 8091 7A00 		lds r24,122
 1018 02d2 877D      		andi r24,lo8(-41)
 1019 02d4 8093 7A00 		sts 122,r24
 162:main.c        ****   ADCSRA |= _BV(ADEN); // enable the ADC
 1020               		.loc 4 162 3 is_stmt 1 view .LVU335
 1021               		.loc 4 162 10 is_stmt 0 view .LVU336
 1022 02d8 8091 7A00 		lds r24,122
 1023 02dc 8068      		ori r24,lo8(-128)
 1024 02de 8093 7A00 		sts 122,r24
 163:main.c        ****   _delay_ms(2); // delay for voltages to become stable.
 1025               		.loc 4 163 3 is_stmt 1 view .LVU337
 1026               	.LVL70:
 1027               	.LBB81:
 1028               	.LBI81:
 166:/usr/avr/include/util/delay.h **** {
 1029               		.loc 3 166 1 view .LVU338
 1030               	.LBB82:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1031               		.loc 3 168 2 view .LVU339
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1032               		.loc 3 172 2 view .LVU340
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1033               		.loc 3 173 2 view .LVU341
 174:/usr/avr/include/util/delay.h **** 
 1034               		.loc 3 174 2 view .LVU342
 184:/usr/avr/include/util/delay.h **** 	#endif
 1035               		.loc 3 184 3 view .LVU343
 187:/usr/avr/include/util/delay.h **** 
 1036               		.loc 3 187 2 view .LVU344
 1037 02e2 8FE3      		ldi r24,lo8(7999)
 1038 02e4 9FE1      		ldi r25,hi8(7999)
 1039 02e6 0197      	1:	sbiw r24,1
 1040 02e8 01F4      		brne 1b
 1041 02ea 00C0      		rjmp .
 1042 02ec 0000      		nop
 1043               	.LVL71:
 187:/usr/avr/include/util/delay.h **** 
 1044               		.loc 3 187 2 is_stmt 0 view .LVU345
 1045               	.LBE82:
 1046               	.LBE81:
 164:main.c        **** 
 165:main.c        ****   ADCSRA |= _BV(ADSC); // measuring
 1047               		.loc 4 165 3 is_stmt 1 view .LVU346
 1048               		.loc 4 165 10 is_stmt 0 view .LVU347
 1049 02ee 8091 7A00 		lds r24,122
 1050 02f2 8064      		ori r24,lo8(64)
 1051 02f4 8093 7A00 		sts 122,r24
 166:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 1052               		.loc 4 166 3 is_stmt 1 view .LVU348
 1053               	.L41:
 1054               		.loc 4 166 31 discriminator 1 view .LVU349
 1055               		.loc 4 166 9 discriminator 1 view .LVU350
 1056               		.loc 4 166 11 is_stmt 0 discriminator 1 view .LVU351
 1057 02f8 8091 7A00 		lds r24,122
 1058               		.loc 4 166 9 discriminator 1 view .LVU352
 1059 02fc 86FD      		sbrc r24,6
 1060 02fe 00C0      		rjmp .L41
 167:main.c        **** 
 168:main.c        ****   ADCSRA |= _BV(ADSC);
 1061               		.loc 4 168 3 is_stmt 1 view .LVU353
 1062               		.loc 4 168 10 is_stmt 0 view .LVU354
 1063 0300 8091 7A00 		lds r24,122
 1064 0304 8064      		ori r24,lo8(64)
 1065 0306 8093 7A00 		sts 122,r24
 169:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 1066               		.loc 4 169 3 is_stmt 1 view .LVU355
 1067               	.L42:
 1068               		.loc 4 169 31 discriminator 1 view .LVU356
 1069               		.loc 4 169 9 discriminator 1 view .LVU357
 1070               		.loc 4 169 11 is_stmt 0 discriminator 1 view .LVU358
 1071 030a 8091 7A00 		lds r24,122
 1072               		.loc 4 169 9 discriminator 1 view .LVU359
 1073 030e 86FD      		sbrc r24,6
 1074 0310 00C0      		rjmp .L42
 170:main.c        **** 
 171:main.c        ****   return (ADCL | (ADCH << 8));
 1075               		.loc 4 171 3 is_stmt 1 view .LVU360
 1076               		.loc 4 171 11 is_stmt 0 view .LVU361
 1077 0312 8091 7800 		lds r24,120
 1078               		.loc 4 171 19 view .LVU362
 1079 0316 9091 7900 		lds r25,121
 1080               	/* epilogue start */
 172:main.c        **** }
 1081               		.loc 4 172 1 view .LVU363
 1082 031a 0895      		ret
 1083               		.cfi_endproc
 1084               	.LFE26:
 1086               	.global	freeRam
 1088               	freeRam:
 1089               	.LFB27:
 173:main.c        **** 
 174:main.c        **** uint16_t freeRam(void) {
 1090               		.loc 4 174 24 is_stmt 1 view -0
 1091               		.cfi_startproc
 1092 031c CF93      		push r28
 1093               	.LCFI2:
 1094               		.cfi_def_cfa_offset 3
 1095               		.cfi_offset 28, -2
 1096 031e DF93      		push r29
 1097               	.LCFI3:
 1098               		.cfi_def_cfa_offset 4
 1099               		.cfi_offset 29, -3
 1100 0320 00D0      		rcall .
 1101               	.LCFI4:
 1102               		.cfi_def_cfa_offset 6
 1103 0322 CDB7      		in r28,__SP_L__
 1104 0324 DEB7      		in r29,__SP_H__
 1105               	.LCFI5:
 1106               		.cfi_def_cfa_register 28
 1107               	/* prologue: function */
 1108               	/* frame size = 2 */
 1109               	/* stack size = 4 */
 1110               	.L__stack_usage = 4
 175:main.c        ****   extern char __heap_start, * __brkval;
 1111               		.loc 4 175 3 view .LVU365
 176:main.c        ****   int v;
 1112               		.loc 4 176 3 view .LVU366
 177:main.c        ****   return (uint16_t) & v - (__brkval == 0 ? (int) & __heap_start : (int) __brkval);
 1113               		.loc 4 177 3 view .LVU367
 1114               		.loc 4 177 37 is_stmt 0 view .LVU368
 1115 0326 2091 0000 		lds r18,__brkval
 1116 032a 3091 0000 		lds r19,__brkval+1
 1117               		.loc 4 177 65 view .LVU369
 1118 032e 2115      		cp r18,__zero_reg__
 1119 0330 3105      		cpc r19,__zero_reg__
 1120 0332 01F4      		brne .L46
 1121 0334 20E0      		ldi r18,lo8(__heap_start)
 1122 0336 30E0      		ldi r19,hi8(__heap_start)
 1123               	.L46:
 178:main.c        **** }
 1124               		.loc 4 178 1 discriminator 4 view .LVU370
 1125 0338 CE01      		movw r24,r28
 1126 033a 0196      		adiw r24,1
 1127 033c 821B      		sub r24,r18
 1128 033e 930B      		sbc r25,r19
 1129               	/* epilogue start */
 1130 0340 0F90      		pop __tmp_reg__
 1131 0342 0F90      		pop __tmp_reg__
 1132 0344 DF91      		pop r29
 1133 0346 CF91      		pop r28
 1134 0348 0895      		ret
 1135               		.cfi_endproc
 1136               	.LFE27:
 1138               	.global	I2C_init
 1140               	I2C_init:
 1141               	.LVL72:
 1142               	.LFB28:
 179:main.c        **** 
 180:main.c        **** 
 181:main.c        **** void I2C_init(uint8_t address) // setup ATmega as I2C slave
 182:main.c        **** {
 1143               		.loc 4 182 1 is_stmt 1 view -0
 1144               		.cfi_startproc
 1145               	/* prologue: function */
 1146               	/* frame size = 0 */
 1147               	/* stack size = 0 */
 1148               	.L__stack_usage = 0
 183:main.c        ****   cli();
 1149               		.loc 4 183 3 view .LVU372
 1150               	/* #APP */
 1151               	 ;  183 "main.c" 1
 1152 034a F894      		cli
 1153               	 ;  0 "" 2
 184:main.c        **** 
 185:main.c        ****   TWAR = (address << 1); // Slave address without general call.
 1154               		.loc 4 185 3 view .LVU373
 1155               		.loc 4 185 19 is_stmt 0 view .LVU374
 1156               	/* #NOAPP */
 1157 034c 880F      		lsl r24
 1158               	.LVL73:
 1159               		.loc 4 185 8 view .LVU375
 1160 034e 8093 BA00 		sts 186,r24
 186:main.c        ****   TWCR = (1 << TWEN) | // TWI Interface enabled.
 1161               		.loc 4 186 3 is_stmt 1 view .LVU376
 1162               		.loc 4 186 8 is_stmt 0 view .LVU377
 1163 0352 85EC      		ldi r24,lo8(-59)
 1164 0354 8093 BC00 		sts 188,r24
 187:main.c        ****     (1 << TWIE) | (1 << TWINT) | // Enable TWI interrupt and clear the flag.
 188:main.c        ****     (1 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // Prepare to ACK next time the Slave is addressed.
 189:main.c        ****     (0 << TWWC);
 190:main.c        **** 
 191:main.c        ****   buffer_address = 0xFF;
 1165               		.loc 4 191 3 is_stmt 1 view .LVU378
 1166               		.loc 4 191 18 is_stmt 0 view .LVU379
 1167 0358 8FEF      		ldi r24,lo8(-1)
 1168 035a 8093 0000 		sts buffer_address,r24
 1169               	/* epilogue start */
 192:main.c        **** 
 193:main.c        **** }
 1170               		.loc 4 193 1 view .LVU380
 1171 035e 0895      		ret
 1172               		.cfi_endproc
 1173               	.LFE28:
 1175               	.global	__vector_9
 1177               	__vector_9:
 1178               	.LFB29:
 194:main.c        **** 
 195:main.c        **** ISR(PCINT0_vect) {
 1179               		.loc 4 195 18 is_stmt 1 view -0
 1180               		.cfi_startproc
 1181 0360 8F93 8FB7 		__gcc_isr 1
 1181      8F93 
 1182 0366 9F93      		push r25
 1183               	.LCFI6:
 1184               		.cfi_def_cfa_offset 3
 1185               		.cfi_offset 25, -2
 1186               	/* prologue: Signal */
 1187               	/* frame size = 0 */
 1188               	/* stack size = 1...5 */
 1189               	.L__stack_usage = 1 + __gcc_isr.n_pushed
 196:main.c        ****   sei();
 1190               		.loc 4 196 3 view .LVU382
 1191               	/* #APP */
 1192               	 ;  196 "main.c" 1
 1193 0368 7894      		sei
 1194               	 ;  0 "" 2
 197:main.c        ****   if (bit_is_clear(PINB, PB0)) fanspin++;
 1195               		.loc 4 197 3 view .LVU383
 1196               		.loc 4 197 6 is_stmt 0 view .LVU384
 1197               	/* #NOAPP */
 1198 036a 1899      		sbic 0x3,0
 1199 036c 00C0      		rjmp .L49
 1200               		.loc 4 197 32 is_stmt 1 discriminator 1 view .LVU385
 1201               		.loc 4 197 39 is_stmt 0 discriminator 1 view .LVU386
 1202 036e 8091 0000 		lds r24,fanspin
 1203 0372 9091 0000 		lds r25,fanspin+1
 1204 0376 0196      		adiw r24,1
 1205 0378 9093 0000 		sts fanspin+1,r25
 1206 037c 8093 0000 		sts fanspin,r24
 1207               	.L49:
 1208               	/* epilogue start */
 198:main.c        **** } // counting VENT_RPM
 1209               		.loc 4 198 1 view .LVU387
 1210 0380 9F91      		pop r25
 1211 0382 8F91 8FBF 		__gcc_isr 2
 1211      8F91 
 1212 0388 1895      		reti
 1213               		__gcc_isr 0,r24
 1214               		.cfi_endproc
 1215               	.LFE29:
 1217               	.global	__vector_23
 1219               	__vector_23:
 1220               	.LFB30:
 199:main.c        **** 
 200:main.c        **** ISR(TIMER0_OVF_vect) {
 1221               		.loc 4 200 22 is_stmt 1 view -0
 1222               		.cfi_startproc
 1223 038a 8F93 8FB7 		__gcc_isr 1
 1223      8F93 
 1224 0390 9F93      		push r25
 1225               	.LCFI7:
 1226               		.cfi_def_cfa_offset 3
 1227               		.cfi_offset 25, -2
 1228               	/* prologue: Signal */
 1229               	/* frame size = 0 */
 1230               	/* stack size = 1...5 */
 1231               	.L__stack_usage = 1 + __gcc_isr.n_pushed
 201:main.c        ****   isrtimer++;
 1232               		.loc 4 201 3 view .LVU389
 1233               		.loc 4 201 11 is_stmt 0 view .LVU390
 1234 0392 8091 0000 		lds r24,isrtimer
 1235 0396 9091 0000 		lds r25,isrtimer+1
 1236 039a 0196      		adiw r24,1
 1237 039c 9093 0000 		sts isrtimer+1,r25
 1238 03a0 8093 0000 		sts isrtimer,r24
 1239               	/* epilogue start */
 202:main.c        **** } // reuse timer0 for counting VENT_RPM
 1240               		.loc 4 202 1 view .LVU391
 1241 03a4 9F91      		pop r25
 1242 03a6 8F91 8FBF 		__gcc_isr 2
 1242      8F91 
 1243 03ac 1895      		reti
 1244               		__gcc_isr 0,r24
 1245               		.cfi_endproc
 1246               	.LFE30:
 1248               	.global	__vector_36
 1250               	__vector_36:
 1251               	.LFB31:
 203:main.c        **** 
 204:main.c        **** ISR(TWI_vect) {
 1252               		.loc 4 204 15 is_stmt 1 view -0
 1253               		.cfi_startproc
 1254 03ae 1F92      		push r1
 1255               	.LCFI8:
 1256               		.cfi_def_cfa_offset 3
 1257               		.cfi_offset 1, -2
 1258 03b0 0F92      		push r0
 1259               	.LCFI9:
 1260               		.cfi_def_cfa_offset 4
 1261               		.cfi_offset 0, -3
 1262 03b2 0FB6      		in r0,__SREG__
 1263 03b4 0F92      		push r0
 1264 03b6 1124      		clr __zero_reg__
 1265 03b8 2F93      		push r18
 1266               	.LCFI10:
 1267               		.cfi_def_cfa_offset 5
 1268               		.cfi_offset 18, -4
 1269 03ba 3F93      		push r19
 1270               	.LCFI11:
 1271               		.cfi_def_cfa_offset 6
 1272               		.cfi_offset 19, -5
 1273 03bc 4F93      		push r20
 1274               	.LCFI12:
 1275               		.cfi_def_cfa_offset 7
 1276               		.cfi_offset 20, -6
 1277 03be 5F93      		push r21
 1278               	.LCFI13:
 1279               		.cfi_def_cfa_offset 8
 1280               		.cfi_offset 21, -7
 1281 03c0 6F93      		push r22
 1282               	.LCFI14:
 1283               		.cfi_def_cfa_offset 9
 1284               		.cfi_offset 22, -8
 1285 03c2 7F93      		push r23
 1286               	.LCFI15:
 1287               		.cfi_def_cfa_offset 10
 1288               		.cfi_offset 23, -9
 1289 03c4 8F93      		push r24
 1290               	.LCFI16:
 1291               		.cfi_def_cfa_offset 11
 1292               		.cfi_offset 24, -10
 1293 03c6 9F93      		push r25
 1294               	.LCFI17:
 1295               		.cfi_def_cfa_offset 12
 1296               		.cfi_offset 25, -11
 1297 03c8 AF93      		push r26
 1298               	.LCFI18:
 1299               		.cfi_def_cfa_offset 13
 1300               		.cfi_offset 26, -12
 1301 03ca BF93      		push r27
 1302               	.LCFI19:
 1303               		.cfi_def_cfa_offset 14
 1304               		.cfi_offset 27, -13
 1305 03cc EF93      		push r30
 1306               	.LCFI20:
 1307               		.cfi_def_cfa_offset 15
 1308               		.cfi_offset 30, -14
 1309 03ce FF93      		push r31
 1310               	.LCFI21:
 1311               		.cfi_def_cfa_offset 16
 1312               		.cfi_offset 31, -15
 1313               	/* prologue: Signal */
 1314               	/* frame size = 0 */
 1315               	/* stack size = 15 */
 1316               	.L__stack_usage = 15
 205:main.c        **** 
 206:main.c        ****   switch (TW_STATUS) {
 1317               		.loc 4 206 3 view .LVU393
 1318               		.loc 4 206 11 is_stmt 0 view .LVU394
 1319 03d0 8091 B900 		lds r24,185
 1320 03d4 982F      		mov r25,r24
 1321 03d6 987F      		andi r25,lo8(-8)
 1322               		.loc 4 206 3 view .LVU395
 1323 03d8 9038      		cpi r25,lo8(-128)
 1324 03da 01F0      		breq .L53
 1325 03dc 00F4      		brsh .L54
 1326 03de 9923      		tst r25
 1327 03e0 01F4      		brne .+2
 1328 03e2 00C0      		rjmp .L55
 1329 03e4 9036      		cpi r25,lo8(96)
 1330 03e6 01F0      		breq .L56
 1331               	.L57:
 207:main.c        **** 
 208:main.c        ****   case TW_SR_SLA_ACK:
 209:main.c        **** 
 210:main.c        ****     TWCR = (1 << TWIE) | (1 << TWINT) | (1 << TWEA) | (1 << TWEN);
 211:main.c        ****     buffer_address = 0xFF; // set buffer pos undefined
 212:main.c        ****     break;
 213:main.c        ****    
 214:main.c        ****   case TW_SR_DATA_ACK: // received data from master
 215:main.c        ****     
 216:main.c        ****     if (buffer_address == 0xFF) {
 217:main.c        **** 
 218:main.c        ****       commandbyte = TWDR;
 219:main.c        ****       crc = _crc8_ccitt_update(0, commandbyte);
 220:main.c        ****       buffer_address = 0;
 221:main.c        ****       i2cerror = 0;
 222:main.c        **** 
 223:main.c        **** 
 224:main.c        ****       switch (commandbyte) {		 
 225:main.c        **** 
 226:main.c        **** 		  case 0x00: i2cbuffer = a0; break;
 227:main.c        **** 		  case 0x01: i2cbuffer = a1; break;
 228:main.c        **** 		  case 0x02: i2cbuffer = a2; break;
 229:main.c        **** 		  case 0x03: i2cbuffer = a3; break;
 230:main.c        **** 		  case 0x04: i2cbuffer = a4; break;
 231:main.c        **** 		  case 0x05: i2cbuffer = a5; break;
 232:main.c        **** 		  case 0x06: i2cbuffer = a7; break;
 233:main.c        **** 		  case 0x08: i2cbuffer = rpm;break;
 234:main.c        **** 		  case 0x09: i2cbuffer = vcc; break;
 235:main.c        **** 		  case 0x0A: i2cbuffer = temp;break;
 236:main.c        **** 		  case 0x0B: i2cbuffer = freeRam(); break;
 237:main.c        **** 		  case 0x14: i2cbuffer = a7avg; break;
 238:main.c        **** 
 239:main.c        **** 
 240:main.c        **** 	    }
 241:main.c        ****       } 
 242:main.c        ****       else { 
 243:main.c        **** 
 244:main.c        ****       
 245:main.c        ****  
 246:main.c        ****       if (buffer_address == 0) {twdrbuffer = TWDR; crc = _crc8_ccitt_update(crc,TWDR);}
 247:main.c        **** 
 248:main.c        ****       else  if ((buffer_address == 1) & (TWDR == crc)) {
 249:main.c        **** 
 250:main.c        ****            if (commandbyte == 0x87 ) {newbllevel = twdrbuffer;}
 251:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 252:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 253:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 254:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 255:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 256:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 257:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 258:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 259:main.c        ****       else if (commandbyte == 0x95 ) {led[0].g = twdrbuffer;changeled = 1;}  //set g color
 260:main.c        ****       else if (commandbyte == 0x96 ) {led[0].b = twdrbuffer;changeled = 1;}  //set b color
 261:main.c        **** 
 262:main.c        ****       else {i2cerror++;} 
 263:main.c        ****       } 
 264:main.c        ****       else {i2cerror++;}
 265:main.c        **** 
 266:main.c        ****       buffer_address++;
 267:main.c        **** 
 268:main.c        ****       }
 269:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 270:main.c        ****       if ((commandbyte == 0x92) & (twdrbuffer == 0x02)) {_delay_us(25); PORTB &= ~_BV(PB5);}
 271:main.c        ****       break;
 272:main.c        **** 
 273:main.c        ****     case TW_ST_SLA_ACK: //  slave adressed
 274:main.c        ****     case TW_ST_DATA_ACK:
 275:main.c        ****       
 276:main.c        ****       _delay_us(0.3); 
 277:main.c        **** 
 278:main.c        **** 	     switch(commandbyte)  {		 
 279:main.c        **** 
 280:main.c        ****                  case 0x87:
 281:main.c        ****                  case 0x8D:
 282:main.c        ****                  case 0x8E:
 283:main.c        ****                  case 0x8F:
 284:main.c        ****                  case 0x90:
 285:main.c        ****                  case 0x91:
 286:main.c        ****                  case 0x92:
 287:main.c        ****                  case 0x93:
 288:main.c        ****                  case 0x94:
 289:main.c        ****                  case 0x95:
 290:main.c        ****                  case 0x96:  { TWDR = crc;  crc = 0xFF;} break;
 291:main.c        ****                  case 0x00:
 292:main.c        ****                  case 0x01:
 293:main.c        ****                  case 0x02:
 294:main.c        ****                  case 0x03:
 295:main.c        ****                  case 0x04:
 296:main.c        ****                  case 0x05:
 297:main.c        ****                  case 0x06:
 298:main.c        ****                  case 0x08: 
 299:main.c        ****                  case 0x09: 
 300:main.c        ****                  case 0x0A: 
 301:main.c        ****                  case 0x0B: 
 302:main.c        ****                  case 0x14:      
 303:main.c        ****                                  if (buffer_address == 0) {TWDR = i2cbuffer & 0xFF; crc = _crc8_cci
 304:main.c        ****                             else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_cci
 305:main.c        ****                             else if (buffer_address == 2) {TWDR = crc;}
 306:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 307:main.c        ****                             break; 
 308:main.c        ****                            
 309:main.c        ****                  case 0x0C:     
 310:main.c        ****                                 if (buffer_address == 0)  {TWDR = led[0].r; crc = _crc8_ccitt_updat
 311:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 312:main.c        ****                            else if (buffer_address == 2)  {TWDR = led[0].b; crc = _crc8_ccitt_updat
 313:main.c        ****                            else if (buffer_address == 3)  {TWDR = crc;}
 314:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 315:main.c        ****                            break; 
 316:main.c        **** 
 317:main.c        ****                  case 0x07:          
 318:main.c        ****                                      if (buffer_address == 0) {TWDR = bllevel; crc = _crc8_ccitt_up
 319:main.c        ****                                 else if (buffer_address == 1) {TWDR = crc;}
 320:main.c        ****                                 else                         {TWDR = 0xFF; i2cerror++;}
 321:main.c        ****                                 break;
 322:main.c        **** 
 323:main.c        **** 
 324:main.c        ****                  case 0x0D:      
 325:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINC,PC6)) {TWDR = 0xFF;}
 326:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 327:main.c        ****                             else {TWDR = 0xFF; i2cerror++;}
 328:main.c        ****                             break;
 329:main.c        **** 
 330:main.c        ****                  case 0x0E:     
 331:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINB,PB4)) {TWDR = 0xFF;}
 332:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 333:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 334:main.c        ****                             break;
 335:main.c        **** 
 336:main.c        **** 
 337:main.c        ****                  case 0x0F:     
 338:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINB,PB6)) {TWDR = 0xFF;}
 339:main.c        ****                             else if (buffer_address == 1) { TWDR = crc;}
 340:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 341:main.c        ****                             break;
 342:main.c        **** 
 343:main.c        ****                  case 0x10:  
 344:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINC,PC7)) {TWDR = 0xFF;}
 345:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 346:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 347:main.c        ****                             break;
 348:main.c        **** 
 349:main.c        **** 
 350:main.c        ****                  case 0x11:  
 351:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINE,PE2)) {TWDR = 0xFF;}
 352:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 353:main.c        ****                             else                          {TWDR = 0xFF; buffer_address = 0xFE; i2ce
 354:main.c        ****                             break;
 355:main.c        **** 
 356:main.c        **** 
 357:main.c        ****                  case 0x12:  
 358:main.c        ****                                  if (buffer_address == 0)  {if (bit_is_set(PINB,PB5)) {TWDR = 0xFF;
 359:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 360:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 361:main.c        ****                             break;
 362:main.c        **** 
 363:main.c        **** 
 364:main.c        ****                  case 0x13:  
 365:main.c        ****                                  if (buffer_address == 0) {TWDR = OCR0A; crc = _crc8_ccitt_update(c
 366:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 367:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 368:main.c        ****                             break;
 369:main.c        **** 
 370:main.c        **** 
 371:main.c        ****                  default: TWDR = 0xFF; 
 372:main.c        **** 
 373:main.c        **** 		 }	 
 374:main.c        **** 
 375:main.c        **** 
 376:main.c        **** 
 377:main.c        ****       
 378:main.c        ****       buffer_address++;
 379:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);        
 380:main.c        ****       break;                                 
 381:main.c        ****    
 382:main.c        ****     case TW_BUS_ERROR:   
 383:main.c        ****      TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 384:main.c        ****      break;
 385:main.c        **** 
 386:main.c        **** 
 387:main.c        ****     //case TW_SR_STOP:  TWCR |= (1<<TWINT)|(1<<TWEA)|(1<<TWEN);  break;
 388:main.c        **** 
 389:main.c        ****     default:         
 390:main.c        ****       TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)| (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|  (0<<TWWC);   
 1332               		.loc 4 390 7 is_stmt 1 view .LVU396
 1333               		.loc 4 390 12 is_stmt 0 view .LVU397
 1334 03e8 85EC      		ldi r24,lo8(-59)
 1335 03ea 00C0      		rjmp .L170
 1336               	.L54:
 206:main.c        **** 
 1337               		.loc 4 206 3 view .LVU398
 1338 03ec 887E      		andi r24,lo8(-24)
 1339 03ee 883A      		cpi r24,lo8(-88)
 1340 03f0 01F4      		brne .L57
 276:main.c        **** 
 1341               		.loc 4 276 7 is_stmt 1 view .LVU399
 1342               	.LVL74:
 1343               	.LBB83:
 1344               	.LBI83:
 255:/usr/avr/include/util/delay.h **** {
 1345               		.loc 3 255 1 view .LVU400
 1346               	.LBB84:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1347               		.loc 3 257 2 view .LVU401
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1348               		.loc 3 261 2 view .LVU402
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 1349               		.loc 3 262 2 view .LVU403
 263:/usr/avr/include/util/delay.h **** 
 1350               		.loc 3 263 2 view .LVU404
 273:/usr/avr/include/util/delay.h **** 	#endif
 1351               		.loc 3 273 3 view .LVU405
 1352               		.loc 3 276 2 view .LVU406
 1353 03f2 00C0      		rjmp .
 1354 03f4 00C0      		rjmp .
 1355 03f6 0000      		nop
 1356               	.LVL75:
 1357               		.loc 3 276 2 is_stmt 0 view .LVU407
 1358               	.LBE84:
 1359               	.LBE83:
 278:main.c        **** 
 1360               		.loc 4 278 7 is_stmt 1 view .LVU408
 1361 03f8 E091 0000 		lds r30,commandbyte
 1362 03fc E531      		cpi r30,lo8(21)
 1363 03fe 00F0      		brlo .+2
 1364 0400 00C0      		rjmp .L99
 1365 0402 E750      		subi r30,lo8(-(-7))
 1366 0404 8091 0000 		lds r24,buffer_address
 1367 0408 ED30      		cpi r30,lo8(13)
 1368 040a 00F0      		brlo .+2
 1369 040c 00C0      		rjmp .L100
 1370 040e F0E0      		ldi r31,0
 1371 0410 E050      		subi r30,lo8(-(gs(.L102)))
 1372 0412 F040      		sbci r31,hi8(-(gs(.L102)))
 1373 0414 0C94 0000 		jmp __tablejump2__
 1374               		.section	.jumptables.gcc.__vector_36,"a",@progbits
 1375               		.p2align	1
 1376               	.L102:
 1377 0000 0000      		.word gs(.L110)
 1378 0002 0000      		.word gs(.L100)
 1379 0004 0000      		.word gs(.L100)
 1380 0006 0000      		.word gs(.L100)
 1381 0008 0000      		.word gs(.L100)
 1382 000a 0000      		.word gs(.L109)
 1383 000c 0000      		.word gs(.L108)
 1384 000e 0000      		.word gs(.L107)
 1385 0010 0000      		.word gs(.L106)
 1386 0012 0000      		.word gs(.L105)
 1387 0014 0000      		.word gs(.L104)
 1388 0016 0000      		.word gs(.L103)
 1389 0018 0000      		.word gs(.L101)
 1390               		.text
 1391               	.L56:
 210:main.c        ****     buffer_address = 0xFF; // set buffer pos undefined
 1392               		.loc 4 210 5 view .LVU409
 210:main.c        ****     buffer_address = 0xFF; // set buffer pos undefined
 1393               		.loc 4 210 10 is_stmt 0 view .LVU410
 1394 0418 85EC      		ldi r24,lo8(-59)
 1395 041a 8093 BC00 		sts 188,r24
 211:main.c        ****     break;
 1396               		.loc 4 211 5 is_stmt 1 view .LVU411
 211:main.c        ****     break;
 1397               		.loc 4 211 20 is_stmt 0 view .LVU412
 1398 041e 8FEF      		ldi r24,lo8(-1)
 1399 0420 8093 0000 		sts buffer_address,r24
 212:main.c        ****    
 1400               		.loc 4 212 5 is_stmt 1 view .LVU413
 1401               	.L52:
 1402               	/* epilogue start */
 391:main.c        ****                                                                                                    
 392:main.c        ****       
 393:main.c        ****   }
 394:main.c        **** 
 395:main.c        **** 
 396:main.c        **** 
 397:main.c        **** }
 1403               		.loc 4 397 1 is_stmt 0 view .LVU414
 1404 0424 FF91      		pop r31
 1405 0426 EF91      		pop r30
 1406 0428 BF91      		pop r27
 1407 042a AF91      		pop r26
 1408 042c 9F91      		pop r25
 1409 042e 8F91      		pop r24
 1410 0430 7F91      		pop r23
 1411 0432 6F91      		pop r22
 1412 0434 5F91      		pop r21
 1413 0436 4F91      		pop r20
 1414 0438 3F91      		pop r19
 1415 043a 2F91      		pop r18
 1416 043c 0F90      		pop r0
 1417 043e 0FBE      		out __SREG__,r0
 1418 0440 0F90      		pop r0
 1419 0442 1F90      		pop r1
 1420 0444 1895      		reti
 1421               	.L53:
 216:main.c        **** 
 1422               		.loc 4 216 5 is_stmt 1 view .LVU415
 216:main.c        **** 
 1423               		.loc 4 216 24 is_stmt 0 view .LVU416
 1424 0446 9091 0000 		lds r25,buffer_address
 216:main.c        **** 
 1425               		.loc 4 216 8 view .LVU417
 1426 044a 9F3F      		cpi r25,lo8(-1)
 1427 044c 01F0      		breq .+2
 1428 044e 00C0      		rjmp .L60
 218:main.c        ****       crc = _crc8_ccitt_update(0, commandbyte);
 1429               		.loc 4 218 7 is_stmt 1 view .LVU418
 218:main.c        ****       crc = _crc8_ccitt_update(0, commandbyte);
 1430               		.loc 4 218 21 is_stmt 0 view .LVU419
 1431 0450 6091 BB00 		lds r22,187
 218:main.c        ****       crc = _crc8_ccitt_update(0, commandbyte);
 1432               		.loc 4 218 19 view .LVU420
 1433 0454 6093 0000 		sts commandbyte,r22
 219:main.c        ****       buffer_address = 0;
 1434               		.loc 4 219 7 is_stmt 1 view .LVU421
 219:main.c        ****       buffer_address = 0;
 1435               		.loc 4 219 13 is_stmt 0 view .LVU422
 1436 0458 80E0      		ldi r24,0
 1437 045a 0E94 0000 		call _crc8_ccitt_update
 1438               	.LVL76:
 219:main.c        ****       buffer_address = 0;
 1439               		.loc 4 219 11 view .LVU423
 1440 045e 8093 0000 		sts crc,r24
 220:main.c        ****       i2cerror = 0;
 1441               		.loc 4 220 7 is_stmt 1 view .LVU424
 220:main.c        ****       i2cerror = 0;
 1442               		.loc 4 220 22 is_stmt 0 view .LVU425
 1443 0462 1092 0000 		sts buffer_address,__zero_reg__
 221:main.c        **** 
 1444               		.loc 4 221 7 is_stmt 1 view .LVU426
 221:main.c        **** 
 1445               		.loc 4 221 16 is_stmt 0 view .LVU427
 1446 0466 1092 0000 		sts i2cerror,__zero_reg__
 224:main.c        **** 
 1447               		.loc 4 224 7 is_stmt 1 view .LVU428
 1448 046a E091 0000 		lds r30,commandbyte
 1449 046e E531      		cpi r30,lo8(21)
 1450 0470 00F4      		brsh .L61
 1451 0472 F0E0      		ldi r31,0
 1452 0474 E050      		subi r30,lo8(-(gs(.L63)))
 1453 0476 F040      		sbci r31,hi8(-(gs(.L63)))
 1454 0478 0C94 0000 		jmp __tablejump2__
 1455               		.section	.jumptables.gcc.__vector_36,"a",@progbits
 1456               		.p2align	1
 1457               	.L63:
 1458 001a 0000      		.word gs(.L74)
 1459 001c 0000      		.word gs(.L73)
 1460 001e 0000      		.word gs(.L72)
 1461 0020 0000      		.word gs(.L71)
 1462 0022 0000      		.word gs(.L70)
 1463 0024 0000      		.word gs(.L69)
 1464 0026 0000      		.word gs(.L68)
 1465 0028 0000      		.word gs(.L61)
 1466 002a 0000      		.word gs(.L67)
 1467 002c 0000      		.word gs(.L66)
 1468 002e 0000      		.word gs(.L65)
 1469 0030 0000      		.word gs(.L64)
 1470 0032 0000      		.word gs(.L61)
 1471 0034 0000      		.word gs(.L61)
 1472 0036 0000      		.word gs(.L61)
 1473 0038 0000      		.word gs(.L61)
 1474 003a 0000      		.word gs(.L61)
 1475 003c 0000      		.word gs(.L61)
 1476 003e 0000      		.word gs(.L61)
 1477 0040 0000      		.word gs(.L61)
 1478 0042 0000      		.word gs(.L62)
 1479               		.text
 1480               	.L74:
 226:main.c        **** 		  case 0x01: i2cbuffer = a1; break;
 1481               		.loc 4 226 16 view .LVU429
 226:main.c        **** 		  case 0x01: i2cbuffer = a1; break;
 1482               		.loc 4 226 26 is_stmt 0 view .LVU430
 1483 047c 8091 0000 		lds r24,a0
 1484 0480 9091 0000 		lds r25,a0+1
 1485               	.L164:
 236:main.c        **** 		  case 0x14: i2cbuffer = a7avg; break;
 1486               		.loc 4 236 26 view .LVU431
 1487 0484 9093 0000 		sts i2cbuffer+1,r25
 1488 0488 8093 0000 		sts i2cbuffer,r24
 236:main.c        **** 		  case 0x14: i2cbuffer = a7avg; break;
 1489               		.loc 4 236 39 is_stmt 1 view .LVU432
 1490               	.L61:
 269:main.c        ****       if ((commandbyte == 0x92) & (twdrbuffer == 0x02)) {_delay_us(25); PORTB &= ~_BV(PB5);}
 1491               		.loc 4 269 7 view .LVU433
 269:main.c        ****       if ((commandbyte == 0x92) & (twdrbuffer == 0x02)) {_delay_us(25); PORTB &= ~_BV(PB5);}
 1492               		.loc 4 269 12 is_stmt 0 view .LVU434
 1493 048c 85EC      		ldi r24,lo8(-59)
 1494 048e 8093 BC00 		sts 188,r24
 270:main.c        ****       break;
 1495               		.loc 4 270 7 is_stmt 1 view .LVU435
 270:main.c        ****       break;
 1496               		.loc 4 270 33 is_stmt 0 view .LVU436
 1497 0492 8091 0000 		lds r24,commandbyte
 1498 0496 8239      		cpi r24,lo8(-110)
 1499 0498 01F4      		brne .L52
 1500 049a 8091 0000 		lds r24,twdrbuffer
 1501 049e 8230      		cpi r24,lo8(2)
 1502 04a0 01F4      		brne .L52
 270:main.c        ****       break;
 1503               		.loc 4 270 58 is_stmt 1 view .LVU437
 1504               	.LVL77:
 1505               	.LBB85:
 1506               	.LBI85:
 255:/usr/avr/include/util/delay.h **** {
 1507               		.loc 3 255 1 view .LVU438
 1508               	.LBB86:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1509               		.loc 3 257 2 view .LVU439
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1510               		.loc 3 261 2 view .LVU440
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 1511               		.loc 3 262 2 view .LVU441
 263:/usr/avr/include/util/delay.h **** 
 1512               		.loc 3 263 2 view .LVU442
 273:/usr/avr/include/util/delay.h **** 	#endif
 1513               		.loc 3 273 3 view .LVU443
 1514               		.loc 3 276 2 view .LVU444
 1515 04a2 85E8      		ldi r24,lo8(-123)
 1516 04a4 8A95      	1:	dec r24
 1517 04a6 01F4      		brne 1b
 1518 04a8 0000      		nop
 1519               	.LVL78:
 1520               		.loc 3 276 2 is_stmt 0 view .LVU445
 1521               	.LBE86:
 1522               	.LBE85:
 270:main.c        ****       break;
 1523               		.loc 4 270 73 is_stmt 1 view .LVU446
 270:main.c        ****       break;
 1524               		.loc 4 270 79 is_stmt 0 view .LVU447
 1525 04aa 2D98      		cbi 0x5,5
 1526 04ac 00C0      		rjmp .L52
 1527               	.L73:
 227:main.c        **** 		  case 0x02: i2cbuffer = a2; break;
 1528               		.loc 4 227 16 is_stmt 1 view .LVU448
 227:main.c        **** 		  case 0x02: i2cbuffer = a2; break;
 1529               		.loc 4 227 26 is_stmt 0 view .LVU449
 1530 04ae 8091 0000 		lds r24,a1
 1531 04b2 9091 0000 		lds r25,a1+1
 1532 04b6 00C0      		rjmp .L164
 1533               	.L72:
 228:main.c        **** 		  case 0x03: i2cbuffer = a3; break;
 1534               		.loc 4 228 16 is_stmt 1 view .LVU450
 228:main.c        **** 		  case 0x03: i2cbuffer = a3; break;
 1535               		.loc 4 228 26 is_stmt 0 view .LVU451
 1536 04b8 8091 0000 		lds r24,a2
 1537 04bc 9091 0000 		lds r25,a2+1
 1538 04c0 00C0      		rjmp .L164
 1539               	.L71:
 229:main.c        **** 		  case 0x04: i2cbuffer = a4; break;
 1540               		.loc 4 229 16 is_stmt 1 view .LVU452
 229:main.c        **** 		  case 0x04: i2cbuffer = a4; break;
 1541               		.loc 4 229 26 is_stmt 0 view .LVU453
 1542 04c2 8091 0000 		lds r24,a3
 1543 04c6 9091 0000 		lds r25,a3+1
 1544 04ca 00C0      		rjmp .L164
 1545               	.L70:
 230:main.c        **** 		  case 0x05: i2cbuffer = a5; break;
 1546               		.loc 4 230 16 is_stmt 1 view .LVU454
 230:main.c        **** 		  case 0x05: i2cbuffer = a5; break;
 1547               		.loc 4 230 26 is_stmt 0 view .LVU455
 1548 04cc 8091 0000 		lds r24,a4
 1549 04d0 9091 0000 		lds r25,a4+1
 1550 04d4 00C0      		rjmp .L164
 1551               	.L69:
 231:main.c        **** 		  case 0x06: i2cbuffer = a7; break;
 1552               		.loc 4 231 16 is_stmt 1 view .LVU456
 231:main.c        **** 		  case 0x06: i2cbuffer = a7; break;
 1553               		.loc 4 231 26 is_stmt 0 view .LVU457
 1554 04d6 8091 0000 		lds r24,a5
 1555 04da 9091 0000 		lds r25,a5+1
 1556 04de 00C0      		rjmp .L164
 1557               	.L68:
 232:main.c        **** 		  case 0x08: i2cbuffer = rpm;break;
 1558               		.loc 4 232 16 is_stmt 1 view .LVU458
 232:main.c        **** 		  case 0x08: i2cbuffer = rpm;break;
 1559               		.loc 4 232 26 is_stmt 0 view .LVU459
 1560 04e0 8091 0000 		lds r24,a7
 1561 04e4 9091 0000 		lds r25,a7+1
 1562 04e8 00C0      		rjmp .L164
 1563               	.L67:
 233:main.c        **** 		  case 0x09: i2cbuffer = vcc; break;
 1564               		.loc 4 233 16 is_stmt 1 view .LVU460
 233:main.c        **** 		  case 0x09: i2cbuffer = vcc; break;
 1565               		.loc 4 233 26 is_stmt 0 view .LVU461
 1566 04ea 8091 0000 		lds r24,rpm
 1567 04ee 9091 0000 		lds r25,rpm+1
 1568 04f2 00C0      		rjmp .L164
 1569               	.L66:
 234:main.c        **** 		  case 0x0A: i2cbuffer = temp;break;
 1570               		.loc 4 234 16 is_stmt 1 view .LVU462
 234:main.c        **** 		  case 0x0A: i2cbuffer = temp;break;
 1571               		.loc 4 234 26 is_stmt 0 view .LVU463
 1572 04f4 8091 0000 		lds r24,vcc
 1573 04f8 9091 0000 		lds r25,vcc+1
 1574 04fc 00C0      		rjmp .L164
 1575               	.L65:
 235:main.c        **** 		  case 0x0B: i2cbuffer = freeRam(); break;
 1576               		.loc 4 235 16 is_stmt 1 view .LVU464
 235:main.c        **** 		  case 0x0B: i2cbuffer = freeRam(); break;
 1577               		.loc 4 235 26 is_stmt 0 view .LVU465
 1578 04fe 8091 0000 		lds r24,temp
 1579 0502 9091 0000 		lds r25,temp+1
 1580 0506 00C0      		rjmp .L164
 1581               	.L64:
 236:main.c        **** 		  case 0x14: i2cbuffer = a7avg; break;
 1582               		.loc 4 236 16 is_stmt 1 view .LVU466
 236:main.c        **** 		  case 0x14: i2cbuffer = a7avg; break;
 1583               		.loc 4 236 28 is_stmt 0 view .LVU467
 1584 0508 0E94 0000 		call freeRam
 1585               	.LVL79:
 1586 050c 00C0      		rjmp .L164
 1587               	.L62:
 237:main.c        **** 
 1588               		.loc 4 237 16 is_stmt 1 view .LVU468
 237:main.c        **** 
 1589               		.loc 4 237 26 is_stmt 0 view .LVU469
 1590 050e 8091 0000 		lds r24,a7avg
 1591 0512 9091 0000 		lds r25,a7avg+1
 1592 0516 00C0      		rjmp .L164
 1593               	.L60:
 246:main.c        **** 
 1594               		.loc 4 246 7 is_stmt 1 view .LVU470
 1595 0518 8091 0000 		lds r24,crc
 246:main.c        **** 
 1596               		.loc 4 246 10 is_stmt 0 view .LVU471
 1597 051c 9111      		cpse r25,__zero_reg__
 1598 051e 00C0      		rjmp .L75
 246:main.c        **** 
 1599               		.loc 4 246 33 is_stmt 1 discriminator 1 view .LVU472
 246:main.c        **** 
 1600               		.loc 4 246 46 is_stmt 0 discriminator 1 view .LVU473
 1601 0520 9091 BB00 		lds r25,187
 246:main.c        **** 
 1602               		.loc 4 246 44 discriminator 1 view .LVU474
 1603 0524 9093 0000 		sts twdrbuffer,r25
 246:main.c        **** 
 1604               		.loc 4 246 52 is_stmt 1 discriminator 1 view .LVU475
 246:main.c        **** 
 1605               		.loc 4 246 58 is_stmt 0 discriminator 1 view .LVU476
 1606 0528 6091 BB00 		lds r22,187
 1607 052c 0E94 0000 		call _crc8_ccitt_update
 1608               	.LVL80:
 246:main.c        **** 
 1609               		.loc 4 246 56 discriminator 1 view .LVU477
 1610 0530 8093 0000 		sts crc,r24
 1611               	.L76:
 266:main.c        **** 
 1612               		.loc 4 266 7 is_stmt 1 view .LVU478
 266:main.c        **** 
 1613               		.loc 4 266 21 is_stmt 0 view .LVU479
 1614 0534 8091 0000 		lds r24,buffer_address
 1615 0538 8F5F      		subi r24,lo8(-(1))
 1616 053a 8093 0000 		sts buffer_address,r24
 1617 053e 00C0      		rjmp .L61
 1618               	.L75:
 248:main.c        **** 
 1619               		.loc 4 248 13 is_stmt 1 view .LVU480
 248:main.c        **** 
 1620               		.loc 4 248 42 is_stmt 0 view .LVU481
 1621 0540 2091 BB00 		lds r18,187
 248:main.c        **** 
 1622               		.loc 4 248 39 view .LVU482
 1623 0544 9130      		cpi r25,lo8(1)
 1624 0546 01F0      		breq .+2
 1625 0548 00C0      		rjmp .L77
 1626 054a 2813      		cpse r18,r24
 1627 054c 00C0      		rjmp .L77
 250:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 1628               		.loc 4 250 12 is_stmt 1 view .LVU483
 250:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 1629               		.loc 4 250 28 is_stmt 0 view .LVU484
 1630 054e 8091 0000 		lds r24,commandbyte
 250:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 1631               		.loc 4 250 15 view .LVU485
 1632 0552 8738      		cpi r24,lo8(-121)
 1633 0554 01F4      		brne .L80
 250:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 1634               		.loc 4 250 39 is_stmt 1 discriminator 1 view .LVU486
 250:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 1635               		.loc 4 250 50 is_stmt 0 discriminator 1 view .LVU487
 1636 0556 8091 0000 		lds r24,twdrbuffer
 1637 055a 8093 0000 		sts newbllevel,r24
 1638 055e 00C0      		rjmp .L76
 1639               	.L80:
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1640               		.loc 4 251 12 is_stmt 1 view .LVU488
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1641               		.loc 4 251 15 is_stmt 0 view .LVU489
 1642 0560 8D38      		cpi r24,lo8(-115)
 1643 0562 01F4      		brne .L81
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1644               		.loc 4 251 39 is_stmt 1 discriminator 1 view .LVU490
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1645               		.loc 4 251 42 is_stmt 0 discriminator 1 view .LVU491
 1646 0564 8091 0000 		lds r24,twdrbuffer
 1647 0568 8F3F      		cpi r24,lo8(-1)
 1648 056a 01F4      		brne .L82
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1649               		.loc 4 251 64 is_stmt 1 discriminator 2 view .LVU492
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1650               		.loc 4 251 70 is_stmt 0 discriminator 2 view .LVU493
 1651 056c 469A      		sbi 0x8,6
 1652 056e 00C0      		rjmp .L76
 1653               	.L82:
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1654               		.loc 4 251 90 is_stmt 1 discriminator 3 view .LVU494
 251:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB4);} else {PORTB &= ~
 1655               		.loc 4 251 96 is_stmt 0 discriminator 3 view .LVU495
 1656 0570 4698      		cbi 0x8,6
 1657 0572 00C0      		rjmp .L76
 1658               	.L81:
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1659               		.loc 4 252 12 is_stmt 1 view .LVU496
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1660               		.loc 4 252 15 is_stmt 0 view .LVU497
 1661 0574 8E38      		cpi r24,lo8(-114)
 1662 0576 01F4      		brne .L83
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1663               		.loc 4 252 39 is_stmt 1 discriminator 1 view .LVU498
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1664               		.loc 4 252 42 is_stmt 0 discriminator 1 view .LVU499
 1665 0578 8091 0000 		lds r24,twdrbuffer
 1666 057c 8F3F      		cpi r24,lo8(-1)
 1667 057e 01F4      		brne .L84
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1668               		.loc 4 252 64 is_stmt 1 discriminator 2 view .LVU500
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1669               		.loc 4 252 70 is_stmt 0 discriminator 2 view .LVU501
 1670 0580 2C9A      		sbi 0x5,4
 1671 0582 00C0      		rjmp .L76
 1672               	.L84:
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1673               		.loc 4 252 90 is_stmt 1 discriminator 3 view .LVU502
 252:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1674               		.loc 4 252 96 is_stmt 0 discriminator 3 view .LVU503
 1675 0584 2C98      		cbi 0x5,4
 1676 0586 00C0      		rjmp .L76
 1677               	.L83:
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1678               		.loc 4 253 12 is_stmt 1 view .LVU504
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1679               		.loc 4 253 15 is_stmt 0 view .LVU505
 1680 0588 8F38      		cpi r24,lo8(-113)
 1681 058a 01F4      		brne .L85
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1682               		.loc 4 253 39 is_stmt 1 discriminator 1 view .LVU506
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1683               		.loc 4 253 42 is_stmt 0 discriminator 1 view .LVU507
 1684 058c 8091 0000 		lds r24,twdrbuffer
 1685 0590 8F3F      		cpi r24,lo8(-1)
 1686 0592 01F4      		brne .L86
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1687               		.loc 4 253 64 is_stmt 1 discriminator 2 view .LVU508
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1688               		.loc 4 253 70 is_stmt 0 discriminator 2 view .LVU509
 1689 0594 2E9A      		sbi 0x5,6
 1690 0596 00C0      		rjmp .L76
 1691               	.L86:
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1692               		.loc 4 253 90 is_stmt 1 discriminator 3 view .LVU510
 253:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1693               		.loc 4 253 96 is_stmt 0 discriminator 3 view .LVU511
 1694 0598 2E98      		cbi 0x5,6
 1695 059a 00C0      		rjmp .L76
 1696               	.L85:
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1697               		.loc 4 254 12 is_stmt 1 view .LVU512
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1698               		.loc 4 254 15 is_stmt 0 view .LVU513
 1699 059c 8039      		cpi r24,lo8(-112)
 1700 059e 01F4      		brne .L87
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1701               		.loc 4 254 39 is_stmt 1 discriminator 1 view .LVU514
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1702               		.loc 4 254 42 is_stmt 0 discriminator 1 view .LVU515
 1703 05a0 8091 0000 		lds r24,twdrbuffer
 1704 05a4 8F3F      		cpi r24,lo8(-1)
 1705 05a6 01F4      		brne .L88
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1706               		.loc 4 254 64 is_stmt 1 discriminator 2 view .LVU516
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1707               		.loc 4 254 70 is_stmt 0 discriminator 2 view .LVU517
 1708 05a8 479A      		sbi 0x8,7
 1709 05aa 00C0      		rjmp .L76
 1710               	.L88:
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1711               		.loc 4 254 90 is_stmt 1 discriminator 3 view .LVU518
 254:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1712               		.loc 4 254 96 is_stmt 0 discriminator 3 view .LVU519
 1713 05ac 4798      		cbi 0x8,7
 1714 05ae 00C0      		rjmp .L76
 1715               	.L87:
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1716               		.loc 4 255 12 is_stmt 1 view .LVU520
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1717               		.loc 4 255 15 is_stmt 0 view .LVU521
 1718 05b0 8139      		cpi r24,lo8(-111)
 1719 05b2 01F4      		brne .L89
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1720               		.loc 4 255 39 is_stmt 1 discriminator 1 view .LVU522
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1721               		.loc 4 255 42 is_stmt 0 discriminator 1 view .LVU523
 1722 05b4 8091 0000 		lds r24,twdrbuffer
 1723 05b8 8F3F      		cpi r24,lo8(-1)
 1724 05ba 01F4      		brne .L90
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1725               		.loc 4 255 64 is_stmt 1 discriminator 2 view .LVU524
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1726               		.loc 4 255 70 is_stmt 0 discriminator 2 view .LVU525
 1727 05bc 729A      		sbi 0xe,2
 1728 05be 00C0      		rjmp .L76
 1729               	.L90:
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1730               		.loc 4 255 90 is_stmt 1 discriminator 3 view .LVU526
 255:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1731               		.loc 4 255 96 is_stmt 0 discriminator 3 view .LVU527
 1732 05c0 7298      		cbi 0xe,2
 1733 05c2 00C0      		rjmp .L76
 1734               	.L89:
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1735               		.loc 4 256 12 is_stmt 1 view .LVU528
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1736               		.loc 4 256 15 is_stmt 0 view .LVU529
 1737 05c4 8239      		cpi r24,lo8(-110)
 1738 05c6 01F4      		brne .L91
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1739               		.loc 4 256 39 is_stmt 1 discriminator 1 view .LVU530
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1740               		.loc 4 256 54 is_stmt 0 discriminator 1 view .LVU531
 1741 05c8 8091 0000 		lds r24,twdrbuffer
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1742               		.loc 4 256 42 discriminator 1 view .LVU532
 1743 05cc 8F3F      		cpi r24,lo8(-1)
 1744 05ce 01F4      		brne .L92
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1745               		.loc 4 256 64 is_stmt 1 discriminator 2 view .LVU533
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1746               		.loc 4 256 70 is_stmt 0 discriminator 2 view .LVU534
 1747 05d0 2D9A      		sbi 0x5,5
 1748 05d2 00C0      		rjmp .L76
 1749               	.L92:
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1750               		.loc 4 256 89 is_stmt 1 discriminator 3 view .LVU535
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1751               		.loc 4 256 92 is_stmt 0 discriminator 3 view .LVU536
 1752 05d4 8130      		cpi r24,lo8(1)
 1753 05d6 01F4      		brne .L93
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1754               		.loc 4 256 114 is_stmt 1 discriminator 4 view .LVU537
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1755               		.loc 4 256 120 is_stmt 0 discriminator 4 view .LVU538
 1756 05d8 2D9A      		sbi 0x5,5
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1757               		.loc 4 256 133 is_stmt 1 discriminator 4 view .LVU539
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1758               		.loc 4 256 144 is_stmt 0 discriminator 4 view .LVU540
 1759 05da 82E0      		ldi r24,lo8(2)
 1760 05dc 8093 0000 		sts twdrbuffer,r24
 1761 05e0 00C0      		rjmp .L76
 1762               	.L93:
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1763               		.loc 4 256 159 is_stmt 1 discriminator 5 view .LVU541
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1764               		.loc 4 256 165 is_stmt 0 discriminator 5 view .LVU542
 1765 05e2 2D98      		cbi 0x5,5
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1766               		.loc 4 256 178 is_stmt 1 discriminator 5 view .LVU543
 256:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1767               		.loc 4 256 189 is_stmt 0 discriminator 5 view .LVU544
 1768 05e4 1092 0000 		sts twdrbuffer,__zero_reg__
 1769 05e8 00C0      		rjmp .L76
 1770               	.L91:
 257:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 1771               		.loc 4 257 12 is_stmt 1 view .LVU545
 257:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 1772               		.loc 4 257 15 is_stmt 0 view .LVU546
 1773 05ea 8339      		cpi r24,lo8(-109)
 1774 05ec 01F4      		brne .L94
 257:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 1775               		.loc 4 257 39 is_stmt 1 discriminator 1 view .LVU547
 257:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 1776               		.loc 4 257 45 is_stmt 0 discriminator 1 view .LVU548
 1777 05ee 8091 0000 		lds r24,twdrbuffer
 1778 05f2 87BD      		out 0x27,r24
 257:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 1779               		.loc 4 257 58 is_stmt 1 discriminator 1 view .LVU549
 257:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 1780               		.loc 4 257 67 is_stmt 0 discriminator 1 view .LVU550
 1781 05f4 8091 0000 		lds r24,twdrbuffer
 1782 05f8 8093 0000 		sts fanlevel,r24
 1783 05fc 00C0      		rjmp .L76
 1784               	.L94:
 258:main.c        ****       else if (commandbyte == 0x95 ) {led[0].g = twdrbuffer;changeled = 1;}  //set g color
 1785               		.loc 4 258 12 is_stmt 1 view .LVU551
 258:main.c        ****       else if (commandbyte == 0x95 ) {led[0].g = twdrbuffer;changeled = 1;}  //set g color
 1786               		.loc 4 258 15 is_stmt 0 view .LVU552
 1787 05fe 8439      		cpi r24,lo8(-108)
 1788 0600 01F4      		brne .L95
 258:main.c        ****       else if (commandbyte == 0x95 ) {led[0].g = twdrbuffer;changeled = 1;}  //set g color
 1789               		.loc 4 258 39 is_stmt 1 discriminator 1 view .LVU553
 258:main.c        ****       else if (commandbyte == 0x95 ) {led[0].g = twdrbuffer;changeled = 1;}  //set g color
 1790               		.loc 4 258 48 is_stmt 0 discriminator 1 view .LVU554
 1791 0602 8091 0000 		lds r24,twdrbuffer
 1792 0606 8093 0000 		sts led+1,r24
 258:main.c        ****       else if (commandbyte == 0x95 ) {led[0].g = twdrbuffer;changeled = 1;}  //set g color
 1793               		.loc 4 258 61 is_stmt 1 discriminator 1 view .LVU555
 1794               	.L163:
 260:main.c        **** 
 1795               		.loc 4 260 61 discriminator 1 view .LVU556
 260:main.c        **** 
 1796               		.loc 4 260 71 is_stmt 0 discriminator 1 view .LVU557
 1797 060a 81E0      		ldi r24,lo8(1)
 1798 060c 8093 0000 		sts changeled,r24
 1799 0610 00C0      		rjmp .L76
 1800               	.L95:
 259:main.c        ****       else if (commandbyte == 0x96 ) {led[0].b = twdrbuffer;changeled = 1;}  //set b color
 1801               		.loc 4 259 12 is_stmt 1 view .LVU558
 259:main.c        ****       else if (commandbyte == 0x96 ) {led[0].b = twdrbuffer;changeled = 1;}  //set b color
 1802               		.loc 4 259 15 is_stmt 0 view .LVU559
 1803 0612 8539      		cpi r24,lo8(-107)
 1804 0614 01F4      		brne .L96
 259:main.c        ****       else if (commandbyte == 0x96 ) {led[0].b = twdrbuffer;changeled = 1;}  //set b color
 1805               		.loc 4 259 39 is_stmt 1 discriminator 1 view .LVU560
 259:main.c        ****       else if (commandbyte == 0x96 ) {led[0].b = twdrbuffer;changeled = 1;}  //set b color
 1806               		.loc 4 259 48 is_stmt 0 discriminator 1 view .LVU561
 1807 0616 8091 0000 		lds r24,twdrbuffer
 1808 061a 8093 0000 		sts led,r24
 259:main.c        ****       else if (commandbyte == 0x96 ) {led[0].b = twdrbuffer;changeled = 1;}  //set b color
 1809               		.loc 4 259 61 is_stmt 1 discriminator 1 view .LVU562
 1810 061e 00C0      		rjmp .L163
 1811               	.L96:
 260:main.c        **** 
 1812               		.loc 4 260 12 view .LVU563
 260:main.c        **** 
 1813               		.loc 4 260 15 is_stmt 0 view .LVU564
 1814 0620 8639      		cpi r24,lo8(-106)
 1815 0622 01F4      		brne .L77
 260:main.c        **** 
 1816               		.loc 4 260 39 is_stmt 1 discriminator 1 view .LVU565
 260:main.c        **** 
 1817               		.loc 4 260 48 is_stmt 0 discriminator 1 view .LVU566
 1818 0624 8091 0000 		lds r24,twdrbuffer
 1819 0628 8093 0000 		sts led+2,r24
 1820 062c 00C0      		rjmp .L163
 1821               	.L77:
 262:main.c        ****       } 
 1822               		.loc 4 262 13 is_stmt 1 view .LVU567
 262:main.c        ****       } 
 1823               		.loc 4 262 21 is_stmt 0 view .LVU568
 1824 062e 8091 0000 		lds r24,i2cerror
 1825 0632 8F5F      		subi r24,lo8(-(1))
 1826 0634 8093 0000 		sts i2cerror,r24
 1827 0638 00C0      		rjmp .L76
 1828               	.L99:
 1829 063a E738      		cpi r30,lo8(-121)
 1830 063c 01F0      		breq .L111
 1831 063e ED58      		subi r30,lo8(-(115))
 1832 0640 EA30      		cpi r30,lo8(10)
 1833 0642 00F0      		brlo .+2
 1834 0644 00C0      		rjmp .L112
 1835               	.L111:
 290:main.c        ****                  case 0x00:
 1836               		.loc 4 290 32 is_stmt 1 view .LVU569
 290:main.c        ****                  case 0x00:
 1837               		.loc 4 290 37 is_stmt 0 view .LVU570
 1838 0646 8091 0000 		lds r24,crc
 1839 064a 8093 BB00 		sts 187,r24
 290:main.c        ****                  case 0x00:
 1840               		.loc 4 290 45 is_stmt 1 view .LVU571
 290:main.c        ****                  case 0x00:
 1841               		.loc 4 290 49 is_stmt 0 view .LVU572
 1842 064e 8FEF      		ldi r24,lo8(-1)
 1843               	.L168:
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1844               		.loc 4 310 81 discriminator 1 view .LVU573
 1845 0650 8093 0000 		sts crc,r24
 1846               	.L113:
 378:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);        
 1847               		.loc 4 378 7 is_stmt 1 view .LVU574
 378:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);        
 1848               		.loc 4 378 21 is_stmt 0 view .LVU575
 1849 0654 8091 0000 		lds r24,buffer_address
 1850 0658 8F5F      		subi r24,lo8(-(1))
 1851 065a 8093 0000 		sts buffer_address,r24
 379:main.c        ****       break;                                 
 1852               		.loc 4 379 7 is_stmt 1 view .LVU576
 1853 065e 00C0      		rjmp .L57
 1854               	.L100:
 303:main.c        ****                             else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_cci
 1855               		.loc 4 303 34 view .LVU577
 303:main.c        ****                             else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_cci
 1856               		.loc 4 303 37 is_stmt 0 view .LVU578
 1857 0660 8111      		cpse r24,__zero_reg__
 1858 0662 00C0      		rjmp .L114
 303:main.c        ****                             else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_cci
 1859               		.loc 4 303 60 is_stmt 1 discriminator 1 view .LVU579
 303:main.c        ****                             else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_cci
 1860               		.loc 4 303 65 is_stmt 0 discriminator 1 view .LVU580
 1861 0664 8091 0000 		lds r24,i2cbuffer
 1862               	.L166:
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1863               		.loc 4 310 65 discriminator 1 view .LVU581
 1864 0668 8093 BB00 		sts 187,r24
 1865               	.L169:
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1866               		.loc 4 310 77 is_stmt 1 discriminator 1 view .LVU582
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1867               		.loc 4 310 83 is_stmt 0 discriminator 1 view .LVU583
 1868 066c 6091 BB00 		lds r22,187
 1869 0670 8091 0000 		lds r24,crc
 1870 0674 0E94 0000 		call _crc8_ccitt_update
 1871               	.LVL81:
 1872 0678 00C0      		rjmp .L168
 1873               	.L114:
 304:main.c        ****                             else if (buffer_address == 2) {TWDR = crc;}
 1874               		.loc 4 304 34 is_stmt 1 view .LVU584
 304:main.c        ****                             else if (buffer_address == 2) {TWDR = crc;}
 1875               		.loc 4 304 37 is_stmt 0 view .LVU585
 1876 067a 8130      		cpi r24,lo8(1)
 1877 067c 01F4      		brne .L115
 304:main.c        ****                             else if (buffer_address == 2) {TWDR = crc;}
 1878               		.loc 4 304 60 is_stmt 1 discriminator 1 view .LVU586
 304:main.c        ****                             else if (buffer_address == 2) {TWDR = crc;}
 1879               		.loc 4 304 77 is_stmt 0 discriminator 1 view .LVU587
 1880 067e 8091 0000 		lds r24,i2cbuffer+1
 1881 0682 00C0      		rjmp .L166
 1882               	.L115:
 305:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 1883               		.loc 4 305 34 is_stmt 1 view .LVU588
 305:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 1884               		.loc 4 305 37 is_stmt 0 view .LVU589
 1885 0684 8230      		cpi r24,lo8(2)
 1886 0686 01F4      		brne .L148
 1887               	.L171:
 366:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 1888               		.loc 4 366 60 is_stmt 1 discriminator 1 view .LVU590
 366:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 1889               		.loc 4 366 65 is_stmt 0 discriminator 1 view .LVU591
 1890 0688 8091 0000 		lds r24,crc
 1891               	.L165:
 371:main.c        **** 
 1892               		.loc 4 371 32 view .LVU592
 1893 068c 8093 BB00 		sts 187,r24
 1894 0690 00C0      		rjmp .L113
 1895               	.L109:
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1896               		.loc 4 310 33 is_stmt 1 view .LVU593
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1897               		.loc 4 310 36 is_stmt 0 view .LVU594
 1898 0692 8111      		cpse r24,__zero_reg__
 1899 0694 00C0      		rjmp .L117
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1900               		.loc 4 310 60 is_stmt 1 discriminator 1 view .LVU595
 310:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1901               		.loc 4 310 73 is_stmt 0 discriminator 1 view .LVU596
 1902 0696 8091 0000 		lds r24,led+1
 1903 069a 00C0      		rjmp .L166
 1904               	.L117:
 311:main.c        ****                            else if (buffer_address == 2)  {TWDR = led[0].b; crc = _crc8_ccitt_updat
 1905               		.loc 4 311 33 is_stmt 1 view .LVU597
 311:main.c        ****                            else if (buffer_address == 2)  {TWDR = led[0].b; crc = _crc8_ccitt_updat
 1906               		.loc 4 311 36 is_stmt 0 view .LVU598
 1907 069c 8130      		cpi r24,lo8(1)
 1908 069e 01F4      		brne .L118
 311:main.c        ****                            else if (buffer_address == 2)  {TWDR = led[0].b; crc = _crc8_ccitt_updat
 1909               		.loc 4 311 60 is_stmt 1 discriminator 1 view .LVU599
 311:main.c        ****                            else if (buffer_address == 2)  {TWDR = led[0].b; crc = _crc8_ccitt_updat
 1910               		.loc 4 311 73 is_stmt 0 discriminator 1 view .LVU600
 1911 06a0 8091 0000 		lds r24,led
 1912 06a4 00C0      		rjmp .L166
 1913               	.L118:
 312:main.c        ****                            else if (buffer_address == 3)  {TWDR = crc;}
 1914               		.loc 4 312 33 is_stmt 1 view .LVU601
 312:main.c        ****                            else if (buffer_address == 3)  {TWDR = crc;}
 1915               		.loc 4 312 36 is_stmt 0 view .LVU602
 1916 06a6 8230      		cpi r24,lo8(2)
 1917 06a8 01F4      		brne .L119
 312:main.c        ****                            else if (buffer_address == 3)  {TWDR = crc;}
 1918               		.loc 4 312 60 is_stmt 1 discriminator 1 view .LVU603
 312:main.c        ****                            else if (buffer_address == 3)  {TWDR = crc;}
 1919               		.loc 4 312 73 is_stmt 0 discriminator 1 view .LVU604
 1920 06aa 8091 0000 		lds r24,led+2
 1921 06ae 00C0      		rjmp .L166
 1922               	.L119:
 313:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 1923               		.loc 4 313 33 is_stmt 1 view .LVU605
 313:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 1924               		.loc 4 313 36 is_stmt 0 view .LVU606
 1925 06b0 8330      		cpi r24,lo8(3)
 1926 06b2 01F0      		breq .L171
 1927               	.L148:
 367:main.c        ****                             break;
 1928               		.loc 4 367 60 is_stmt 1 view .LVU607
 367:main.c        ****                             break;
 1929               		.loc 4 367 65 is_stmt 0 view .LVU608
 1930 06b4 8FEF      		ldi r24,lo8(-1)
 1931 06b6 8093 BB00 		sts 187,r24
 1932 06ba 00C0      		rjmp .L167
 1933               	.L110:
 318:main.c        ****                                 else if (buffer_address == 1) {TWDR = crc;}
 1934               		.loc 4 318 38 is_stmt 1 view .LVU609
 318:main.c        ****                                 else if (buffer_address == 1) {TWDR = crc;}
 1935               		.loc 4 318 41 is_stmt 0 view .LVU610
 1936 06bc 8111      		cpse r24,__zero_reg__
 1937 06be 00C0      		rjmp .L147
 318:main.c        ****                                 else if (buffer_address == 1) {TWDR = crc;}
 1938               		.loc 4 318 64 is_stmt 1 discriminator 1 view .LVU611
 318:main.c        ****                                 else if (buffer_address == 1) {TWDR = crc;}
 1939               		.loc 4 318 69 is_stmt 0 discriminator 1 view .LVU612
 1940 06c0 8091 0000 		lds r24,bllevel
 1941 06c4 00C0      		rjmp .L166
 1942               	.L108:
 325:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1943               		.loc 4 325 34 is_stmt 1 view .LVU613
 325:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1944               		.loc 4 325 37 is_stmt 0 view .LVU614
 1945 06c6 8111      		cpse r24,__zero_reg__
 1946 06c8 00C0      		rjmp .L147
 325:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1947               		.loc 4 325 60 is_stmt 1 discriminator 1 view .LVU615
 325:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1948               		.loc 4 325 63 is_stmt 0 discriminator 1 view .LVU616
 1949 06ca 369B      		sbis 0x6,6
 1950 06cc 00C0      		rjmp .L144
 1951               	.L178:
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1952               		.loc 4 358 88 is_stmt 1 discriminator 2 view .LVU617
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1953               		.loc 4 358 93 is_stmt 0 discriminator 2 view .LVU618
 1954 06ce 8FEF      		ldi r24,lo8(-1)
 1955 06d0 00C0      		rjmp .L166
 1956               	.L107:
 331:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1957               		.loc 4 331 34 is_stmt 1 view .LVU619
 331:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1958               		.loc 4 331 37 is_stmt 0 view .LVU620
 1959 06d2 8111      		cpse r24,__zero_reg__
 1960 06d4 00C0      		rjmp .L147
 331:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1961               		.loc 4 331 60 is_stmt 1 discriminator 1 view .LVU621
 331:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1962               		.loc 4 331 63 is_stmt 0 discriminator 1 view .LVU622
 1963 06d6 1C99      		sbic 0x3,4
 1964 06d8 00C0      		rjmp .L178
 1965               	.L144:
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1966               		.loc 4 358 108 is_stmt 1 discriminator 3 view .LVU623
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1967               		.loc 4 358 113 is_stmt 0 discriminator 3 view .LVU624
 1968 06da 1092 BB00 		sts 187,__zero_reg__
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1969               		.loc 4 358 122 is_stmt 1 discriminator 3 view .LVU625
 1970 06de 00C0      		rjmp .L169
 1971               	.L106:
 338:main.c        ****                             else if (buffer_address == 1) { TWDR = crc;}
 1972               		.loc 4 338 34 view .LVU626
 338:main.c        ****                             else if (buffer_address == 1) { TWDR = crc;}
 1973               		.loc 4 338 37 is_stmt 0 view .LVU627
 1974 06e0 8111      		cpse r24,__zero_reg__
 1975 06e2 00C0      		rjmp .L147
 338:main.c        ****                             else if (buffer_address == 1) { TWDR = crc;}
 1976               		.loc 4 338 60 is_stmt 1 discriminator 1 view .LVU628
 338:main.c        ****                             else if (buffer_address == 1) { TWDR = crc;}
 1977               		.loc 4 338 63 is_stmt 0 discriminator 1 view .LVU629
 1978 06e4 1E9B      		sbis 0x3,6
 1979 06e6 00C0      		rjmp .L144
 1980 06e8 00C0      		rjmp .L178
 1981               	.L105:
 344:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1982               		.loc 4 344 34 is_stmt 1 view .LVU630
 344:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1983               		.loc 4 344 37 is_stmt 0 view .LVU631
 1984 06ea 8111      		cpse r24,__zero_reg__
 1985 06ec 00C0      		rjmp .L147
 344:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1986               		.loc 4 344 60 is_stmt 1 discriminator 1 view .LVU632
 344:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1987               		.loc 4 344 63 is_stmt 0 discriminator 1 view .LVU633
 1988 06ee 379B      		sbis 0x6,7
 1989 06f0 00C0      		rjmp .L144
 1990 06f2 00C0      		rjmp .L178
 1991               	.L104:
 351:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1992               		.loc 4 351 34 is_stmt 1 view .LVU634
 351:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1993               		.loc 4 351 37 is_stmt 0 view .LVU635
 1994 06f4 8111      		cpse r24,__zero_reg__
 1995 06f6 00C0      		rjmp .L139
 351:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1996               		.loc 4 351 60 is_stmt 1 discriminator 1 view .LVU636
 351:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1997               		.loc 4 351 63 is_stmt 0 discriminator 1 view .LVU637
 1998 06f8 629B      		sbis 0xc,2
 1999 06fa 00C0      		rjmp .L144
 2000 06fc 00C0      		rjmp .L178
 2001               	.L139:
 352:main.c        ****                             else                          {TWDR = 0xFF; buffer_address = 0xFE; i2ce
 2002               		.loc 4 352 34 is_stmt 1 view .LVU638
 352:main.c        ****                             else                          {TWDR = 0xFF; buffer_address = 0xFE; i2ce
 2003               		.loc 4 352 37 is_stmt 0 view .LVU639
 2004 06fe 8130      		cpi r24,lo8(1)
 2005 0700 01F0      		breq .L171
 353:main.c        ****                             break;
 2006               		.loc 4 353 60 is_stmt 1 view .LVU640
 353:main.c        ****                             break;
 2007               		.loc 4 353 65 is_stmt 0 view .LVU641
 2008 0702 8FEF      		ldi r24,lo8(-1)
 2009 0704 8093 BB00 		sts 187,r24
 353:main.c        ****                             break;
 2010               		.loc 4 353 73 is_stmt 1 view .LVU642
 353:main.c        ****                             break;
 2011               		.loc 4 353 88 is_stmt 0 view .LVU643
 2012 0708 8EEF      		ldi r24,lo8(-2)
 2013 070a 8093 0000 		sts buffer_address,r24
 353:main.c        ****                             break;
 2014               		.loc 4 353 96 is_stmt 1 view .LVU644
 2015               	.L167:
 367:main.c        ****                             break;
 2016               		.loc 4 367 73 view .LVU645
 367:main.c        ****                             break;
 2017               		.loc 4 367 81 is_stmt 0 view .LVU646
 2018 070e 8091 0000 		lds r24,i2cerror
 2019 0712 8F5F      		subi r24,lo8(-(1))
 2020 0714 8093 0000 		sts i2cerror,r24
 2021 0718 00C0      		rjmp .L113
 2022               	.L103:
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2023               		.loc 4 358 34 is_stmt 1 view .LVU647
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2024               		.loc 4 358 37 is_stmt 0 view .LVU648
 2025 071a 8111      		cpse r24,__zero_reg__
 2026 071c 00C0      		rjmp .L147
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2027               		.loc 4 358 61 is_stmt 1 discriminator 1 view .LVU649
 358:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2028               		.loc 4 358 64 is_stmt 0 discriminator 1 view .LVU650
 2029 071e 1D9B      		sbis 0x3,5
 2030 0720 00C0      		rjmp .L144
 2031 0722 00C0      		rjmp .L178
 2032               	.L101:
 365:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2033               		.loc 4 365 34 is_stmt 1 view .LVU651
 365:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2034               		.loc 4 365 37 is_stmt 0 view .LVU652
 2035 0724 8111      		cpse r24,__zero_reg__
 2036 0726 00C0      		rjmp .L147
 365:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2037               		.loc 4 365 60 is_stmt 1 discriminator 1 view .LVU653
 365:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 2038               		.loc 4 365 67 is_stmt 0 discriminator 1 view .LVU654
 2039 0728 87B5      		in r24,0x27
 2040 072a 00C0      		rjmp .L166
 2041               	.L147:
 366:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 2042               		.loc 4 366 34 is_stmt 1 view .LVU655
 366:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 2043               		.loc 4 366 37 is_stmt 0 view .LVU656
 2044 072c 8130      		cpi r24,lo8(1)
 2045 072e 01F4      		brne .L148
 2046 0730 00C0      		rjmp .L171
 2047               	.L112:
 371:main.c        **** 
 2048               		.loc 4 371 27 is_stmt 1 view .LVU657
 371:main.c        **** 
 2049               		.loc 4 371 32 is_stmt 0 view .LVU658
 2050 0732 8FEF      		ldi r24,lo8(-1)
 2051 0734 00C0      		rjmp .L165
 2052               	.L55:
 383:main.c        ****      break;
 2053               		.loc 4 383 6 is_stmt 1 view .LVU659
 383:main.c        ****      break;
 2054               		.loc 4 383 11 is_stmt 0 view .LVU660
 2055 0736 85ED      		ldi r24,lo8(-43)
 2056               	.L170:
 390:main.c        ****                                                                                                    
 2057               		.loc 4 390 12 view .LVU661
 2058 0738 8093 BC00 		sts 188,r24
 2059               		.loc 4 397 1 view .LVU662
 2060 073c 00C0      		rjmp .L52
 2061               		.cfi_endproc
 2062               	.LFE31:
 2064               	.global	setup
 2066               	setup:
 2067               	.LFB32:
 398:main.c        **** 
 399:main.c        **** 
 400:main.c        **** void setup(void)
 401:main.c        **** {
 2068               		.loc 4 401 1 is_stmt 1 view -0
 2069               		.cfi_startproc
 2070 073e CF93      		push r28
 2071               	.LCFI22:
 2072               		.cfi_def_cfa_offset 3
 2073               		.cfi_offset 28, -2
 2074 0740 DF93      		push r29
 2075               	.LCFI23:
 2076               		.cfi_def_cfa_offset 4
 2077               		.cfi_offset 29, -3
 2078               	/* prologue: function */
 2079               	/* frame size = 0 */
 2080               	/* stack size = 2 */
 2081               	.L__stack_usage = 2
 402:main.c        ****    DDRF = 0b00000000;
 2082               		.loc 4 402 4 view .LVU664
 2083               		.loc 4 402 9 is_stmt 0 view .LVU665
 2084 0742 10BA      		out 0x10,__zero_reg__
 403:main.c        ****    DDRD = 0b01111000;
 2085               		.loc 4 403 4 is_stmt 1 view .LVU666
 2086               		.loc 4 403 9 is_stmt 0 view .LVU667
 2087 0744 88E7      		ldi r24,lo8(120)
 2088 0746 8AB9      		out 0xa,r24
 404:main.c        ****    PORTD= 0b00000000;
 2089               		.loc 4 404 4 is_stmt 1 view .LVU668
 2090               		.loc 4 404 9 is_stmt 0 view .LVU669
 2091 0748 1BB8      		out 0xb,__zero_reg__
 405:main.c        ****    DDRE = 0b00000000;   // DDRE |= (1<<2);   be carefull with hwb, check if its connected to GND vi
 2092               		.loc 4 405 4 is_stmt 1 view .LVU670
 2093               		.loc 4 405 9 is_stmt 0 view .LVU671
 2094 074a 1DB8      		out 0xd,__zero_reg__
 406:main.c        ****    DDRB = 0b11110110;
 2095               		.loc 4 406 4 is_stmt 1 view .LVU672
 2096               		.loc 4 406 9 is_stmt 0 view .LVU673
 2097 074c 86EF      		ldi r24,lo8(-10)
 2098 074e 84B9      		out 0x4,r24
 407:main.c        ****    DDRC = 0b11000000;
 2099               		.loc 4 407 4 is_stmt 1 view .LVU674
 2100               		.loc 4 407 9 is_stmt 0 view .LVU675
 2101 0750 80EC      		ldi r24,lo8(-64)
 2102 0752 87B9      		out 0x7,r24
 408:main.c        ****    OCR0A = 0;           //    start value for FAN  0 / 255  (-> p-channel so inverted)       0x00 i
 2103               		.loc 4 408 4 is_stmt 1 view .LVU676
 2104               		.loc 4 408 10 is_stmt 0 view .LVU677
 2105 0754 17BC      		out 0x27,__zero_reg__
 409:main.c        ****    TCCR0B  =  0b00000001;
 2106               		.loc 4 409 4 is_stmt 1 view .LVU678
 2107               		.loc 4 409 12 is_stmt 0 view .LVU679
 2108 0756 81E0      		ldi r24,lo8(1)
 2109 0758 85BD      		out 0x25,r24
 410:main.c        ****    TCCR0A  =  0b10000001;            // 8bit dual slope 31khz
 2110               		.loc 4 410 4 is_stmt 1 view .LVU680
 2111               		.loc 4 410 12 is_stmt 0 view .LVU681
 2112 075a 81E8      		ldi r24,lo8(-127)
 2113 075c 84BD      		out 0x24,r24
 411:main.c        ****    TIMSK0 |= (1 << TOIE0);            // init interrupt for timer0 overflow
 2114               		.loc 4 411 4 is_stmt 1 view .LVU682
 2115               		.loc 4 411 11 is_stmt 0 view .LVU683
 2116 075e EEE6      		ldi r30,lo8(110)
 2117 0760 F0E0      		ldi r31,0
 2118 0762 8081      		ld r24,Z
 2119 0764 8160      		ori r24,lo8(1)
 2120 0766 8083      		st Z,r24
 412:main.c        ****    clock_prescale_set(clock_div_1);
 2121               		.loc 4 412 4 is_stmt 1 view .LVU684
 2122               	.LVL82:
 2123               	.LBB87:
 2124               	.LBI87:
 2125               		.file 5 "/usr/avr/include/avr/power.h"
   1:/usr/avr/include/avr/power.h **** /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
   2:/usr/avr/include/avr/power.h ****    Copyright (c) 2011 Frdric Nadeau
   3:/usr/avr/include/avr/power.h ****    All rights reserved.
   4:/usr/avr/include/avr/power.h **** 
   5:/usr/avr/include/avr/power.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/avr/power.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/avr/power.h **** 
   8:/usr/avr/include/avr/power.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/avr/power.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/avr/include/avr/power.h ****      the documentation and/or other materials provided with the
  13:/usr/avr/include/avr/power.h ****      distribution.
  14:/usr/avr/include/avr/power.h ****    * Neither the name of the copyright holders nor the names of
  15:/usr/avr/include/avr/power.h ****      contributors may be used to endorse or promote products derived
  16:/usr/avr/include/avr/power.h ****      from this software without specific prior written permission.
  17:/usr/avr/include/avr/power.h **** 
  18:/usr/avr/include/avr/power.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  19:/usr/avr/include/avr/power.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  20:/usr/avr/include/avr/power.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  21:/usr/avr/include/avr/power.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  22:/usr/avr/include/avr/power.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  23:/usr/avr/include/avr/power.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  24:/usr/avr/include/avr/power.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  25:/usr/avr/include/avr/power.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  26:/usr/avr/include/avr/power.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  27:/usr/avr/include/avr/power.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  28:/usr/avr/include/avr/power.h ****   POSSIBILITY OF SUCH DAMAGE. */
  29:/usr/avr/include/avr/power.h **** 
  30:/usr/avr/include/avr/power.h **** /* $Id: power.h 2503 2016-02-07 22:59:47Z joerg_wunsch $ */
  31:/usr/avr/include/avr/power.h **** 
  32:/usr/avr/include/avr/power.h **** #ifndef _AVR_POWER_H_
  33:/usr/avr/include/avr/power.h **** #define _AVR_POWER_H_   1
  34:/usr/avr/include/avr/power.h **** 
  35:/usr/avr/include/avr/power.h **** #include <avr/io.h>
  36:/usr/avr/include/avr/power.h **** #include <stdint.h>
  37:/usr/avr/include/avr/power.h **** 
  38:/usr/avr/include/avr/power.h **** 
  39:/usr/avr/include/avr/power.h **** /** \file */
  40:/usr/avr/include/avr/power.h **** /** \defgroup avr_power <avr/power.h>: Power Reduction Management
  41:/usr/avr/include/avr/power.h **** 
  42:/usr/avr/include/avr/power.h **** \code #include <avr/power.h>\endcode
  43:/usr/avr/include/avr/power.h **** 
  44:/usr/avr/include/avr/power.h **** Many AVRs contain a Power Reduction Register (PRR) or Registers (PRRx) that 
  45:/usr/avr/include/avr/power.h **** allow you to reduce power consumption by disabling or enabling various on-board 
  46:/usr/avr/include/avr/power.h **** peripherals as needed. Some devices have the XTAL Divide Control Register
  47:/usr/avr/include/avr/power.h **** (XDIV) which offer similar functionality as System Clock Prescale
  48:/usr/avr/include/avr/power.h **** Register (CLKPR).
  49:/usr/avr/include/avr/power.h **** 
  50:/usr/avr/include/avr/power.h **** There are many macros in this header file that provide an easy interface
  51:/usr/avr/include/avr/power.h **** to enable or disable on-board peripherals to reduce power. See the table below.
  52:/usr/avr/include/avr/power.h **** 
  53:/usr/avr/include/avr/power.h **** \note Not all AVR devices have a Power Reduction Register (for example
  54:/usr/avr/include/avr/power.h **** the ATmega8). On those devices without a Power Reduction Register, the
  55:/usr/avr/include/avr/power.h **** power reduction macros are not available..
  56:/usr/avr/include/avr/power.h **** 
  57:/usr/avr/include/avr/power.h **** \note Not all AVR devices contain the same peripherals (for example, the LCD
  58:/usr/avr/include/avr/power.h **** interface), or they will be named differently (for example, USART and 
  59:/usr/avr/include/avr/power.h **** USART0). Please consult your device's datasheet, or the header file, to 
  60:/usr/avr/include/avr/power.h **** find out which macros are applicable to your device.
  61:/usr/avr/include/avr/power.h **** 
  62:/usr/avr/include/avr/power.h **** \note For device using the XTAL Divide Control Register (XDIV), when prescaler
  63:/usr/avr/include/avr/power.h **** is used, Timer/Counter0 can only be used in asynchronous mode. Keep in mind
  64:/usr/avr/include/avr/power.h **** that Timer/Counter0 source shall be less than th of peripheral clock.
  65:/usr/avr/include/avr/power.h **** Therefore, when using a typical 32.768 kHz crystal, one shall not scale
  66:/usr/avr/include/avr/power.h **** the clock below 131.072 kHz.
  67:/usr/avr/include/avr/power.h **** 
  68:/usr/avr/include/avr/power.h **** */
  69:/usr/avr/include/avr/power.h **** 
  70:/usr/avr/include/avr/power.h **** 
  71:/usr/avr/include/avr/power.h **** /** \addtogroup avr_power
  72:/usr/avr/include/avr/power.h **** 
  73:/usr/avr/include/avr/power.h **** \anchor avr_powermacros
  74:/usr/avr/include/avr/power.h **** <small>
  75:/usr/avr/include/avr/power.h **** <center>
  76:/usr/avr/include/avr/power.h **** <table border="3">
  77:/usr/avr/include/avr/power.h ****   <tr>
  78:/usr/avr/include/avr/power.h ****     <td width="10%"><strong>Power Macro</strong></td>
  79:/usr/avr/include/avr/power.h ****     <td width="15%"><strong>Description</strong></td>
  80:/usr/avr/include/avr/power.h ****   </tr>
  81:/usr/avr/include/avr/power.h **** 
  82:/usr/avr/include/avr/power.h ****   <tr>
  83:/usr/avr/include/avr/power.h ****     <td>power_aca_disable()</td>
  84:/usr/avr/include/avr/power.h ****     <td>Disable the Analog Comparator on PortA.</td>
  85:/usr/avr/include/avr/power.h ****   </tr>
  86:/usr/avr/include/avr/power.h **** 
  87:/usr/avr/include/avr/power.h ****   <tr>
  88:/usr/avr/include/avr/power.h ****     <td>power_aca_enable()</td>
  89:/usr/avr/include/avr/power.h ****     <td>Enable the Analog Comparator on PortA.</td>
  90:/usr/avr/include/avr/power.h ****   </tr>
  91:/usr/avr/include/avr/power.h **** 
  92:/usr/avr/include/avr/power.h ****   <tr>
  93:/usr/avr/include/avr/power.h ****     <td>power_adc_enable()</td>
  94:/usr/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module.</td>
  95:/usr/avr/include/avr/power.h ****   </tr>
  96:/usr/avr/include/avr/power.h **** 
  97:/usr/avr/include/avr/power.h ****   <tr>
  98:/usr/avr/include/avr/power.h ****     <td>power_adc_disable()</td>
  99:/usr/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module.</td>
 100:/usr/avr/include/avr/power.h ****   </tr>
 101:/usr/avr/include/avr/power.h **** 
 102:/usr/avr/include/avr/power.h ****   <tr>
 103:/usr/avr/include/avr/power.h ****     <td>power_adca_disable()</td>
 104:/usr/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module on PortA</td>
 105:/usr/avr/include/avr/power.h ****   </tr>
 106:/usr/avr/include/avr/power.h **** 
 107:/usr/avr/include/avr/power.h ****   <tr>
 108:/usr/avr/include/avr/power.h ****     <td>power_adca_enable()</td>
 109:/usr/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module on PortA</td>
 110:/usr/avr/include/avr/power.h ****   </tr>
 111:/usr/avr/include/avr/power.h **** 
 112:/usr/avr/include/avr/power.h ****   <tr>
 113:/usr/avr/include/avr/power.h ****     <td>power_evsys_disable()</td>
 114:/usr/avr/include/avr/power.h ****     <td>Disable the EVSYS module</td>
 115:/usr/avr/include/avr/power.h ****   </tr>
 116:/usr/avr/include/avr/power.h **** 
 117:/usr/avr/include/avr/power.h ****   <tr>
 118:/usr/avr/include/avr/power.h ****     <td>power_evsys_enable()</td>
 119:/usr/avr/include/avr/power.h ****     <td>Enable the EVSYS module</td>
 120:/usr/avr/include/avr/power.h ****   </tr>
 121:/usr/avr/include/avr/power.h **** 
 122:/usr/avr/include/avr/power.h ****   <tr>
 123:/usr/avr/include/avr/power.h ****     <td>power_hiresc_disable()</td>
 124:/usr/avr/include/avr/power.h ****     <td>Disable the HIRES module on PortC</td>
 125:/usr/avr/include/avr/power.h ****   </tr>
 126:/usr/avr/include/avr/power.h **** 
 127:/usr/avr/include/avr/power.h ****   <tr>
 128:/usr/avr/include/avr/power.h ****     <td>power_hiresc_enable()</td>
 129:/usr/avr/include/avr/power.h ****     <td>Enable the HIRES module on PortC</td>
 130:/usr/avr/include/avr/power.h ****   </tr>
 131:/usr/avr/include/avr/power.h **** 
 132:/usr/avr/include/avr/power.h ****    <tr>
 133:/usr/avr/include/avr/power.h ****     <td>power_lcd_enable()</td>
 134:/usr/avr/include/avr/power.h ****     <td>Enable the LCD module.</td>
 135:/usr/avr/include/avr/power.h ****   </tr>
 136:/usr/avr/include/avr/power.h **** 
 137:/usr/avr/include/avr/power.h ****   <tr>
 138:/usr/avr/include/avr/power.h ****     <td>power_lcd_disable().</td>
 139:/usr/avr/include/avr/power.h ****     <td>Disable the LCD module.</td>
 140:/usr/avr/include/avr/power.h ****   </tr>
 141:/usr/avr/include/avr/power.h **** 
 142:/usr/avr/include/avr/power.h ****   <tr>
 143:/usr/avr/include/avr/power.h ****     <td>power_pga_enable()</td>
 144:/usr/avr/include/avr/power.h ****     <td>Enable the Programmable Gain Amplifier module.</td>
 145:/usr/avr/include/avr/power.h ****   </tr>
 146:/usr/avr/include/avr/power.h **** 
 147:/usr/avr/include/avr/power.h ****   <tr>
 148:/usr/avr/include/avr/power.h ****     <td>power_pga_disable()</td>
 149:/usr/avr/include/avr/power.h ****     <td>Disable the Programmable Gain Amplifier module.</td>
 150:/usr/avr/include/avr/power.h ****   </tr>
 151:/usr/avr/include/avr/power.h ****   
 152:/usr/avr/include/avr/power.h ****   <tr>
 153:/usr/avr/include/avr/power.h ****     <td>power_pscr_enable()</td>
 154:/usr/avr/include/avr/power.h ****     <td>Enable the Reduced Power Stage Controller module.</td>
 155:/usr/avr/include/avr/power.h ****   </tr>
 156:/usr/avr/include/avr/power.h **** 
 157:/usr/avr/include/avr/power.h ****   <tr>
 158:/usr/avr/include/avr/power.h ****     <td>power_pscr_disable()</td>
 159:/usr/avr/include/avr/power.h ****     <td>Disable the Reduced Power Stage Controller module.</td>
 160:/usr/avr/include/avr/power.h ****   </tr>
 161:/usr/avr/include/avr/power.h **** 
 162:/usr/avr/include/avr/power.h ****   <tr>
 163:/usr/avr/include/avr/power.h ****     <td>power_psc0_enable()</td>
 164:/usr/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 0 module.</td>
 165:/usr/avr/include/avr/power.h ****   </tr>
 166:/usr/avr/include/avr/power.h **** 
 167:/usr/avr/include/avr/power.h ****   <tr>
 168:/usr/avr/include/avr/power.h ****     <td>power_psc0_disable()</td>
 169:/usr/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 0 module.</td>
 170:/usr/avr/include/avr/power.h ****   </tr>
 171:/usr/avr/include/avr/power.h **** 
 172:/usr/avr/include/avr/power.h ****   <tr>
 173:/usr/avr/include/avr/power.h ****     <td>power_psc1_enable()</td>
 174:/usr/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 1 module.</td>
 175:/usr/avr/include/avr/power.h ****   </tr>
 176:/usr/avr/include/avr/power.h **** 
 177:/usr/avr/include/avr/power.h ****   <tr>
 178:/usr/avr/include/avr/power.h ****     <td>power_psc1_disable()</td>
 179:/usr/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 1 module.</td>
 180:/usr/avr/include/avr/power.h ****   </tr>
 181:/usr/avr/include/avr/power.h **** 
 182:/usr/avr/include/avr/power.h ****   <tr>
 183:/usr/avr/include/avr/power.h ****     <td>power_psc2_enable()</td>
 184:/usr/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 2 module.</td>
 185:/usr/avr/include/avr/power.h ****   </tr>
 186:/usr/avr/include/avr/power.h **** 
 187:/usr/avr/include/avr/power.h ****   <tr>
 188:/usr/avr/include/avr/power.h ****     <td>power_psc2_disable()</td>
 189:/usr/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 2 module.</td>
 190:/usr/avr/include/avr/power.h ****   </tr>
 191:/usr/avr/include/avr/power.h **** 
 192:/usr/avr/include/avr/power.h ****   <tr>
 193:/usr/avr/include/avr/power.h ****     <td>power_ram0_enable()</td>
 194:/usr/avr/include/avr/power.h ****     <td>Enable the SRAM block 0 .</td>
 195:/usr/avr/include/avr/power.h ****   </tr>
 196:/usr/avr/include/avr/power.h **** 
 197:/usr/avr/include/avr/power.h ****   <tr>
 198:/usr/avr/include/avr/power.h ****     <td>power_ram0_disable()</td>
 199:/usr/avr/include/avr/power.h ****     <td>Disable the SRAM block 0. </td>
 200:/usr/avr/include/avr/power.h ****   </tr>
 201:/usr/avr/include/avr/power.h **** 
 202:/usr/avr/include/avr/power.h ****   <tr>
 203:/usr/avr/include/avr/power.h ****     <td>power_ram1_enable()</td>
 204:/usr/avr/include/avr/power.h ****     <td>Enable the SRAM block 1 .</td>
 205:/usr/avr/include/avr/power.h ****   </tr>
 206:/usr/avr/include/avr/power.h **** 
 207:/usr/avr/include/avr/power.h ****   <tr>
 208:/usr/avr/include/avr/power.h ****     <td>power_ram1_disable()</td>
 209:/usr/avr/include/avr/power.h ****     <td>Disable the SRAM block 1. </td>
 210:/usr/avr/include/avr/power.h ****   </tr>
 211:/usr/avr/include/avr/power.h **** 
 212:/usr/avr/include/avr/power.h ****   <tr>
 213:/usr/avr/include/avr/power.h ****     <td>power_ram2_enable()</td>
 214:/usr/avr/include/avr/power.h ****     <td>Enable the SRAM block 2 .</td>
 215:/usr/avr/include/avr/power.h ****   </tr>
 216:/usr/avr/include/avr/power.h **** 
 217:/usr/avr/include/avr/power.h ****   <tr>
 218:/usr/avr/include/avr/power.h ****     <td>power_ram2_disable()</td>
 219:/usr/avr/include/avr/power.h ****     <td>Disable the SRAM block 2. </td>
 220:/usr/avr/include/avr/power.h ****   </tr>
 221:/usr/avr/include/avr/power.h **** 
 222:/usr/avr/include/avr/power.h ****   <tr>
 223:/usr/avr/include/avr/power.h ****     <td>power_ram3_enable()</td>
 224:/usr/avr/include/avr/power.h ****     <td>Enable the SRAM block 3 .</td>
 225:/usr/avr/include/avr/power.h ****   </tr>
 226:/usr/avr/include/avr/power.h **** 
 227:/usr/avr/include/avr/power.h ****   <tr>
 228:/usr/avr/include/avr/power.h ****     <td>power_ram3_disable()</td>
 229:/usr/avr/include/avr/power.h ****     <td>Disable the SRAM block 3. </td>
 230:/usr/avr/include/avr/power.h ****   </tr>
 231:/usr/avr/include/avr/power.h **** 
 232:/usr/avr/include/avr/power.h ****   <tr>
 233:/usr/avr/include/avr/power.h ****     <td>power_rtc_disable()</td>
 234:/usr/avr/include/avr/power.h ****     <td>Disable the RTC module</td>
 235:/usr/avr/include/avr/power.h ****   </tr>
 236:/usr/avr/include/avr/power.h **** 
 237:/usr/avr/include/avr/power.h ****   <tr>
 238:/usr/avr/include/avr/power.h ****     <td>power_rtc_enable()</td>
 239:/usr/avr/include/avr/power.h ****     <td>Enable the RTC module</td>
 240:/usr/avr/include/avr/power.h ****   </tr>
 241:/usr/avr/include/avr/power.h **** 
 242:/usr/avr/include/avr/power.h ****   <tr>
 243:/usr/avr/include/avr/power.h ****     <td>power_spi_enable()</td>
 244:/usr/avr/include/avr/power.h ****     <td>Enable the Serial Peripheral Interface module.</td>
 245:/usr/avr/include/avr/power.h ****   </tr>
 246:/usr/avr/include/avr/power.h **** 
 247:/usr/avr/include/avr/power.h ****   <tr>
 248:/usr/avr/include/avr/power.h ****     <td>power_spi_disable()</td>
 249:/usr/avr/include/avr/power.h ****     <td>Disable the Serial Peripheral Interface module.</td>
 250:/usr/avr/include/avr/power.h ****   </tr>
 251:/usr/avr/include/avr/power.h **** 
 252:/usr/avr/include/avr/power.h ****   <tr>
 253:/usr/avr/include/avr/power.h ****     <td>power_spic_disable()</td>
 254:/usr/avr/include/avr/power.h ****     <td>Disable the SPI module on PortC</td>
 255:/usr/avr/include/avr/power.h ****   </tr>
 256:/usr/avr/include/avr/power.h **** 
 257:/usr/avr/include/avr/power.h ****   <tr>
 258:/usr/avr/include/avr/power.h ****     <td>power_spic_enable()</td>
 259:/usr/avr/include/avr/power.h ****     <td>Enable the SPI module on PortC</td>
 260:/usr/avr/include/avr/power.h ****   </tr>
 261:/usr/avr/include/avr/power.h **** 
 262:/usr/avr/include/avr/power.h ****   <tr>
 263:/usr/avr/include/avr/power.h ****     <td>power_spid_disable()</td>
 264:/usr/avr/include/avr/power.h ****     <td>Disable the SPI module on PortD</td>
 265:/usr/avr/include/avr/power.h ****   </tr>
 266:/usr/avr/include/avr/power.h **** 
 267:/usr/avr/include/avr/power.h ****   <tr>
 268:/usr/avr/include/avr/power.h ****     <td>power_spid_enable()</td>
 269:/usr/avr/include/avr/power.h ****     <td>Enable the SPI module on PortD</td>
 270:/usr/avr/include/avr/power.h ****   </tr>
 271:/usr/avr/include/avr/power.h **** 
 272:/usr/avr/include/avr/power.h ****   <tr>
 273:/usr/avr/include/avr/power.h ****     <td>power_tc0c_disable()</td>
 274:/usr/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortC</td>
 275:/usr/avr/include/avr/power.h ****   </tr>
 276:/usr/avr/include/avr/power.h **** 
 277:/usr/avr/include/avr/power.h ****   <tr>
 278:/usr/avr/include/avr/power.h ****     <td>power_tc0c_enable()</td>
 279:/usr/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortC</td>
 280:/usr/avr/include/avr/power.h ****   </tr>
 281:/usr/avr/include/avr/power.h **** 
 282:/usr/avr/include/avr/power.h ****   <tr>
 283:/usr/avr/include/avr/power.h ****     <td>power_tc0d_disable()</td>
 284:/usr/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortD</td>
 285:/usr/avr/include/avr/power.h ****   </tr>
 286:/usr/avr/include/avr/power.h **** 
 287:/usr/avr/include/avr/power.h ****   <tr>
 288:/usr/avr/include/avr/power.h ****     <td>power_tc0d_enable()</td>
 289:/usr/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortD</td>
 290:/usr/avr/include/avr/power.h ****   </tr>
 291:/usr/avr/include/avr/power.h **** 
 292:/usr/avr/include/avr/power.h ****   <tr>
 293:/usr/avr/include/avr/power.h ****     <td>power_tc0e_disable()</td>
 294:/usr/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortE</td>
 295:/usr/avr/include/avr/power.h ****   </tr>
 296:/usr/avr/include/avr/power.h **** 
 297:/usr/avr/include/avr/power.h ****   <tr>
 298:/usr/avr/include/avr/power.h ****     <td>power_tc0e_enable()</td>
 299:/usr/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortE</td>
 300:/usr/avr/include/avr/power.h ****   </tr>
 301:/usr/avr/include/avr/power.h **** 
 302:/usr/avr/include/avr/power.h ****   <tr>
 303:/usr/avr/include/avr/power.h ****     <td>power_tc0f_disable()</td>
 304:/usr/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortF</td>
 305:/usr/avr/include/avr/power.h ****   </tr>
 306:/usr/avr/include/avr/power.h **** 
 307:/usr/avr/include/avr/power.h ****   <tr>
 308:/usr/avr/include/avr/power.h ****     <td>power_tc0f_enable()</td>
 309:/usr/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortF</td>
 310:/usr/avr/include/avr/power.h ****   </tr>
 311:/usr/avr/include/avr/power.h **** 
 312:/usr/avr/include/avr/power.h ****   <tr>
 313:/usr/avr/include/avr/power.h ****     <td>power_tc1c_disable()</td>
 314:/usr/avr/include/avr/power.h ****     <td>Disable the TC1 module on PortC</td>
 315:/usr/avr/include/avr/power.h ****   </tr>
 316:/usr/avr/include/avr/power.h **** 
 317:/usr/avr/include/avr/power.h ****   <tr>
 318:/usr/avr/include/avr/power.h ****     <td>power_tc1c_enable()</td>
 319:/usr/avr/include/avr/power.h ****     <td>Enable the TC1 module on PortC</td>
 320:/usr/avr/include/avr/power.h ****   </tr>
 321:/usr/avr/include/avr/power.h **** 
 322:/usr/avr/include/avr/power.h ****   <tr>
 323:/usr/avr/include/avr/power.h ****     <td>power_twic_disable()</td>
 324:/usr/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortC</td>
 325:/usr/avr/include/avr/power.h ****   </tr>
 326:/usr/avr/include/avr/power.h **** 
 327:/usr/avr/include/avr/power.h ****   <tr>
 328:/usr/avr/include/avr/power.h ****     <td>power_twic_enable()</td>
 329:/usr/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortC</td>
 330:/usr/avr/include/avr/power.h ****   </tr>
 331:/usr/avr/include/avr/power.h **** 
 332:/usr/avr/include/avr/power.h ****   <tr>
 333:/usr/avr/include/avr/power.h ****     <td>power_twie_disable()</td>
 334:/usr/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortE</td>
 335:/usr/avr/include/avr/power.h ****   </tr>
 336:/usr/avr/include/avr/power.h **** 
 337:/usr/avr/include/avr/power.h ****   <tr>
 338:/usr/avr/include/avr/power.h ****     <td>power_twie_enable()</td>
 339:/usr/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortE</td>
 340:/usr/avr/include/avr/power.h ****   </tr>
 341:/usr/avr/include/avr/power.h **** 
 342:/usr/avr/include/avr/power.h ****   <tr>
 343:/usr/avr/include/avr/power.h ****     <td>power_timer0_enable()</td>
 344:/usr/avr/include/avr/power.h ****     <td>Enable the Timer 0 module.</td>
 345:/usr/avr/include/avr/power.h ****   </tr>
 346:/usr/avr/include/avr/power.h **** 
 347:/usr/avr/include/avr/power.h ****   <tr>
 348:/usr/avr/include/avr/power.h ****     <td>power_timer0_disable()</td>
 349:/usr/avr/include/avr/power.h ****     <td>Disable the Timer 0 module.</td>
 350:/usr/avr/include/avr/power.h ****   </tr>
 351:/usr/avr/include/avr/power.h **** 
 352:/usr/avr/include/avr/power.h ****   <tr>
 353:/usr/avr/include/avr/power.h ****     <td>power_timer1_enable()</td>
 354:/usr/avr/include/avr/power.h ****     <td>Enable the Timer 1 module.</td>
 355:/usr/avr/include/avr/power.h ****   </tr>
 356:/usr/avr/include/avr/power.h **** 
 357:/usr/avr/include/avr/power.h ****   <tr>
 358:/usr/avr/include/avr/power.h ****     <td>power_timer1_disable()</td>
 359:/usr/avr/include/avr/power.h ****     <td>Disable the Timer 1 module.</td>
 360:/usr/avr/include/avr/power.h ****   </tr>
 361:/usr/avr/include/avr/power.h **** 
 362:/usr/avr/include/avr/power.h ****   <tr>
 363:/usr/avr/include/avr/power.h ****     <td>power_timer2_enable()</td>
 364:/usr/avr/include/avr/power.h ****     <td>Enable the Timer 2 module.</td>
 365:/usr/avr/include/avr/power.h ****   </tr>
 366:/usr/avr/include/avr/power.h **** 
 367:/usr/avr/include/avr/power.h ****   <tr>
 368:/usr/avr/include/avr/power.h ****     <td>power_timer2_disable()</td>
 369:/usr/avr/include/avr/power.h ****     <td>Disable the Timer 2 module.</td>
 370:/usr/avr/include/avr/power.h ****   </tr>
 371:/usr/avr/include/avr/power.h **** 
 372:/usr/avr/include/avr/power.h ****   <tr>
 373:/usr/avr/include/avr/power.h ****     <td>power_timer3_enable()</td>
 374:/usr/avr/include/avr/power.h ****     <td>Enable the Timer 3 module.</td>
 375:/usr/avr/include/avr/power.h ****   </tr>
 376:/usr/avr/include/avr/power.h **** 
 377:/usr/avr/include/avr/power.h ****   <tr>
 378:/usr/avr/include/avr/power.h ****     <td>power_timer3_disable()</td>
 379:/usr/avr/include/avr/power.h ****     <td>Disable the Timer 3 module.</td>
 380:/usr/avr/include/avr/power.h ****   </tr>
 381:/usr/avr/include/avr/power.h **** 
 382:/usr/avr/include/avr/power.h ****   <tr>
 383:/usr/avr/include/avr/power.h ****     <td>power_timer4_enable()</td>
 384:/usr/avr/include/avr/power.h ****     <td>Enable the Timer 4 module.</td>
 385:/usr/avr/include/avr/power.h ****   </tr>
 386:/usr/avr/include/avr/power.h **** 
 387:/usr/avr/include/avr/power.h ****   <tr>
 388:/usr/avr/include/avr/power.h ****     <td>power_timer4_disable()</td>
 389:/usr/avr/include/avr/power.h ****     <td>Disable the Timer 4 module.</td>
 390:/usr/avr/include/avr/power.h ****   </tr>
 391:/usr/avr/include/avr/power.h **** 
 392:/usr/avr/include/avr/power.h ****   <tr>
 393:/usr/avr/include/avr/power.h ****     <td>power_timer5_enable()</td>
 394:/usr/avr/include/avr/power.h ****     <td>Enable the Timer 5 module.</td>
 395:/usr/avr/include/avr/power.h ****   </tr>
 396:/usr/avr/include/avr/power.h **** 
 397:/usr/avr/include/avr/power.h ****   <tr>
 398:/usr/avr/include/avr/power.h ****     <td>power_timer5_disable()</td>
 399:/usr/avr/include/avr/power.h ****     <td>Disable the Timer 5 module.</td>
 400:/usr/avr/include/avr/power.h ****   </tr>
 401:/usr/avr/include/avr/power.h **** 
 402:/usr/avr/include/avr/power.h ****   <tr>
 403:/usr/avr/include/avr/power.h ****     <td>power_twi_enable()</td>
 404:/usr/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module.</td>
 405:/usr/avr/include/avr/power.h ****   </tr>
 406:/usr/avr/include/avr/power.h **** 
 407:/usr/avr/include/avr/power.h ****   <tr>
 408:/usr/avr/include/avr/power.h ****     <td>power_twi_disable()</td>
 409:/usr/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module.</td>
 410:/usr/avr/include/avr/power.h ****   </tr>
 411:/usr/avr/include/avr/power.h **** 
 412:/usr/avr/include/avr/power.h ****   <tr>
 413:/usr/avr/include/avr/power.h ****     <td>power_usart_enable()</td>
 414:/usr/avr/include/avr/power.h ****     <td>Enable the USART module.</td>
 415:/usr/avr/include/avr/power.h ****   </tr>
 416:/usr/avr/include/avr/power.h **** 
 417:/usr/avr/include/avr/power.h ****   <tr>
 418:/usr/avr/include/avr/power.h ****     <td>power_usart_disable()</td>
 419:/usr/avr/include/avr/power.h ****     <td>Disable the USART module.</td>
 420:/usr/avr/include/avr/power.h ****   </tr>
 421:/usr/avr/include/avr/power.h **** 
 422:/usr/avr/include/avr/power.h ****   <tr>
 423:/usr/avr/include/avr/power.h ****     <td>power_usart0_enable()</td>
 424:/usr/avr/include/avr/power.h ****     <td>Enable the USART 0 module.</td>
 425:/usr/avr/include/avr/power.h ****   </tr>
 426:/usr/avr/include/avr/power.h **** 
 427:/usr/avr/include/avr/power.h ****   <tr>
 428:/usr/avr/include/avr/power.h ****     <td>power_usart0_disable()</td>
 429:/usr/avr/include/avr/power.h ****     <td>Disable the USART 0 module.</td>
 430:/usr/avr/include/avr/power.h ****   </tr>
 431:/usr/avr/include/avr/power.h **** 
 432:/usr/avr/include/avr/power.h ****   <tr>
 433:/usr/avr/include/avr/power.h ****     <td>power_usart1_enable()</td>
 434:/usr/avr/include/avr/power.h ****     <td>Enable the USART 1 module.</td>
 435:/usr/avr/include/avr/power.h ****   </tr>
 436:/usr/avr/include/avr/power.h **** 
 437:/usr/avr/include/avr/power.h ****   <tr>
 438:/usr/avr/include/avr/power.h ****     <td>power_usart1_disable()</td>
 439:/usr/avr/include/avr/power.h ****     <td>Disable the USART 1 module.</td>
 440:/usr/avr/include/avr/power.h ****   </tr>
 441:/usr/avr/include/avr/power.h **** 
 442:/usr/avr/include/avr/power.h ****   <tr>
 443:/usr/avr/include/avr/power.h ****     <td>power_usart2_enable()</td>
 444:/usr/avr/include/avr/power.h ****     <td>Enable the USART 2 module.</td>
 445:/usr/avr/include/avr/power.h ****   </tr>
 446:/usr/avr/include/avr/power.h **** 
 447:/usr/avr/include/avr/power.h ****   <tr>
 448:/usr/avr/include/avr/power.h ****     <td>power_usart2_disable()</td>
 449:/usr/avr/include/avr/power.h ****     <td>Disable the USART 2 module.</td>
 450:/usr/avr/include/avr/power.h ****   </tr>
 451:/usr/avr/include/avr/power.h **** 
 452:/usr/avr/include/avr/power.h ****   <tr>
 453:/usr/avr/include/avr/power.h ****     <td>power_usart3_enable()</td>
 454:/usr/avr/include/avr/power.h ****     <td>Enable the USART 3 module.</td>
 455:/usr/avr/include/avr/power.h ****   </tr>
 456:/usr/avr/include/avr/power.h **** 
 457:/usr/avr/include/avr/power.h ****   <tr>
 458:/usr/avr/include/avr/power.h ****     <td>power_usart3_disable()</td>
 459:/usr/avr/include/avr/power.h ****     <td>Disable the USART 3 module.</td>
 460:/usr/avr/include/avr/power.h ****   </tr>
 461:/usr/avr/include/avr/power.h **** 
 462:/usr/avr/include/avr/power.h ****   <tr>
 463:/usr/avr/include/avr/power.h ****     <td>power_usartc0_disable()</td>
 464:/usr/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortC</td>
 465:/usr/avr/include/avr/power.h ****   </tr>
 466:/usr/avr/include/avr/power.h **** 
 467:/usr/avr/include/avr/power.h ****   <tr>
 468:/usr/avr/include/avr/power.h ****     <td>power_usartc0_enable()</td>
 469:/usr/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortC</td>
 470:/usr/avr/include/avr/power.h ****   </tr>
 471:/usr/avr/include/avr/power.h **** 
 472:/usr/avr/include/avr/power.h ****   <tr>
 473:/usr/avr/include/avr/power.h ****     <td>power_usartd0_disable()</td>
 474:/usr/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortD</td>
 475:/usr/avr/include/avr/power.h ****   </tr>
 476:/usr/avr/include/avr/power.h **** 
 477:/usr/avr/include/avr/power.h ****   <tr>
 478:/usr/avr/include/avr/power.h ****     <td>power_usartd0_enable()</td>
 479:/usr/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortD</td>
 480:/usr/avr/include/avr/power.h ****   </tr>
 481:/usr/avr/include/avr/power.h **** 
 482:/usr/avr/include/avr/power.h ****   <tr>
 483:/usr/avr/include/avr/power.h ****     <td>power_usarte0_disable()</td>
 484:/usr/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortE</td>
 485:/usr/avr/include/avr/power.h ****   </tr>
 486:/usr/avr/include/avr/power.h **** 
 487:/usr/avr/include/avr/power.h ****   <tr>
 488:/usr/avr/include/avr/power.h ****     <td>power_usarte0_enable()</td>
 489:/usr/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortE</td>
 490:/usr/avr/include/avr/power.h ****   </tr>
 491:/usr/avr/include/avr/power.h **** 
 492:/usr/avr/include/avr/power.h ****   <tr>
 493:/usr/avr/include/avr/power.h ****     <td>power_usartf0_disable()</td>
 494:/usr/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortF</td>
 495:/usr/avr/include/avr/power.h ****   </tr>
 496:/usr/avr/include/avr/power.h **** 
 497:/usr/avr/include/avr/power.h ****   <tr>
 498:/usr/avr/include/avr/power.h ****     <td>power_usartf0_enable()</td>
 499:/usr/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortF</td>
 500:/usr/avr/include/avr/power.h ****   </tr>
 501:/usr/avr/include/avr/power.h **** 
 502:/usr/avr/include/avr/power.h ****   <tr>
 503:/usr/avr/include/avr/power.h ****     <td>power_usb_enable()</td>
 504:/usr/avr/include/avr/power.h ****     <td>Enable the USB module.</td>
 505:/usr/avr/include/avr/power.h ****   </tr>
 506:/usr/avr/include/avr/power.h **** 
 507:/usr/avr/include/avr/power.h ****   <tr>
 508:/usr/avr/include/avr/power.h ****     <td>power_usb_disable()</td>
 509:/usr/avr/include/avr/power.h ****     <td>Disable the USB module.</td>
 510:/usr/avr/include/avr/power.h ****   </tr>
 511:/usr/avr/include/avr/power.h **** 
 512:/usr/avr/include/avr/power.h ****   <tr>
 513:/usr/avr/include/avr/power.h ****     <td>power_usi_enable()</td>
 514:/usr/avr/include/avr/power.h ****     <td>Enable the Universal Serial Interface module.</td>
 515:/usr/avr/include/avr/power.h ****   </tr>
 516:/usr/avr/include/avr/power.h **** 
 517:/usr/avr/include/avr/power.h ****   <tr>
 518:/usr/avr/include/avr/power.h ****     <td>power_usi_disable()</td>
 519:/usr/avr/include/avr/power.h ****     <td>Disable the Universal Serial Interface module.</td>
 520:/usr/avr/include/avr/power.h ****   </tr>
 521:/usr/avr/include/avr/power.h **** 
 522:/usr/avr/include/avr/power.h ****   <tr>
 523:/usr/avr/include/avr/power.h ****     <td>power_vadc_enable()</td>
 524:/usr/avr/include/avr/power.h ****     <td>Enable the Voltage ADC module.</td>
 525:/usr/avr/include/avr/power.h ****   </tr>
 526:/usr/avr/include/avr/power.h **** 
 527:/usr/avr/include/avr/power.h ****   <tr>
 528:/usr/avr/include/avr/power.h ****     <td>power_vadc_disable()</td>
 529:/usr/avr/include/avr/power.h ****     <td>Disable the Voltage ADC module.</td>
 530:/usr/avr/include/avr/power.h ****   </tr>
 531:/usr/avr/include/avr/power.h **** 
 532:/usr/avr/include/avr/power.h ****   <tr>
 533:/usr/avr/include/avr/power.h ****     <td>power_all_enable()</td>
 534:/usr/avr/include/avr/power.h ****     <td>Enable all modules.</td>
 535:/usr/avr/include/avr/power.h ****   </tr>
 536:/usr/avr/include/avr/power.h **** 
 537:/usr/avr/include/avr/power.h ****   <tr>
 538:/usr/avr/include/avr/power.h ****     <td>power_all_disable()</td>
 539:/usr/avr/include/avr/power.h ****     <td>Disable all modules.</td>
 540:/usr/avr/include/avr/power.h ****   </tr>
 541:/usr/avr/include/avr/power.h **** </table>
 542:/usr/avr/include/avr/power.h **** </center>
 543:/usr/avr/include/avr/power.h **** </small>
 544:/usr/avr/include/avr/power.h **** 
 545:/usr/avr/include/avr/power.h **** @} */
 546:/usr/avr/include/avr/power.h **** 
 547:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRADC)
 548:/usr/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 549:/usr/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 550:/usr/avr/include/avr/power.h **** #endif
 551:/usr/avr/include/avr/power.h **** 
 552:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRCAN)
 553:/usr/avr/include/avr/power.h **** #define power_can_enable()      (PRR &= (uint8_t)~(1 << PRCAN))
 554:/usr/avr/include/avr/power.h **** #define power_can_disable()     (PRR |= (uint8_t)(1 << PRCAN))
 555:/usr/avr/include/avr/power.h **** #endif
 556:/usr/avr/include/avr/power.h **** 
 557:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLCD)
 558:/usr/avr/include/avr/power.h **** #define power_lcd_enable()      (PRR &= (uint8_t)~(1 << PRLCD))
 559:/usr/avr/include/avr/power.h **** #define power_lcd_disable()     (PRR |= (uint8_t)(1 << PRLCD))
 560:/usr/avr/include/avr/power.h **** #endif
 561:/usr/avr/include/avr/power.h **** 
 562:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLIN)
 563:/usr/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
 564:/usr/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
 565:/usr/avr/include/avr/power.h **** #endif
 566:/usr/avr/include/avr/power.h **** 
 567:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC)
 568:/usr/avr/include/avr/power.h **** #define power_psc_enable()      (PRR &= (uint8_t)~(1 << PRPSC))
 569:/usr/avr/include/avr/power.h **** #define power_psc_disable()     (PRR |= (uint8_t)(1 << PRPSC))
 570:/usr/avr/include/avr/power.h **** #endif
 571:/usr/avr/include/avr/power.h **** 
 572:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC0)
 573:/usr/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 574:/usr/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 575:/usr/avr/include/avr/power.h **** #endif
 576:/usr/avr/include/avr/power.h **** 
 577:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC1)
 578:/usr/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 579:/usr/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 580:/usr/avr/include/avr/power.h **** #endif
 581:/usr/avr/include/avr/power.h **** 
 582:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC2)
 583:/usr/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 584:/usr/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 585:/usr/avr/include/avr/power.h **** #endif
 586:/usr/avr/include/avr/power.h **** 
 587:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSCR)
 588:/usr/avr/include/avr/power.h **** #define power_pscr_enable()     (PRR &= (uint8_t)~(1 << PRPSCR))
 589:/usr/avr/include/avr/power.h **** #define power_pscr_disable()    (PRR |= (uint8_t)(1 << PRPSCR))
 590:/usr/avr/include/avr/power.h **** #endif
 591:/usr/avr/include/avr/power.h **** 
 592:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSPI)
 593:/usr/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 594:/usr/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 595:/usr/avr/include/avr/power.h **** #endif
 596:/usr/avr/include/avr/power.h **** 
 597:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM0)
 598:/usr/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 599:/usr/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 600:/usr/avr/include/avr/power.h **** #endif
 601:/usr/avr/include/avr/power.h **** 
 602:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM1)
 603:/usr/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 604:/usr/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 605:/usr/avr/include/avr/power.h **** #endif
 606:/usr/avr/include/avr/power.h **** 
 607:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM2)
 608:/usr/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR &= (uint8_t)~(1 << PRTIM2))
 609:/usr/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR |= (uint8_t)(1 << PRTIM2))
 610:/usr/avr/include/avr/power.h **** #endif
 611:/usr/avr/include/avr/power.h **** 
 612:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTWI)
 613:/usr/avr/include/avr/power.h **** #define power_twi_enable()      (PRR &= (uint8_t)~(1 << PRTWI))
 614:/usr/avr/include/avr/power.h **** #define power_twi_disable()     (PRR |= (uint8_t)(1 << PRTWI))
 615:/usr/avr/include/avr/power.h **** #endif
 616:/usr/avr/include/avr/power.h **** 
 617:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART)
 618:/usr/avr/include/avr/power.h **** #define power_usart_enable()    (PRR &= (uint8_t)~(1 << PRUSART))
 619:/usr/avr/include/avr/power.h **** #define power_usart_disable()   (PRR |= (uint8_t)(1 << PRUSART))
 620:/usr/avr/include/avr/power.h **** #endif
 621:/usr/avr/include/avr/power.h **** 
 622:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART0)
 623:/usr/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 624:/usr/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 625:/usr/avr/include/avr/power.h **** #endif
 626:/usr/avr/include/avr/power.h **** 
 627:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART1)
 628:/usr/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR &= (uint8_t)~(1 << PRUSART1))
 629:/usr/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR |= (uint8_t)(1 << PRUSART1))
 630:/usr/avr/include/avr/power.h **** #endif
 631:/usr/avr/include/avr/power.h **** 
 632:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSI)
 633:/usr/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
 634:/usr/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
 635:/usr/avr/include/avr/power.h **** #endif
 636:/usr/avr/include/avr/power.h **** 
 637:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRADC)
 638:/usr/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 639:/usr/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 640:/usr/avr/include/avr/power.h **** #endif
 641:/usr/avr/include/avr/power.h **** 
 642:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRC0)
 643:/usr/avr/include/avr/power.h **** #define power_clock_output_enable()     (PRR0 &= (uint8_t)~(1 << PRCO))
 644:/usr/avr/include/avr/power.h **** #define power_clock_output_disable()    (PRR0 |= (uint8_t)(1 << PRCO))
 645:/usr/avr/include/avr/power.h **** #endif
 646:/usr/avr/include/avr/power.h **** 
 647:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCRC)
 648:/usr/avr/include/avr/power.h **** #define power_crc_enable()              (PRR0 &= (uint8_t)~(1 << PRCRC))
 649:/usr/avr/include/avr/power.h **** #define power_crc_disable()             (PRR0 |= (uint8_t)(1 << PRCRC))
 650:/usr/avr/include/avr/power.h **** #endif
 651:/usr/avr/include/avr/power.h **** 
 652:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCU)
 653:/usr/avr/include/avr/power.h **** #define power_crypto_enable()           (PRR0 &= (uint8_t)~(1 << PRCU))
 654:/usr/avr/include/avr/power.h **** #define power_crypto_disable()          (PRR0 |= (uint8_t)(1 << PRCU))
 655:/usr/avr/include/avr/power.h **** #endif
 656:/usr/avr/include/avr/power.h **** 
 657:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRDS)
 658:/usr/avr/include/avr/power.h **** #define power_irdriver_enable()         (PRR0 &= (uint8_t)~(1 << PRDS))
 659:/usr/avr/include/avr/power.h **** #define power_irdriver_disable()        (PRR0 |= (uint8_t)(1 << PRDS))
 660:/usr/avr/include/avr/power.h **** #endif
 661:/usr/avr/include/avr/power.h **** 
 662:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFR)
 663:/usr/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR0 &= (uint8_t)~(1 << PRLFR))            
 664:/usr/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR0 |= (uint8_t)(1 << PRLFR))            
 665:/usr/avr/include/avr/power.h **** #endif
 666:/usr/avr/include/avr/power.h **** 
 667:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLIN)
 668:/usr/avr/include/avr/power.h **** #define power_lin_enable()              (PRR0 &= (uint8_t)~(1 << PRLIN))
 669:/usr/avr/include/avr/power.h **** #define power_lin_disable()             (PRR0 |= (uint8_t)(1 << PRLIN))
 670:/usr/avr/include/avr/power.h **** #endif
 671:/usr/avr/include/avr/power.h **** 
 672:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRPGA)
 673:/usr/avr/include/avr/power.h **** #define power_pga_enable()              (PRR0 &= (uint8_t)~(1 << PRPGA))
 674:/usr/avr/include/avr/power.h **** #define power_pga_disable()             (PRR0 |= (uint8_t)(1 << PRPGA))
 675:/usr/avr/include/avr/power.h **** #endif
 676:/usr/avr/include/avr/power.h **** 
 677:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRRXDC)
 678:/usr/avr/include/avr/power.h **** #define power_receive_dsp_control_enable()  (PRR0 &= (uint8_t)~(1 << PRRXDC))
 679:/usr/avr/include/avr/power.h **** #define power_receive_dsp_control_disable() (PRR0 |= (uint8_t)(1 << PRRXDC))
 680:/usr/avr/include/avr/power.h **** #endif
 681:/usr/avr/include/avr/power.h **** 
 682:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRSPI)
 683:/usr/avr/include/avr/power.h **** #define power_spi_enable()              (PRR0 &= (uint8_t)~(1 << PRSPI))
 684:/usr/avr/include/avr/power.h **** #define power_spi_disable()             (PRR0 |= (uint8_t)(1 << PRSPI))
 685:/usr/avr/include/avr/power.h **** #endif
 686:/usr/avr/include/avr/power.h **** 
 687:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT0)
 688:/usr/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRT0))
 689:/usr/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRT0))
 690:/usr/avr/include/avr/power.h **** #endif
 691:/usr/avr/include/avr/power.h **** 
 692:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM0)
 693:/usr/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM0))
 694:/usr/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRTIM0))
 695:/usr/avr/include/avr/power.h **** #endif
 696:/usr/avr/include/avr/power.h **** 
 697:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT1)
 698:/usr/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRT1))
 699:/usr/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRT1))
 700:/usr/avr/include/avr/power.h **** #endif
 701:/usr/avr/include/avr/power.h **** 
 702:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM1)
 703:/usr/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM1))
 704:/usr/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRTIM1))
 705:/usr/avr/include/avr/power.h **** #endif
 706:/usr/avr/include/avr/power.h **** 
 707:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT2)
 708:/usr/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRT2))
 709:/usr/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRT2))
 710:/usr/avr/include/avr/power.h **** #endif
 711:/usr/avr/include/avr/power.h **** 
 712:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM2)
 713:/usr/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM2))
 714:/usr/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRTIM2))
 715:/usr/avr/include/avr/power.h **** #endif
 716:/usr/avr/include/avr/power.h **** 
 717:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT3)
 718:/usr/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR0 &= (uint8_t)~(1 << PRT3))
 719:/usr/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR0 |= (uint8_t)(1 << PRT3))
 720:/usr/avr/include/avr/power.h **** #endif
 721:/usr/avr/include/avr/power.h **** 
 722:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTM)
 723:/usr/avr/include/avr/power.h **** #define power_timermodulator_enable()   (PRR0 &= (uint8_t)~(1 << PRTM))
 724:/usr/avr/include/avr/power.h **** #define power_timermodulator_disable()  (PRR0 |= (uint8_t)(1 << PRTM))
 725:/usr/avr/include/avr/power.h **** #endif
 726:/usr/avr/include/avr/power.h **** 
 727:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI)
 728:/usr/avr/include/avr/power.h **** #define power_twi_enable()              (PRR0 &= (uint8_t)~(1 << PRTWI))
 729:/usr/avr/include/avr/power.h **** #define power_twi_disable()             (PRR0 |= (uint8_t)(1 << PRTWI))
 730:/usr/avr/include/avr/power.h **** #endif
 731:/usr/avr/include/avr/power.h **** 
 732:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTXDC)
 733:/usr/avr/include/avr/power.h **** #define power_transmit_dsp_control_enable()   (PRR0 &= (uint8_t)~(1 << PRTXDC))
 734:/usr/avr/include/avr/power.h **** #define power_transmit_dsp_control_disable()  (PRR0 |= (uint8_t)(1 << PRTXDC))
 735:/usr/avr/include/avr/power.h **** #endif
 736:/usr/avr/include/avr/power.h **** 
 737:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART0)
 738:/usr/avr/include/avr/power.h **** #define power_usart0_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART0))
 739:/usr/avr/include/avr/power.h **** #define power_usart0_disable()          (PRR0 |= (uint8_t)(1 << PRUSART0))
 740:/usr/avr/include/avr/power.h **** #endif
 741:/usr/avr/include/avr/power.h **** 
 742:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART1)
 743:/usr/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART1))
 744:/usr/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR0 |= (uint8_t)(1 << PRUSART1))
 745:/usr/avr/include/avr/power.h **** #endif
 746:/usr/avr/include/avr/power.h **** 
 747:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVADC)
 748:/usr/avr/include/avr/power.h **** #define power_vadc_enable()             (PRR0 &= (uint8_t)~(1 << PRVADC))
 749:/usr/avr/include/avr/power.h **** #define power_vadc_disable()            (PRR0 |= (uint8_t)(1 << PRVADC))
 750:/usr/avr/include/avr/power.h **** #endif
 751:/usr/avr/include/avr/power.h **** 
 752:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVM)
 753:/usr/avr/include/avr/power.h **** #define power_voltage_monitor_enable()  (PRR0 &= (uint8_t)~(1 << PRVM))
 754:/usr/avr/include/avr/power.h **** #define power_voltage_monitor_disable() (PRR0 |= (uint8_t)(1 << PRVM))
 755:/usr/avr/include/avr/power.h **** #endif
 756:/usr/avr/include/avr/power.h **** 
 757:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVRM)
 758:/usr/avr/include/avr/power.h **** #define power_vrm_enable()              (PRR0 &= (uint8_t)~(1 << PRVRM))
 759:/usr/avr/include/avr/power.h **** #define power_vrm_disable()             (PRR0 |= (uint8_t)(1 << PRVRM))
 760:/usr/avr/include/avr/power.h **** #endif
 761:/usr/avr/include/avr/power.h **** 
 762:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRAES)
 763:/usr/avr/include/avr/power.h **** #define power_aes_enable()              (PRR1 &= (uint8_t)~(1 << PRAES))
 764:/usr/avr/include/avr/power.h **** #define power_aes_disable()             (PRR1 |= (uint8_t)(1 << PRAES))
 765:/usr/avr/include/avr/power.h **** #endif
 766:/usr/avr/include/avr/power.h **** 
 767:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRCI)
 768:/usr/avr/include/avr/power.h **** #define power_cinterface_enable()       (PRR1 &= (uint8_t)~(1 << PRCI))
 769:/usr/avr/include/avr/power.h **** #define power_cinterface_disable()      (PRR1 |= (uint8_t)(1 << PRCI))
 770:/usr/avr/include/avr/power.h **** #endif
 771:/usr/avr/include/avr/power.h **** 
 772:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRHSSPI)
 773:/usr/avr/include/avr/power.h **** #define power_hsspi_enable()            (PRR1 &= (uint8_t)~(1 << PRHSSPI))
 774:/usr/avr/include/avr/power.h **** #define power_hsspi_disable()           (PRR1 |= (uint8_t)(1 << PRHSSPI))
 775:/usr/avr/include/avr/power.h **** #endif
 776:/usr/avr/include/avr/power.h **** 
 777:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRKB)
 778:/usr/avr/include/avr/power.h **** #define power_kb_enable()               (PRR1 &= (uint8_t)~(1 << PRKB))
 779:/usr/avr/include/avr/power.h **** #define power_kb_disable()              (PRR1 |= (uint8_t)(1 << PRKB))
 780:/usr/avr/include/avr/power.h **** #endif
 781:/usr/avr/include/avr/power.h **** 
 782:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFR)
 783:/usr/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR1 &= (uint8_t)~(1 << PRLFR))            
 784:/usr/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR1 |= (uint8_t)(1 << PRLFR))            
 785:/usr/avr/include/avr/power.h **** #endif
 786:/usr/avr/include/avr/power.h **** 
 787:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSCI)
 788:/usr/avr/include/avr/power.h **** #define power_sci_enable()              (PRR1 &= (uint8_t)~(1 << PRSCI))
 789:/usr/avr/include/avr/power.h **** #define power_sci_disable()             (PRR1 |= (uint8_t)(1 << PRSCI))
 790:/usr/avr/include/avr/power.h **** #endif
 791:/usr/avr/include/avr/power.h **** 
 792:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT1)
 793:/usr/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR1 &= (uint8_t)~(1 << PRT1))
 794:/usr/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR1 |= (uint8_t)(1 << PRT1))
 795:/usr/avr/include/avr/power.h **** #endif
 796:/usr/avr/include/avr/power.h **** 
 797:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT2)
 798:/usr/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR1 &= (uint8_t)~(1 << PRT2))
 799:/usr/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR1 |= (uint8_t)(1 << PRT2))
 800:/usr/avr/include/avr/power.h **** #endif
 801:/usr/avr/include/avr/power.h **** 
 802:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT3)
 803:/usr/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRT3))
 804:/usr/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRT3))
 805:/usr/avr/include/avr/power.h **** #endif
 806:/usr/avr/include/avr/power.h **** 
 807:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT4)
 808:/usr/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRT4))
 809:/usr/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRT4))
 810:/usr/avr/include/avr/power.h **** #endif
 811:/usr/avr/include/avr/power.h **** 
 812:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT5)
 813:/usr/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRT5))
 814:/usr/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRT5))
 815:/usr/avr/include/avr/power.h **** #endif
 816:/usr/avr/include/avr/power.h **** 
 817:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM3)
 818:/usr/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM3))
 819:/usr/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRTIM3))
 820:/usr/avr/include/avr/power.h **** #endif
 821:/usr/avr/include/avr/power.h **** 
 822:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM4)
 823:/usr/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM4))
 824:/usr/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRTIM4))
 825:/usr/avr/include/avr/power.h **** #endif
 826:/usr/avr/include/avr/power.h **** 
 827:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM5)
 828:/usr/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM5))
 829:/usr/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRTIM5))
 830:/usr/avr/include/avr/power.h **** #endif
 831:/usr/avr/include/avr/power.h **** 
 832:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTRX24)
 833:/usr/avr/include/avr/power.h **** #define power_transceiver_enable()      (PRR1 &= (uint8_t)~(1 << PRTRX24))
 834:/usr/avr/include/avr/power.h **** #define power_transceiver_disable()     (PRR1 |= (uint8_t)(1 << PRTRX24))
 835:/usr/avr/include/avr/power.h **** #endif
 836:/usr/avr/include/avr/power.h **** 
 837:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART1)
 838:/usr/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART1))
 839:/usr/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR1 |= (uint8_t)(1 << PRUSART1))
 840:/usr/avr/include/avr/power.h **** #endif
 841:/usr/avr/include/avr/power.h **** 
 842:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART2)
 843:/usr/avr/include/avr/power.h **** #define power_usart2_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART2))
 844:/usr/avr/include/avr/power.h **** #define power_usart2_disable()          (PRR1 |= (uint8_t)(1 << PRUSART2))
 845:/usr/avr/include/avr/power.h **** #endif
 846:/usr/avr/include/avr/power.h **** 
 847:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSB)
 848:/usr/avr/include/avr/power.h **** #define power_usb_enable()              (PRR1 &= (uint8_t)~(1 << PRUSB))
 849:/usr/avr/include/avr/power.h **** #define power_usb_disable()             (PRR1 |= (uint8_t)(1 << PRUSB))
 850:/usr/avr/include/avr/power.h **** #endif
 851:/usr/avr/include/avr/power.h **** 
 852:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSBH)
 853:/usr/avr/include/avr/power.h **** #define power_usbh_enable()             (PRR1 &= (uint8_t)~(1 << PRUSBH))
 854:/usr/avr/include/avr/power.h **** #define power_usbh_disable()            (PRR1 |= (uint8_t)(1 << PRUSBH))
 855:/usr/avr/include/avr/power.h **** #endif
 856:/usr/avr/include/avr/power.h **** 
 857:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRDF)
 858:/usr/avr/include/avr/power.h **** #define power_data_fifo_enable()        (PRR2 &= (uint8_t)~(1 << PRDF))
 859:/usr/avr/include/avr/power.h **** #define power_data_fifo_disable()       (PRR2 |= (uint8_t)(1 << PRDF))
 860:/usr/avr/include/avr/power.h **** #endif
 861:/usr/avr/include/avr/power.h **** 
 862:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRIDS)
 863:/usr/avr/include/avr/power.h **** #define power_id_scan_enable()          (PRR2 &= (uint8_t)~(1 << PRIDS))
 864:/usr/avr/include/avr/power.h **** #define power_id_scan_disable()         (PRR2 |= (uint8_t)(1 << PRIDS))
 865:/usr/avr/include/avr/power.h **** #endif
 866:/usr/avr/include/avr/power.h **** 
 867:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM0)
 868:/usr/avr/include/avr/power.h **** #define power_ram0_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM0))
 869:/usr/avr/include/avr/power.h **** #define power_ram0_disable()            (PRR2 |= (uint8_t)(1 << PRRAM0))
 870:/usr/avr/include/avr/power.h **** #endif
 871:/usr/avr/include/avr/power.h **** 
 872:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM1)
 873:/usr/avr/include/avr/power.h **** #define power_ram1_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM1))
 874:/usr/avr/include/avr/power.h **** #define power_ram1_disable()            (PRR2 |= (uint8_t)(1 << PRRAM1))
 875:/usr/avr/include/avr/power.h **** #endif
 876:/usr/avr/include/avr/power.h **** 
 877:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM2)
 878:/usr/avr/include/avr/power.h **** #define power_ram2_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM2))
 879:/usr/avr/include/avr/power.h **** #define power_ram2_disable()            (PRR2 |= (uint8_t)(1 << PRRAM2))
 880:/usr/avr/include/avr/power.h **** #endif
 881:/usr/avr/include/avr/power.h **** 
 882:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM3)
 883:/usr/avr/include/avr/power.h **** #define power_ram3_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM3))
 884:/usr/avr/include/avr/power.h **** #define power_ram3_disable()            (PRR2 |= (uint8_t)(1 << PRRAM3))
 885:/usr/avr/include/avr/power.h **** #endif
 886:/usr/avr/include/avr/power.h **** 
 887:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRS)
 888:/usr/avr/include/avr/power.h **** #define power_rssi_buffer_enable()      (PRR2 &= (uint8_t)~(1 << PRRS))
 889:/usr/avr/include/avr/power.h **** #define power_rssi_buffer_disable()     (PRR2 |= (uint8_t)(1 << PRRS))
 890:/usr/avr/include/avr/power.h **** #endif
 891:/usr/avr/include/avr/power.h **** 
 892:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSF)
 893:/usr/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_enable()       (PRR2 &= (uint8_t)~(1 << PRSF))
 894:/usr/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_disable()      (PRR2 |= (uint8_t)(1 << PRSF))
 895:/usr/avr/include/avr/power.h **** #endif
 896:/usr/avr/include/avr/power.h **** 
 897:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSSM)
 898:/usr/avr/include/avr/power.h **** #define power_sequencer_state_machine_enable()  (PRR2 &= (uint8_t)~(1 << PRSSM))
 899:/usr/avr/include/avr/power.h **** #define power_sequencer_state_machine_disable() (PRR2 |= (uint8_t)(1 << PRSSM))
 900:/usr/avr/include/avr/power.h **** #endif
 901:/usr/avr/include/avr/power.h **** 
 902:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTM)
 903:/usr/avr/include/avr/power.h **** #define power_tx_modulator_enable()     (PRR2 &= (uint8_t)~(1 << PRTM))
 904:/usr/avr/include/avr/power.h **** #define power_tx_modulator_disable()    (PRR2 |= (uint8_t)(1 << PRTM))
 905:/usr/avr/include/avr/power.h **** #endif
 906:/usr/avr/include/avr/power.h **** 
 907:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXA)
 908:/usr/avr/include/avr/power.h **** #define power_rx_buffer_A_enable()      (PRR2 &= (uint8_t)~(1 << PRXA))
 909:/usr/avr/include/avr/power.h **** #define power_rx_buffer_A_disable()     (PRR2 |= (uint8_t)(1 << PRXA))
 910:/usr/avr/include/avr/power.h **** #endif
 911:/usr/avr/include/avr/power.h **** 
 912:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXB)
 913:/usr/avr/include/avr/power.h **** #define power_rx_buffer_B_enable()      (PRR2 &= (uint8_t)~(1 << PRXB))
 914:/usr/avr/include/avr/power.h **** #define power_rx_buffer_B_disable()     (PRR2 |= (uint8_t)(1 << PRXB))
 915:/usr/avr/include/avr/power.h **** #endif
 916:/usr/avr/include/avr/power.h **** 
 917:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_AES)
 918:/usr/avr/include/avr/power.h **** #define power_aes_enable()              (PR_PRGEN &= (uint8_t)~(PR_AES_bm))
 919:/usr/avr/include/avr/power.h **** #define power_aes_disable()             (PR_PRGEN |= (uint8_t)PR_AES_bm)
 920:/usr/avr/include/avr/power.h **** #endif
 921:/usr/avr/include/avr/power.h **** 
 922:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_DMA)
 923:/usr/avr/include/avr/power.h **** #define power_dma_enable()              (PR_PRGEN &= (uint8_t)~(PR_DMA_bm))
 924:/usr/avr/include/avr/power.h **** #define power_dma_disable()             (PR_PRGEN |= (uint8_t)PR_DMA_bm)
 925:/usr/avr/include/avr/power.h **** #endif
 926:/usr/avr/include/avr/power.h **** 
 927:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EBI)
 928:/usr/avr/include/avr/power.h **** #define power_ebi_enable()              (PR_PRGEN &= (uint8_t)~(PR_EBI_bm))
 929:/usr/avr/include/avr/power.h **** #define power_ebi_disable()             (PR_PRGEN |= (uint8_t)PR_EBI_bm)
 930:/usr/avr/include/avr/power.h **** #endif
 931:/usr/avr/include/avr/power.h **** 
 932:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EDMA)
 933:/usr/avr/include/avr/power.h **** #define power_edma_enable()             (PR_PRGEN &= (uint8_t)~(PR_EDMA_bm))
 934:/usr/avr/include/avr/power.h **** #define power_edma_disable()            (PR_PRGEN |= (uint8_t)PR_EDMA_bm)
 935:/usr/avr/include/avr/power.h **** #endif
 936:/usr/avr/include/avr/power.h **** 
 937:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EVSYS)
 938:/usr/avr/include/avr/power.h **** #define power_evsys_enable()            (PR_PRGEN &= (uint8_t)~(PR_EVSYS_bm))
 939:/usr/avr/include/avr/power.h **** #define power_evsys_disable()           (PR_PRGEN |= (uint8_t)PR_EVSYS_bm)
 940:/usr/avr/include/avr/power.h **** #endif
 941:/usr/avr/include/avr/power.h **** 
 942:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_LCD)
 943:/usr/avr/include/avr/power.h **** #define power_lcd_enable()              (PR_PRGEN &= (uint8_t)~(PR_LCD_bm))
 944:/usr/avr/include/avr/power.h **** #define power_lcd_disable()             (PR_PRGEN |= (uint8_t)PR_LCD_bm)
 945:/usr/avr/include/avr/power.h **** #endif
 946:/usr/avr/include/avr/power.h **** 
 947:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_RTC)
 948:/usr/avr/include/avr/power.h **** #define power_rtc_enable()              (PR_PRGEN &= (uint8_t)~(PR_RTC_bm))
 949:/usr/avr/include/avr/power.h **** #define power_rtc_disable()             (PR_PRGEN |= (uint8_t)PR_RTC_bm)
 950:/usr/avr/include/avr/power.h **** #endif
 951:/usr/avr/include/avr/power.h **** 
 952:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_USB)
 953:/usr/avr/include/avr/power.h **** #define power_usb_enable()              (PR_PRGEN &= (uint8_t)~(PR_USB_bm))
 954:/usr/avr/include/avr/power.h **** #define power_usb_disable()             (PR_PRGEN &= (uint8_t)(PR_USB_bm))
 955:/usr/avr/include/avr/power.h **** #endif
 956:/usr/avr/include/avr/power.h **** 
 957:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_XCL)
 958:/usr/avr/include/avr/power.h **** #define power_xcl_enable()              (PR_PRGEN &= (uint8_t)~(PR_XCL_bm))
 959:/usr/avr/include/avr/power.h **** #define power_xcl_disable()             (PR_PRGEN |= (uint8_t)PR_XCL_bm)
 960:/usr/avr/include/avr/power.h **** #endif
 961:/usr/avr/include/avr/power.h **** 
 962:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_AC)
 963:/usr/avr/include/avr/power.h **** #define power_aca_enable()      (PR_PRPA &= (uint8_t)~(PR_AC_bm))
 964:/usr/avr/include/avr/power.h **** #define power_aca_disable()     (PR_PRPA |= (uint8_t)PR_AC_bm)
 965:/usr/avr/include/avr/power.h **** #endif
 966:/usr/avr/include/avr/power.h **** 
 967:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_ADC)
 968:/usr/avr/include/avr/power.h **** #define power_adca_enable()     (PR_PRPA &= (uint8_t)~(PR_ADC_bm))
 969:/usr/avr/include/avr/power.h **** #define power_adca_disable()    (PR_PRPA |= (uint8_t)PR_ADC_bm)
 970:/usr/avr/include/avr/power.h **** #endif
 971:/usr/avr/include/avr/power.h **** 
 972:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_DAC)
 973:/usr/avr/include/avr/power.h **** #define power_daca_enable()     (PR_PRPA &= (uint8_t)~(PR_DAC_bm))
 974:/usr/avr/include/avr/power.h **** #define power_daca_disable()    (PR_PRPA |= (uint8_t)PR_DAC_bm)
 975:/usr/avr/include/avr/power.h **** #endif
 976:/usr/avr/include/avr/power.h **** 
 977:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_AC)
 978:/usr/avr/include/avr/power.h **** #define power_acb_enable()      (PR_PRPB &= (uint8_t)~(PR_AC_bm))
 979:/usr/avr/include/avr/power.h **** #define power_acb_disable()     (PR_PRPB |= (uint8_t)PR_AC_bm)
 980:/usr/avr/include/avr/power.h **** #endif
 981:/usr/avr/include/avr/power.h **** 
 982:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_ADC)
 983:/usr/avr/include/avr/power.h **** #define power_adcb_enable()     (PR_PRPB &= (uint8_t)~(PR_ADC_bm))
 984:/usr/avr/include/avr/power.h **** #define power_adcb_disable()    (PR_PRPB |= (uint8_t)PR_ADC_bm)
 985:/usr/avr/include/avr/power.h **** #endif
 986:/usr/avr/include/avr/power.h **** 
 987:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_DAC)
 988:/usr/avr/include/avr/power.h **** #define power_dacb_enable()     (PR_PRPB &= (uint8_t)~(PR_DAC_bm))
 989:/usr/avr/include/avr/power.h **** #define power_dacb_disable()    (PR_PRPB |= (uint8_t)PR_DAC_bm)
 990:/usr/avr/include/avr/power.h **** #endif
 991:/usr/avr/include/avr/power.h **** 
 992:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_HIRES)
 993:/usr/avr/include/avr/power.h **** #define power_hiresc_enable()   (PR_PRPC &= (uint8_t)~(PR_HIRES_bm))
 994:/usr/avr/include/avr/power.h **** #define power_hiresc_disable()  (PR_PRPC |= (uint8_t)PR_HIRES_bm)
 995:/usr/avr/include/avr/power.h **** #endif
 996:/usr/avr/include/avr/power.h **** 
 997:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_SPI)
 998:/usr/avr/include/avr/power.h **** #define power_spic_enable()     (PR_PRPC &= (uint8_t)~(PR_SPI_bm))
 999:/usr/avr/include/avr/power.h **** #define power_spic_disable()    (PR_PRPC |= (uint8_t)PR_SPI_bm)
1000:/usr/avr/include/avr/power.h **** #endif
1001:/usr/avr/include/avr/power.h **** 
1002:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC0)
1003:/usr/avr/include/avr/power.h **** #define power_tc0c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC0_bm))
1004:/usr/avr/include/avr/power.h **** #define power_tc0c_disable()    (PR_PRPC |= (uint8_t)PR_TC0_bm)
1005:/usr/avr/include/avr/power.h **** #endif
1006:/usr/avr/include/avr/power.h **** 
1007:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC1)
1008:/usr/avr/include/avr/power.h **** #define power_tc1c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC1_bm))
1009:/usr/avr/include/avr/power.h **** #define power_tc1c_disable()    (PR_PRPC |= (uint8_t)PR_TC1_bm)
1010:/usr/avr/include/avr/power.h **** #endif
1011:/usr/avr/include/avr/power.h **** 
1012:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC4)
1013:/usr/avr/include/avr/power.h **** #define power_tc4c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC4_bm))
1014:/usr/avr/include/avr/power.h **** #define power_tc4c_disable()    (PR_PRPC  |= (uint8_t)PR_TC4_bm)
1015:/usr/avr/include/avr/power.h **** #endif
1016:/usr/avr/include/avr/power.h **** 
1017:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC5)
1018:/usr/avr/include/avr/power.h **** #define power_tc5c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC5_bm))
1019:/usr/avr/include/avr/power.h **** #define power_tc5c_disable()    (PR_PRPC  |= (uint8_t)PR_TC5_bm)
1020:/usr/avr/include/avr/power.h **** #endif
1021:/usr/avr/include/avr/power.h **** 
1022:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TWI)
1023:/usr/avr/include/avr/power.h **** #define power_twic_enable()     (PR_PRPC &= (uint8_t)~(PR_TWI_bm))
1024:/usr/avr/include/avr/power.h **** #define power_twic_disable()    (PR_PRPC |= (uint8_t)PR_TWI_bm)
1025:/usr/avr/include/avr/power.h **** #endif
1026:/usr/avr/include/avr/power.h **** 
1027:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART0)
1028:/usr/avr/include/avr/power.h **** #define power_usartc0_enable()  (PR_PRPC &= (uint8_t)~(PR_USART0_bm))
1029:/usr/avr/include/avr/power.h **** #define power_usartc0_disable() (PR_PRPC |= (uint8_t)PR_USART0_bm)
1030:/usr/avr/include/avr/power.h **** #endif
1031:/usr/avr/include/avr/power.h **** 
1032:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART1)
1033:/usr/avr/include/avr/power.h **** #define power_usartc1_enable()  (PR_PRPC &= (uint8_t)~(PR_USART1_bm))
1034:/usr/avr/include/avr/power.h **** #define power_usartc1_disable() (PR_PRPC |= (uint8_t)PR_USART1_bm)
1035:/usr/avr/include/avr/power.h **** #endif
1036:/usr/avr/include/avr/power.h **** 
1037:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_HIRES)
1038:/usr/avr/include/avr/power.h **** #define power_hiresd_enable()   (PR_PRPD &= (uint8_t)~(PR_HIRES_bm))
1039:/usr/avr/include/avr/power.h **** #define power_hiresd_disable()  (PR_PRPD |= (uint8_t)PR_HIRES_bm)
1040:/usr/avr/include/avr/power.h **** #endif
1041:/usr/avr/include/avr/power.h **** 
1042:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_SPI)
1043:/usr/avr/include/avr/power.h **** #define power_spid_enable()     (PR_PRPD &= (uint8_t)~(PR_SPI_bm))
1044:/usr/avr/include/avr/power.h **** #define power_spid_disable()    (PR_PRPD |= (uint8_t)PR_SPI_bm)
1045:/usr/avr/include/avr/power.h **** #endif
1046:/usr/avr/include/avr/power.h **** 
1047:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC0)
1048:/usr/avr/include/avr/power.h **** #define power_tc0d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC0_bm))
1049:/usr/avr/include/avr/power.h **** #define power_tc0d_disable()    (PR_PRPD |= (uint8_t)PR_TC0_bm)
1050:/usr/avr/include/avr/power.h **** #endif
1051:/usr/avr/include/avr/power.h **** 
1052:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC1)
1053:/usr/avr/include/avr/power.h **** #define power_tc1d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC1_bm))
1054:/usr/avr/include/avr/power.h **** #define power_tc1d_disable()    (PR_PRPD |= (uint8_t)PR_TC1_bm)
1055:/usr/avr/include/avr/power.h **** #endif
1056:/usr/avr/include/avr/power.h **** 
1057:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC5)
1058:/usr/avr/include/avr/power.h **** #define power_tc5d_enable()     (PR_PRPD  &= (uint8_t)~(PR_TC5_bm))
1059:/usr/avr/include/avr/power.h **** #define power_tc5d_disable()    (PR_PRPD  |= (uint8_t)PR_TC5_bm)
1060:/usr/avr/include/avr/power.h **** #endif
1061:/usr/avr/include/avr/power.h **** 
1062:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TWI)
1063:/usr/avr/include/avr/power.h **** #define power_twid_enable()     (PR_PRPD &= (uint8_t)~(PR_TWI_bm))
1064:/usr/avr/include/avr/power.h **** #define power_twid_disable()    (PR_PRPD |= (uint8_t)PR_TWI_bm)
1065:/usr/avr/include/avr/power.h **** #endif
1066:/usr/avr/include/avr/power.h **** 
1067:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART0)
1068:/usr/avr/include/avr/power.h **** #define power_usartd0_enable()  (PR_PRPD &= (uint8_t)~(PR_USART0_bm))
1069:/usr/avr/include/avr/power.h **** #define power_usartd0_disable() (PR_PRPD |= (uint8_t)PR_USART0_bm)
1070:/usr/avr/include/avr/power.h **** #endif
1071:/usr/avr/include/avr/power.h **** 
1072:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART1)
1073:/usr/avr/include/avr/power.h **** #define power_usartd1_enable()  (PR_PRPD &= (uint8_t)~(PR_USART1_bm))
1074:/usr/avr/include/avr/power.h **** #define power_usartd1_disable() (PR_PRPD |= (uint8_t)PR_USART1_bm)
1075:/usr/avr/include/avr/power.h **** #endif
1076:/usr/avr/include/avr/power.h **** 
1077:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_HIRES)
1078:/usr/avr/include/avr/power.h **** #define power_hirese_enable()   (PR_PRPE &= (uint8_t)~(PR_HIRES_bm))
1079:/usr/avr/include/avr/power.h **** #define power_hirese_disable()  (PR_PRPE |= (uint8_t)PR_HIRES_bm)
1080:/usr/avr/include/avr/power.h **** #endif
1081:/usr/avr/include/avr/power.h **** 
1082:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_SPI)
1083:/usr/avr/include/avr/power.h **** #define power_spie_enable()     (PR_PRPE &= (uint8_t)~(PR_SPI_bm))
1084:/usr/avr/include/avr/power.h **** #define power_spie_disable()    (PR_PRPE |= (uint8_t)PR_SPI_bm)
1085:/usr/avr/include/avr/power.h **** #endif
1086:/usr/avr/include/avr/power.h **** 
1087:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC0)
1088:/usr/avr/include/avr/power.h **** #define power_tc0e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC0_bm))
1089:/usr/avr/include/avr/power.h **** #define power_tc0e_disable()    (PR_PRPE |= (uint8_t)PR_TC0_bm)
1090:/usr/avr/include/avr/power.h **** #endif
1091:/usr/avr/include/avr/power.h **** 
1092:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC1)
1093:/usr/avr/include/avr/power.h **** #define power_tc1e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC1_bm))
1094:/usr/avr/include/avr/power.h **** #define power_tc1e_disable()    (PR_PRPE |= (uint8_t)PR_TC1_bm)
1095:/usr/avr/include/avr/power.h **** #endif
1096:/usr/avr/include/avr/power.h **** 
1097:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TWI)
1098:/usr/avr/include/avr/power.h **** #define power_twie_enable()     (PR_PRPE &= (uint8_t)~(PR_TWI_bm))
1099:/usr/avr/include/avr/power.h **** #define power_twie_disable()    (PR_PRPE |= (uint8_t)PR_TWI_bm)
1100:/usr/avr/include/avr/power.h **** #endif
1101:/usr/avr/include/avr/power.h **** 
1102:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART0)
1103:/usr/avr/include/avr/power.h **** #define power_usarte0_enable()  (PR_PRPE &= (uint8_t)~(PR_USART0_bm))
1104:/usr/avr/include/avr/power.h **** #define power_usarte0_disable() (PR_PRPE |= (uint8_t)PR_USART0_bm)
1105:/usr/avr/include/avr/power.h **** #endif
1106:/usr/avr/include/avr/power.h **** 
1107:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART1)
1108:/usr/avr/include/avr/power.h **** #define power_usarte1_enable()  (PR_PRPE &= (uint8_t)~(PR_USART1_bm))
1109:/usr/avr/include/avr/power.h **** #define power_usarte1_disable() (PR_PRPE |= (uint8_t)PR_USART1_bm)
1110:/usr/avr/include/avr/power.h **** #endif
1111:/usr/avr/include/avr/power.h **** 
1112:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_HIRES)
1113:/usr/avr/include/avr/power.h **** #define power_hiresf_enable()   (PR_PRPF &= (uint8_t)~(PR_HIRES_bm))
1114:/usr/avr/include/avr/power.h **** #define power_hiresf_disable()  (PR_PRPF |= (uint8_t)PR_HIRES_bm)
1115:/usr/avr/include/avr/power.h **** #endif
1116:/usr/avr/include/avr/power.h **** 
1117:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_SPI)
1118:/usr/avr/include/avr/power.h **** #define power_spif_enable()     (PR_PRPF &= (uint8_t)~(PR_SPI_bm))
1119:/usr/avr/include/avr/power.h **** #define power_spif_disable()    (PR_PRPF |= (uint8_t)PR_SPI_bm)
1120:/usr/avr/include/avr/power.h **** #endif
1121:/usr/avr/include/avr/power.h **** 
1122:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC0)
1123:/usr/avr/include/avr/power.h **** #define power_tc0f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC0_bm))
1124:/usr/avr/include/avr/power.h **** #define power_tc0f_disable()    (PR_PRPF |= (uint8_t)PR_TC0_bm)
1125:/usr/avr/include/avr/power.h **** #endif
1126:/usr/avr/include/avr/power.h **** 
1127:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC1)
1128:/usr/avr/include/avr/power.h **** #define power_tc1f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC1_bm))
1129:/usr/avr/include/avr/power.h **** #define power_tc1f_disable()    (PR_PRPF |= (uint8_t)PR_TC1_bm)
1130:/usr/avr/include/avr/power.h **** #endif
1131:/usr/avr/include/avr/power.h **** 
1132:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TWI)
1133:/usr/avr/include/avr/power.h **** #define power_twif_enable()     (PR_PRPF &= (uint8_t)~(PR_TWI_bm))
1134:/usr/avr/include/avr/power.h **** #define power_twif_disable()    (PR_PRPF |= (uint8_t)PR_TWI_bm)
1135:/usr/avr/include/avr/power.h **** #endif
1136:/usr/avr/include/avr/power.h **** 
1137:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART0)
1138:/usr/avr/include/avr/power.h **** #define power_usartf0_enable()  (PR_PRPF &= (uint8_t)~(PR_USART0_bm))
1139:/usr/avr/include/avr/power.h **** #define power_usartf0_disable() (PR_PRPF |= (uint8_t)PR_USART0_bm)
1140:/usr/avr/include/avr/power.h **** #endif
1141:/usr/avr/include/avr/power.h **** 
1142:/usr/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART1)
1143:/usr/avr/include/avr/power.h **** #define power_usartf1_enable()  (PR_PRPF &= (uint8_t)~(PR_USART1_bm))
1144:/usr/avr/include/avr/power.h **** #define power_usartf1_disable() (PR_PRPF |= (uint8_t)PR_USART1_bm)
1145:/usr/avr/include/avr/power.h **** #endif
1146:/usr/avr/include/avr/power.h **** 
1147:/usr/avr/include/avr/power.h **** static __inline void
1148:/usr/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1149:/usr/avr/include/avr/power.h **** __power_all_enable()
1150:/usr/avr/include/avr/power.h **** {
1151:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1152:/usr/avr/include/avr/power.h ****     PRR &= (uint8_t)~(__AVR_HAVE_PRR);
1153:/usr/avr/include/avr/power.h **** #endif
1154:/usr/avr/include/avr/power.h **** 
1155:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1156:/usr/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~(__AVR_HAVE_PRR0);
1157:/usr/avr/include/avr/power.h **** #endif
1158:/usr/avr/include/avr/power.h **** 
1159:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1160:/usr/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~(__AVR_HAVE_PRR1);
1161:/usr/avr/include/avr/power.h **** #endif
1162:/usr/avr/include/avr/power.h **** 
1163:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1164:/usr/avr/include/avr/power.h ****    PRR2 &= (uint8_t)~(__AVR_HAVE_PRR2);
1165:/usr/avr/include/avr/power.h **** #endif
1166:/usr/avr/include/avr/power.h **** 
1167:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1168:/usr/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(__AVR_HAVE_PRGEN);
1169:/usr/avr/include/avr/power.h **** #endif
1170:/usr/avr/include/avr/power.h **** 
1171:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1172:/usr/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(__AVR_HAVE_PRPA);
1173:/usr/avr/include/avr/power.h **** #endif
1174:/usr/avr/include/avr/power.h **** 
1175:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1176:/usr/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(__AVR_HAVE_PRPB);
1177:/usr/avr/include/avr/power.h **** #endif
1178:/usr/avr/include/avr/power.h **** 
1179:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1180:/usr/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(__AVR_HAVE_PRPC);
1181:/usr/avr/include/avr/power.h **** #endif
1182:/usr/avr/include/avr/power.h **** 
1183:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1184:/usr/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(__AVR_HAVE_PRPD);
1185:/usr/avr/include/avr/power.h **** #endif
1186:/usr/avr/include/avr/power.h **** 
1187:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1188:/usr/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(__AVR_HAVE_PRPE);
1189:/usr/avr/include/avr/power.h **** #endif
1190:/usr/avr/include/avr/power.h **** 
1191:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1192:/usr/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(__AVR_HAVE_PRPF);
1193:/usr/avr/include/avr/power.h **** #endif
1194:/usr/avr/include/avr/power.h **** }
1195:/usr/avr/include/avr/power.h **** 
1196:/usr/avr/include/avr/power.h **** static __inline void
1197:/usr/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1198:/usr/avr/include/avr/power.h **** __power_all_disable()
1199:/usr/avr/include/avr/power.h **** {
1200:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1201:/usr/avr/include/avr/power.h ****     PRR |= (uint8_t)(__AVR_HAVE_PRR);
1202:/usr/avr/include/avr/power.h **** #endif
1203:/usr/avr/include/avr/power.h **** 
1204:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1205:/usr/avr/include/avr/power.h ****     PRR0 |= (uint8_t)(__AVR_HAVE_PRR0);
1206:/usr/avr/include/avr/power.h **** #endif
1207:/usr/avr/include/avr/power.h **** 
1208:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1209:/usr/avr/include/avr/power.h ****     PRR1 |= (uint8_t)(__AVR_HAVE_PRR1);
1210:/usr/avr/include/avr/power.h **** #endif
1211:/usr/avr/include/avr/power.h **** 
1212:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1213:/usr/avr/include/avr/power.h ****     PRR2 |= (uint8_t)(__AVR_HAVE_PRR2);
1214:/usr/avr/include/avr/power.h **** #endif
1215:/usr/avr/include/avr/power.h **** 
1216:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1217:/usr/avr/include/avr/power.h ****     PR_PRGEN |= (uint8_t)(__AVR_HAVE_PRGEN);
1218:/usr/avr/include/avr/power.h **** #endif
1219:/usr/avr/include/avr/power.h **** 
1220:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1221:/usr/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(__AVR_HAVE_PRPA);
1222:/usr/avr/include/avr/power.h **** #endif
1223:/usr/avr/include/avr/power.h **** 
1224:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1225:/usr/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(__AVR_HAVE_PRPB);
1226:/usr/avr/include/avr/power.h **** #endif
1227:/usr/avr/include/avr/power.h **** 
1228:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1229:/usr/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(__AVR_HAVE_PRPC);
1230:/usr/avr/include/avr/power.h **** #endif
1231:/usr/avr/include/avr/power.h **** 
1232:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1233:/usr/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(__AVR_HAVE_PRPD);
1234:/usr/avr/include/avr/power.h **** #endif
1235:/usr/avr/include/avr/power.h **** 
1236:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1237:/usr/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(__AVR_HAVE_PRPE);
1238:/usr/avr/include/avr/power.h **** #endif
1239:/usr/avr/include/avr/power.h **** 
1240:/usr/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1241:/usr/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(__AVR_HAVE_PRPF);
1242:/usr/avr/include/avr/power.h **** #endif
1243:/usr/avr/include/avr/power.h **** }
1244:/usr/avr/include/avr/power.h **** 
1245:/usr/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1246:/usr/avr/include/avr/power.h **** #ifndef power_all_enable
1247:/usr/avr/include/avr/power.h **** #define power_all_enable() __power_all_enable()
1248:/usr/avr/include/avr/power.h **** #endif
1249:/usr/avr/include/avr/power.h **** 
1250:/usr/avr/include/avr/power.h **** #ifndef power_all_disable
1251:/usr/avr/include/avr/power.h **** #define power_all_disable() __power_all_disable()
1252:/usr/avr/include/avr/power.h **** #endif
1253:/usr/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1254:/usr/avr/include/avr/power.h **** 
1255:/usr/avr/include/avr/power.h **** 
1256:/usr/avr/include/avr/power.h **** #if defined(__AVR_AT90CAN32__) \
1257:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90CAN64__) \
1258:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90CAN128__) \
1259:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM1__) \
1260:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2__) \
1261:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
1262:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
1263:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
1264:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM81__) \
1265:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM161__) \
1266:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
1267:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__) \
1268:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90SCR100__) \
1269:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90USB646__) \
1270:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
1271:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90USB82__) \
1272:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
1273:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__) \
1274:/usr/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1275:/usr/avr/include/avr/power.h **** || defined(__AVR_ATA5505__) \
1276:/usr/avr/include/avr/power.h **** || defined(__AVR_ATA5272__) \
1277:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
1278:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
1279:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega1284__) \
1280:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFA1__) \
1281:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1282:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1283:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega1284P__) \
1284:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega162__) \
1285:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega164A__) \
1286:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
1287:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega164PA__) \
1288:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega165__) \
1289:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
1290:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
1291:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega165PA__) \
1292:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1293:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1294:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega168PA__) \
1295:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega169__) \
1296:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
1297:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
1298:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
1299:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__) \
1300:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
1301:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) \
1302:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1303:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1304:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
1305:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
1306:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
1307:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
1308:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega325PA__) \
1309:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
1310:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
1311:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega3250PA__) \
1312:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1313:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1314:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
1315:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
1316:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
1317:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
1318:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
1319:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
1320:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega3290PA__) \
1321:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1322:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1323:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1324:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega32U4__) \
1325:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega32U6__) \
1326:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega48__) \
1327:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega48A__) \
1328:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega48PA__) \
1329:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1330:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega640__) \
1331:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
1332:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega644__) \
1333:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
1334:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
1335:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__) \
1336:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
1337:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
1338:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
1339:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
1340:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
1341:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__) \
1342:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
1343:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
1344:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
1345:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
1346:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__) \
1347:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1348:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__) \
1349:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1350:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1351:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1352:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1353:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1354:/usr/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1355:/usr/avr/include/avr/power.h **** || defined(__AVR_ATtiny167__) \
1356:/usr/avr/include/avr/power.h **** || defined(__DOXYGEN__)
1357:/usr/avr/include/avr/power.h **** 
1358:/usr/avr/include/avr/power.h **** 
1359:/usr/avr/include/avr/power.h **** /** \addtogroup avr_power
1360:/usr/avr/include/avr/power.h **** 
1361:/usr/avr/include/avr/power.h **** Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
1362:/usr/avr/include/avr/power.h **** allows you to decrease the system clock frequency and the power consumption
1363:/usr/avr/include/avr/power.h **** when the need for processing power is low.
1364:/usr/avr/include/avr/power.h **** On some earlier AVRs (ATmega103, ATmega64, ATmega128), similar
1365:/usr/avr/include/avr/power.h **** functionality can be achieved through the XTAL Divide Control Register.
1366:/usr/avr/include/avr/power.h **** Below are two macros and an enumerated type that can be used to
1367:/usr/avr/include/avr/power.h **** interface to the Clock Prescale Register or
1368:/usr/avr/include/avr/power.h **** XTAL Divide Control Register.
1369:/usr/avr/include/avr/power.h **** 
1370:/usr/avr/include/avr/power.h **** \note Not all AVR devices have a clock prescaler. On those devices
1371:/usr/avr/include/avr/power.h **** without a Clock Prescale Register or XTAL Divide Control Register, these
1372:/usr/avr/include/avr/power.h **** macros are not available.
1373:/usr/avr/include/avr/power.h **** */
1374:/usr/avr/include/avr/power.h **** 
1375:/usr/avr/include/avr/power.h **** 
1376:/usr/avr/include/avr/power.h **** /** \addtogroup avr_power
1377:/usr/avr/include/avr/power.h **** \code 
1378:/usr/avr/include/avr/power.h **** typedef enum
1379:/usr/avr/include/avr/power.h **** {
1380:/usr/avr/include/avr/power.h ****     clock_div_1 = 0,
1381:/usr/avr/include/avr/power.h ****     clock_div_2 = 1,
1382:/usr/avr/include/avr/power.h ****     clock_div_4 = 2,
1383:/usr/avr/include/avr/power.h ****     clock_div_8 = 3,
1384:/usr/avr/include/avr/power.h ****     clock_div_16 = 4,
1385:/usr/avr/include/avr/power.h ****     clock_div_32 = 5,
1386:/usr/avr/include/avr/power.h ****     clock_div_64 = 6,
1387:/usr/avr/include/avr/power.h ****     clock_div_128 = 7,
1388:/usr/avr/include/avr/power.h ****     clock_div_256 = 8,
1389:/usr/avr/include/avr/power.h ****     clock_div_1_rc = 15, // ATmega128RFA1 only
1390:/usr/avr/include/avr/power.h **** } clock_div_t;
1391:/usr/avr/include/avr/power.h **** \endcode
1392:/usr/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1393:/usr/avr/include/avr/power.h **** System Clock Prescale Register.
1394:/usr/avr/include/avr/power.h **** 
1395:/usr/avr/include/avr/power.h **** \code
1396:/usr/avr/include/avr/power.h **** typedef enum
1397:/usr/avr/include/avr/power.h **** {
1398:/usr/avr/include/avr/power.h ****     clock_div_1 = 1,
1399:/usr/avr/include/avr/power.h ****     clock_div_2 = 2,
1400:/usr/avr/include/avr/power.h ****     clock_div_4 = 4,
1401:/usr/avr/include/avr/power.h ****     clock_div_8 = 8,
1402:/usr/avr/include/avr/power.h ****     clock_div_16 = 16,
1403:/usr/avr/include/avr/power.h ****     clock_div_32 = 32,
1404:/usr/avr/include/avr/power.h ****     clock_div_64 = 64,
1405:/usr/avr/include/avr/power.h ****     clock_div_128 = 128
1406:/usr/avr/include/avr/power.h **** } clock_div_t;
1407:/usr/avr/include/avr/power.h **** \endcode
1408:/usr/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1409:/usr/avr/include/avr/power.h **** XTAL Divide Control Register.
1410:/usr/avr/include/avr/power.h **** 
1411:/usr/avr/include/avr/power.h **** */
1412:/usr/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1413:/usr/avr/include/avr/power.h **** typedef enum
1414:/usr/avr/include/avr/power.h **** {
1415:/usr/avr/include/avr/power.h ****     clock_div_1 = 0,
1416:/usr/avr/include/avr/power.h ****     clock_div_2 = 1,
1417:/usr/avr/include/avr/power.h ****     clock_div_4 = 2,
1418:/usr/avr/include/avr/power.h ****     clock_div_8 = 3,
1419:/usr/avr/include/avr/power.h ****     clock_div_16 = 4,
1420:/usr/avr/include/avr/power.h ****     clock_div_32 = 5,
1421:/usr/avr/include/avr/power.h ****     clock_div_64 = 6,
1422:/usr/avr/include/avr/power.h ****     clock_div_128 = 7,
1423:/usr/avr/include/avr/power.h ****     clock_div_256 = 8
1424:/usr/avr/include/avr/power.h **** #if defined(__AVR_ATmega128RFA1__) \
1425:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1426:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1427:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1428:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1429:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1430:/usr/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__)
1431:/usr/avr/include/avr/power.h ****     , clock_div_1_rc = 15
1432:/usr/avr/include/avr/power.h **** #endif
1433:/usr/avr/include/avr/power.h **** } clock_div_t;
1434:/usr/avr/include/avr/power.h **** 
1435:/usr/avr/include/avr/power.h **** static __inline__ void clock_prescale_set(clock_div_t) __attribute__((__always_inline__));
1436:/usr/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1437:/usr/avr/include/avr/power.h **** 
1438:/usr/avr/include/avr/power.h **** /**
1439:/usr/avr/include/avr/power.h ****    \ingroup avr_power
1440:/usr/avr/include/avr/power.h ****    \fn clock_prescale_set(clock_div_t x)
1441:/usr/avr/include/avr/power.h **** 
1442:/usr/avr/include/avr/power.h **** Set the clock prescaler register select bits, selecting a system clock
1443:/usr/avr/include/avr/power.h **** division setting. This function is inlined, even if compiler
1444:/usr/avr/include/avr/power.h **** optimizations are disabled.
1445:/usr/avr/include/avr/power.h **** 
1446:/usr/avr/include/avr/power.h **** The type of \c x is \c clock_div_t.
1447:/usr/avr/include/avr/power.h **** 
1448:/usr/avr/include/avr/power.h **** \note For device with XTAL Divide Control Register (XDIV), \c x can actually range
1449:/usr/avr/include/avr/power.h **** from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
1450:/usr/avr/include/avr/power.h **** */
1451:/usr/avr/include/avr/power.h **** void clock_prescale_set(clock_div_t __x)
 2126               		.loc 5 1451 6 view .LVU685
 2127               	.LBB88:
1452:/usr/avr/include/avr/power.h **** {
1453:/usr/avr/include/avr/power.h ****     uint8_t __tmp = _BV(CLKPCE);
 2128               		.loc 5 1453 5 view .LVU686
1454:/usr/avr/include/avr/power.h ****     __asm__ __volatile__ (
 2129               		.loc 5 1454 5 view .LVU687
 2130 0768 80E8      		ldi r24,lo8(-128)
 2131 076a 90E0      		ldi r25,0
 2132               	/* #APP */
 2133               	 ;  1454 "/usr/avr/include/avr/power.h" 1
 2134 076c 0FB6      		in __tmp_reg__,__SREG__
 2135 076e F894      		cli
 2136 0770 8093 6100 		sts 97, r24
 2137 0774 9093 6100 		sts 97, r25
 2138 0778 0FBE      		out __SREG__, __tmp_reg__
 2139               	 ;  0 "" 2
 2140               	.LVL83:
 2141               		.loc 5 1454 5 is_stmt 0 view .LVU688
 2142               	/* #NOAPP */
 2143               	.LBE88:
 2144               	.LBE87:
 413:main.c        ****    I2C_init(I2C_ADDR);
 2145               		.loc 4 413 4 is_stmt 1 view .LVU689
 2146 077a 8AE2      		ldi r24,lo8(42)
 2147 077c 0E94 0000 		call I2C_init
 2148               	.LVL84:
 414:main.c        ****    PCICR |= _BV(PCIE0);              // enable pin change interrupt for PB0 (rpm)
 2149               		.loc 4 414 4 view .LVU690
 2150               		.loc 4 414 10 is_stmt 0 view .LVU691
 2151 0780 E8E6      		ldi r30,lo8(104)
 2152 0782 F0E0      		ldi r31,0
 2153 0784 8081      		ld r24,Z
 2154 0786 8160      		ori r24,lo8(1)
 2155 0788 8083      		st Z,r24
 415:main.c        ****    PCMSK0 |= _BV(PCINT0);
 2156               		.loc 4 415 4 is_stmt 1 view .LVU692
 2157               		.loc 4 415 11 is_stmt 0 view .LVU693
 2158 078a EBE6      		ldi r30,lo8(107)
 2159 078c F0E0      		ldi r31,0
 2160 078e 8081      		ld r24,Z
 2161 0790 8160      		ori r24,lo8(1)
 2162 0792 8083      		st Z,r24
 416:main.c        ****    sei();
 2163               		.loc 4 416 4 is_stmt 1 view .LVU694
 2164               	/* #APP */
 2165               	 ;  416 "main.c" 1
 2166 0794 7894      		sei
 2167               	 ;  0 "" 2
 417:main.c        ****    led[0].r = 255;
 2168               		.loc 4 417 4 view .LVU695
 2169               		.loc 4 417 13 is_stmt 0 view .LVU696
 2170               	/* #NOAPP */
 2171 0796 C0E0      		ldi r28,lo8(led)
 2172 0798 D0E0      		ldi r29,hi8(led)
 2173 079a 8FEF      		ldi r24,lo8(-1)
 2174 079c 8983      		std Y+1,r24
 418:main.c        ****    led[0].g = 255;
 2175               		.loc 4 418 4 is_stmt 1 view .LVU697
 2176               		.loc 4 418 13 is_stmt 0 view .LVU698
 2177 079e 8883      		st Y,r24
 419:main.c        ****    led[0].b = 255;
 2178               		.loc 4 419 4 is_stmt 1 view .LVU699
 2179               		.loc 4 419 13 is_stmt 0 view .LVU700
 2180 07a0 8A83      		std Y+2,r24
 420:main.c        ****    ws2812_setleds(led,1);
 2181               		.loc 4 420 4 is_stmt 1 view .LVU701
 2182 07a2 61E0      		ldi r22,lo8(1)
 2183 07a4 70E0      		ldi r23,0
 2184 07a6 CE01      		movw r24,r28
 2185 07a8 0E94 0000 		call ws2812_setleds
 2186               	.LVL85:
 421:main.c        ****    setup_lcd();
 2187               		.loc 4 421 4 view .LVU702
 2188 07ac 0E94 0000 		call setup_lcd
 2189               	.LVL86:
 422:main.c        ****    initbl();
 2190               		.loc 4 422 4 view .LVU703
 2191 07b0 0E94 0000 		call initbl
 2192               	.LVL87:
 423:main.c        ****    led[0].r = 0;
 2193               		.loc 4 423 4 view .LVU704
 2194               		.loc 4 423 13 is_stmt 0 view .LVU705
 2195 07b4 1982      		std Y+1,__zero_reg__
 424:main.c        ****    led[0].g = 0;
 2196               		.loc 4 424 4 is_stmt 1 view .LVU706
 2197               		.loc 4 424 13 is_stmt 0 view .LVU707
 2198 07b6 1882      		st Y,__zero_reg__
 425:main.c        ****    led[0].b = 0;
 2199               		.loc 4 425 4 is_stmt 1 view .LVU708
 2200               		.loc 4 425 13 is_stmt 0 view .LVU709
 2201 07b8 1A82      		std Y+2,__zero_reg__
 426:main.c        ****    ws2812_setleds(led,1);
 2202               		.loc 4 426 4 is_stmt 1 view .LVU710
 2203 07ba 61E0      		ldi r22,lo8(1)
 2204 07bc 70E0      		ldi r23,0
 2205 07be CE01      		movw r24,r28
 2206 07c0 0E94 0000 		call ws2812_setleds
 2207               	.LVL88:
 427:main.c        ****    OCR0A = 210;
 2208               		.loc 4 427 4 view .LVU711
 2209               		.loc 4 427 10 is_stmt 0 view .LVU712
 2210 07c4 82ED      		ldi r24,lo8(-46)
 2211 07c6 87BD      		out 0x27,r24
 428:main.c        ****    wdt_enable(WDTO_8S);
 2212               		.loc 4 428 4 is_stmt 1 view .LVU713
 2213               	.LVL89:
 2214               	.LBB89:
 2215               	.LBI89:
 2216               		.file 6 "/usr/avr/include/avr/wdt.h"
   1:/usr/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/avr/include/avr/wdt.h **** 
   5:/usr/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/avr/wdt.h **** 
   8:/usr/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/avr/wdt.h **** 
  11:/usr/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/avr/include/avr/wdt.h ****      distribution.
  15:/usr/avr/include/avr/wdt.h **** 
  16:/usr/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/avr/include/avr/wdt.h **** 
  20:/usr/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/avr/include/avr/wdt.h **** 
  32:/usr/avr/include/avr/wdt.h **** /* $Id: wdt.h 2503 2016-02-07 22:59:47Z joerg_wunsch $ */
  33:/usr/avr/include/avr/wdt.h **** 
  34:/usr/avr/include/avr/wdt.h **** /*
  35:/usr/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/avr/include/avr/wdt.h ****  */
  37:/usr/avr/include/avr/wdt.h **** 
  38:/usr/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/avr/include/avr/wdt.h **** 
  41:/usr/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/avr/include/avr/wdt.h **** 
  44:/usr/avr/include/avr/wdt.h **** /** \file */
  45:/usr/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/avr/include/avr/wdt.h **** 
  48:/usr/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/avr/include/avr/wdt.h **** 
  57:/usr/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/avr/include/avr/wdt.h **** 
  61:/usr/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/avr/include/avr/wdt.h ****     the following:
  68:/usr/avr/include/avr/wdt.h **** 
  69:/usr/avr/include/avr/wdt.h ****     \code
  70:/usr/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/avr/include/avr/wdt.h **** 
  73:/usr/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/avr/include/avr/wdt.h **** 
  75:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/avr/include/avr/wdt.h ****     {
  80:/usr/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/avr/include/avr/wdt.h ****     }
  84:/usr/avr/include/avr/wdt.h ****     \endcode
  85:/usr/avr/include/avr/wdt.h **** 
  86:/usr/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/avr/include/avr/wdt.h **** */
  91:/usr/avr/include/avr/wdt.h **** 
  92:/usr/avr/include/avr/wdt.h **** /**
  93:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/avr/include/avr/wdt.h **** */
  98:/usr/avr/include/avr/wdt.h **** 
  99:/usr/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/avr/include/avr/wdt.h **** 
 101:/usr/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/avr/include/avr/wdt.h **** 
 103:/usr/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/avr/include/avr/wdt.h **** #else
 106:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/avr/include/avr/wdt.h **** #endif
 108:/usr/avr/include/avr/wdt.h **** 
 109:/usr/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/avr/include/avr/wdt.h **** #else
 114:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/avr/include/avr/wdt.h **** #endif
 116:/usr/avr/include/avr/wdt.h **** 
 117:/usr/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/avr/include/avr/wdt.h **** #else
 120:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/avr/include/avr/wdt.h **** #endif
 122:/usr/avr/include/avr/wdt.h **** 
 123:/usr/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/avr/include/avr/wdt.h **** 
 125:/usr/avr/include/avr/wdt.h **** 
 126:/usr/avr/include/avr/wdt.h **** /**
 127:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/avr/include/avr/wdt.h **** 
 134:/usr/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/avr/include/avr/wdt.h **** */
 136:/usr/avr/include/avr/wdt.h **** 
 137:/usr/avr/include/avr/wdt.h **** 
 138:/usr/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/avr/include/avr/wdt.h **** 
 140:/usr/avr/include/avr/wdt.h **** /*
 141:/usr/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 142:/usr/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 143:/usr/avr/include/avr/wdt.h ****    registers to the CCP register
 144:/usr/avr/include/avr/wdt.h **** ** At the same time,
 145:/usr/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 146:/usr/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 147:/usr/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 148:/usr/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 149:/usr/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 150:/usr/avr/include/avr/wdt.h ****    sync is finished).
 151:/usr/avr/include/avr/wdt.h **** */
 152:/usr/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 153:/usr/avr/include/avr/wdt.h **** do { \
 154:/usr/avr/include/avr/wdt.h **** uint8_t temp; \
 155:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 156:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 157:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 158:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 159:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 160:/usr/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 161:/usr/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 162:/usr/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 163:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 164:/usr/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 165:/usr/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 166:/usr/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 167:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 168:/usr/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 169:/usr/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 170:/usr/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 171:/usr/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 172:/usr/avr/include/avr/wdt.h ****     : "r0" \
 173:/usr/avr/include/avr/wdt.h **** ); \
 174:/usr/avr/include/avr/wdt.h **** } while(0)
 175:/usr/avr/include/avr/wdt.h **** 
 176:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 177:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 178:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 179:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 180:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 181:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 182:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 183:/usr/avr/include/avr/wdt.h ****     : \
 184:/usr/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 185:/usr/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 186:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 187:/usr/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 188:/usr/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 189:/usr/avr/include/avr/wdt.h ****     : "r0" \
 190:/usr/avr/include/avr/wdt.h **** );
 191:/usr/avr/include/avr/wdt.h **** 
 192:/usr/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 193:/usr/avr/include/avr/wdt.h **** 
 194:/usr/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 195:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 196:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 197:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 198:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 199:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 200:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 201:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 202:/usr/avr/include/avr/wdt.h ****     : /* no outputs */  \
 203:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 204:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 205:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 206:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 207:/usr/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 208:/usr/avr/include/avr/wdt.h ****     : "r16" \
 209:/usr/avr/include/avr/wdt.h **** )
 210:/usr/avr/include/avr/wdt.h **** 
 211:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 212:/usr/avr/include/avr/wdt.h **** do { \
 213:/usr/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 214:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 215:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 216:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 217:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 218:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 219:/usr/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 220:/usr/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 221:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 222:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 223:/usr/avr/include/avr/wdt.h ****     : /*no output */ \
 224:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 225:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 226:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 227:/usr/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 228:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 229:/usr/avr/include/avr/wdt.h ****     : "r16" \
 230:/usr/avr/include/avr/wdt.h **** ); \
 231:/usr/avr/include/avr/wdt.h **** }while(0)
 232:/usr/avr/include/avr/wdt.h **** 
 233:/usr/avr/include/avr/wdt.h **** #elif defined(CCP)
 234:/usr/avr/include/avr/wdt.h **** 
 235:/usr/avr/include/avr/wdt.h **** static __inline__
 236:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 237:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 238:/usr/avr/include/avr/wdt.h **** {
 239:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 240:/usr/avr/include/avr/wdt.h **** 	{
 241:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 242:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 243:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 244:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 245:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 246:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 247:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 248:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 249:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 250:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 251:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 252:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 253:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 254:/usr/avr/include/avr/wdt.h **** 			: "r0"
 255:/usr/avr/include/avr/wdt.h **** 			);
 256:/usr/avr/include/avr/wdt.h **** 	}
 257:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 258:/usr/avr/include/avr/wdt.h **** 	{
 259:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 260:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 261:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 262:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 263:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 264:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 265:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 266:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 267:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 268:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 269:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 270:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 271:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 272:/usr/avr/include/avr/wdt.h **** 			: "r0"
 273:/usr/avr/include/avr/wdt.h **** 			);
 274:/usr/avr/include/avr/wdt.h **** 	}
 275:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 276:/usr/avr/include/avr/wdt.h **** 	{
 277:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 278:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 279:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 280:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 281:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 282:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 283:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 284:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 285:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 286:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 287:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 288:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 289:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 290:/usr/avr/include/avr/wdt.h **** 			: "r0"
 291:/usr/avr/include/avr/wdt.h **** 			);
 292:/usr/avr/include/avr/wdt.h **** 	}
 293:/usr/avr/include/avr/wdt.h **** 	else
 294:/usr/avr/include/avr/wdt.h ****  	{
 295:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 296:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 297:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 298:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 299:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 300:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 301:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 302:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 303:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 304:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 305:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 306:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 307:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 308:/usr/avr/include/avr/wdt.h **** 			: "r0"
 309:/usr/avr/include/avr/wdt.h **** 			);
 310:/usr/avr/include/avr/wdt.h **** 	}
 311:/usr/avr/include/avr/wdt.h **** }
 312:/usr/avr/include/avr/wdt.h **** 
 313:/usr/avr/include/avr/wdt.h **** static __inline__
 314:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 315:/usr/avr/include/avr/wdt.h **** void wdt_disable (void)
 316:/usr/avr/include/avr/wdt.h **** {
 317:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 318:/usr/avr/include/avr/wdt.h **** 	{
 319:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 320:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 321:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 322:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 323:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 324:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 325:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 326:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 327:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 328:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 330:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 331:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 334:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 335:/usr/avr/include/avr/wdt.h **** 				: "r0"
 336:/usr/avr/include/avr/wdt.h **** 				);
 337:/usr/avr/include/avr/wdt.h **** 	}
 338:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 339:/usr/avr/include/avr/wdt.h **** 	{
 340:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 341:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 342:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 343:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 344:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 345:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 346:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 347:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 348:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 349:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 350:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 351:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 352:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 353:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 354:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 355:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 356:/usr/avr/include/avr/wdt.h **** 				: "r0"
 357:/usr/avr/include/avr/wdt.h **** 				);
 358:/usr/avr/include/avr/wdt.h **** 	}
 359:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 360:/usr/avr/include/avr/wdt.h **** 	{
 361:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 362:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 363:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 364:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 365:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 366:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 367:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 368:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 369:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 370:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 371:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 372:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 373:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 374:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 375:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 376:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 377:/usr/avr/include/avr/wdt.h **** 				: "r0"
 378:/usr/avr/include/avr/wdt.h **** 				);
 379:/usr/avr/include/avr/wdt.h **** 	}
 380:/usr/avr/include/avr/wdt.h **** 	else
 381:/usr/avr/include/avr/wdt.h **** 	{
 382:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 383:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 384:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 385:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 386:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 387:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 388:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 389:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 390:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 391:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 392:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 393:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 394:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 395:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 396:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 397:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 398:/usr/avr/include/avr/wdt.h **** 				: "r0"
 399:/usr/avr/include/avr/wdt.h **** 				);
 400:/usr/avr/include/avr/wdt.h **** 	}
 401:/usr/avr/include/avr/wdt.h **** }
 402:/usr/avr/include/avr/wdt.h **** 
 403:/usr/avr/include/avr/wdt.h **** #else
 404:/usr/avr/include/avr/wdt.h **** 
 405:/usr/avr/include/avr/wdt.h **** static __inline__
 406:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 407:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 2217               		.loc 6 407 6 view .LVU714
 2218               	.LBB90:
 408:/usr/avr/include/avr/wdt.h **** {
 409:/usr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 2219               		.loc 6 409 2 view .LVU715
 410:/usr/avr/include/avr/wdt.h **** 	{
 411:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 412:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 413:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 414:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 415:/usr/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 416:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 417:/usr/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 418:/usr/avr/include/avr/wdt.h **** 				: /* no outputs */
 419:/usr/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 420:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 421:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 422:/usr/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 423:/usr/avr/include/avr/wdt.h **** 				: "r0"
 424:/usr/avr/include/avr/wdt.h **** 		);
 425:/usr/avr/include/avr/wdt.h **** 	}
 426:/usr/avr/include/avr/wdt.h **** 	else
 427:/usr/avr/include/avr/wdt.h **** 	{
 428:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2220               		.loc 6 428 3 view .LVU716
 2221 07c8 88E1      		ldi r24,lo8(24)
 2222 07ca 99E2      		ldi r25,lo8(41)
 2223               	/* #APP */
 2224               	 ;  428 "/usr/avr/include/avr/wdt.h" 1
 2225 07cc 0FB6      		in __tmp_reg__,__SREG__
 2226 07ce F894      		cli
 2227 07d0 A895      		wdr
 2228 07d2 8093 6000 		sts 96, r24
 2229 07d6 0FBE      		out __SREG__,__tmp_reg__
 2230 07d8 9093 6000 		sts 96, r25
 2231               	 	
 2232               	 ;  0 "" 2
 2233               	.LVL90:
 2234               		.loc 6 428 3 is_stmt 0 view .LVU717
 2235               	/* #NOAPP */
 2236               	.LBE90:
 2237               	.LBE89:
 429:main.c        ****    bllevel = 0;
 2238               		.loc 4 429 4 is_stmt 1 view .LVU718
 2239               		.loc 4 429 12 is_stmt 0 view .LVU719
 2240 07dc 1092 0000 		sts bllevel,__zero_reg__
 430:main.c        ****    newbllevel = 31;
 2241               		.loc 4 430 4 is_stmt 1 view .LVU720
 2242               		.loc 4 430 15 is_stmt 0 view .LVU721
 2243 07e0 8FE1      		ldi r24,lo8(31)
 2244 07e2 8093 0000 		sts newbllevel,r24
 2245               	/* epilogue start */
 431:main.c        **** }
 2246               		.loc 4 431 1 view .LVU722
 2247 07e6 DF91      		pop r29
 2248 07e8 CF91      		pop r28
 2249 07ea 0895      		ret
 2250               		.cfi_endproc
 2251               	.LFE32:
 2253               	.global	__floatunsisf
 2254               	.global	__mulsf3
 2255               	.global	__fixunssfsi
 2256               		.section	.text.startup,"ax",@progbits
 2257               	.global	main
 2259               	main:
 2260               	.LFB33:
 432:main.c        **** 
 433:main.c        **** 
 434:main.c        **** int main(void)
 435:main.c        **** {
 2261               		.loc 4 435 1 is_stmt 1 view -0
 2262               		.cfi_startproc
 2263 0000 00D0      		rcall .
 2264 0002 00D0      		rcall .
 2265               	.LCFI24:
 2266               		.cfi_def_cfa_offset 6
 2267 0004 CDB7      		in r28,__SP_L__
 2268 0006 DEB7      		in r29,__SP_H__
 2269               	.LCFI25:
 2270               		.cfi_def_cfa_register 28
 2271               	/* prologue: function */
 2272               	/* frame size = 4 */
 2273               	/* stack size = 4 */
 2274               	.L__stack_usage = 4
 436:main.c        ****   uint8_t adcselect = 0;
 2275               		.loc 4 436 3 view .LVU724
 2276               	.LVL91:
 437:main.c        ****   setup();
 2277               		.loc 4 437 3 view .LVU725
 2278 0008 0E94 0000 		call setup
 2279               	.LVL92:
 436:main.c        ****   uint8_t adcselect = 0;
 2280               		.loc 4 436 11 is_stmt 0 view .LVU726
 2281 000c 10E0      		ldi r17,0
 438:main.c        **** 
 439:main.c        ****   while(1) {  
 440:main.c        **** 
 441:main.c        ****   if (!SDA_LINE) {i2cerror++;}
 442:main.c        ****   
 443:main.c        ****   if (i2cerror > 50) {
 444:main.c        ****   TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN); 
 2282               		.loc 4 444 8 view .LVU727
 2283 000e 01ED      		ldi r16,lo8(-47)
 445:main.c        ****   I2C_init(I2C_ADDR); 
 446:main.c        ****   i2cerror = 0;
 447:main.c        ****   sei();
 448:main.c        ****   }                    
 449:main.c        **** 
 450:main.c        ****   wdt_reset();	
 451:main.c        ****   if (isrtimer > 31250)   // routine for calculate fan speed - timer is 32khz
 452:main.c        ****   {rpm = fanspin * 30;    // 2 signals each turn        
 2284               		.loc 4 452 18 view .LVU728
 2285 0010 5EE1      		ldi r21,lo8(30)
 2286 0012 F52E      		mov r15,r21
 2287               	.LVL93:
 2288               	.L181:
 439:main.c        **** 
 2289               		.loc 4 439 3 is_stmt 1 view .LVU729
 441:main.c        ****   
 2290               		.loc 4 441 3 view .LVU730
 441:main.c        ****   
 2291               		.loc 4 441 6 is_stmt 0 view .LVU731
 2292 0014 4999      		sbic 0x9,1
 2293 0016 00C0      		rjmp .L182
 441:main.c        ****   
 2294               		.loc 4 441 19 is_stmt 1 discriminator 1 view .LVU732
 441:main.c        ****   
 2295               		.loc 4 441 27 is_stmt 0 discriminator 1 view .LVU733
 2296 0018 8091 0000 		lds r24,i2cerror
 2297 001c 8F5F      		subi r24,lo8(-(1))
 2298 001e 8093 0000 		sts i2cerror,r24
 2299               	.L182:
 443:main.c        ****   TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN); 
 2300               		.loc 4 443 3 is_stmt 1 view .LVU734
 443:main.c        ****   TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN); 
 2301               		.loc 4 443 6 is_stmt 0 view .LVU735
 2302 0022 8091 0000 		lds r24,i2cerror
 2303 0026 8333      		cpi r24,lo8(51)
 2304 0028 00F0      		brlo .L183
 444:main.c        ****   I2C_init(I2C_ADDR); 
 2305               		.loc 4 444 3 is_stmt 1 view .LVU736
 444:main.c        ****   I2C_init(I2C_ADDR); 
 2306               		.loc 4 444 8 is_stmt 0 view .LVU737
 2307 002a 0093 BC00 		sts 188,r16
 445:main.c        ****   i2cerror = 0;
 2308               		.loc 4 445 3 is_stmt 1 view .LVU738
 2309 002e 8AE2      		ldi r24,lo8(42)
 2310 0030 0E94 0000 		call I2C_init
 2311               	.LVL94:
 446:main.c        ****   sei();
 2312               		.loc 4 446 3 view .LVU739
 446:main.c        ****   sei();
 2313               		.loc 4 446 12 is_stmt 0 view .LVU740
 2314 0034 1092 0000 		sts i2cerror,__zero_reg__
 447:main.c        ****   }                    
 2315               		.loc 4 447 3 is_stmt 1 view .LVU741
 2316               	/* #APP */
 2317               	 ;  447 "main.c" 1
 2318 0038 7894      		sei
 2319               	 ;  0 "" 2
 2320               	/* #NOAPP */
 2321               	.L183:
 450:main.c        ****   if (isrtimer > 31250)   // routine for calculate fan speed - timer is 32khz
 2322               		.loc 4 450 3 view .LVU742
 2323               	/* #APP */
 2324               	 ;  450 "main.c" 1
 2325 003a A895      		wdr
 2326               	 ;  0 "" 2
 451:main.c        ****   {rpm = fanspin * 30;    // 2 signals each turn        
 2327               		.loc 4 451 3 view .LVU743
 451:main.c        ****   {rpm = fanspin * 30;    // 2 signals each turn        
 2328               		.loc 4 451 6 is_stmt 0 view .LVU744
 2329               	/* #NOAPP */
 2330 003c 8091 0000 		lds r24,isrtimer
 2331 0040 9091 0000 		lds r25,isrtimer+1
 2332 0044 8331      		cpi r24,19
 2333 0046 9A47      		sbci r25,122
 2334 0048 00F0      		brlo .L185
 2335               		.loc 4 452 4 is_stmt 1 view .LVU745
 2336               		.loc 4 452 18 is_stmt 0 view .LVU746
 2337 004a 2091 0000 		lds r18,fanspin
 2338 004e 3091 0000 		lds r19,fanspin+1
 2339 0052 F29E      		mul r15,r18
 2340 0054 C001      		movw r24,r0
 2341 0056 F39E      		mul r15,r19
 2342 0058 900D      		add r25,r0
 2343 005a 1124      		clr __zero_reg__
 2344               		.loc 4 452 8 view .LVU747
 2345 005c 9093 0000 		sts rpm+1,r25
 2346 0060 8093 0000 		sts rpm,r24
 453:main.c        ****   fanspin = 0;
 2347               		.loc 4 453 3 is_stmt 1 view .LVU748
 2348               		.loc 4 453 11 is_stmt 0 view .LVU749
 2349 0064 1092 0000 		sts fanspin+1,__zero_reg__
 2350 0068 1092 0000 		sts fanspin,__zero_reg__
 454:main.c        ****   isrtimer = 0;
 2351               		.loc 4 454 3 is_stmt 1 view .LVU750
 2352               		.loc 4 454 12 is_stmt 0 view .LVU751
 2353 006c 1092 0000 		sts isrtimer+1,__zero_reg__
 2354 0070 1092 0000 		sts isrtimer,__zero_reg__
 455:main.c        ****   if (fanlevel == 254) { //fan minimal auto
 2355               		.loc 4 455 3 is_stmt 1 view .LVU752
 2356               		.loc 4 455 6 is_stmt 0 view .LVU753
 2357 0074 2091 0000 		lds r18,fanlevel
 2358 0078 2E3F      		cpi r18,lo8(-2)
 2359 007a 01F4      		brne .L185
 456:main.c        ****   if (rpm > 4400) {OCR0A++;}
 2360               		.loc 4 456 3 is_stmt 1 view .LVU754
 2361               		.loc 4 456 6 is_stmt 0 view .LVU755
 2362 007c 8133      		cpi r24,49
 2363 007e 9141      		sbci r25,17
 2364 0080 00F0      		brlo .L187
 2365               		.loc 4 456 20 is_stmt 1 discriminator 1 view .LVU756
 2366 0082 87B5      		in r24,0x27
 2367               		.loc 4 456 25 is_stmt 0 discriminator 1 view .LVU757
 2368 0084 8F5F      		subi r24,lo8(-(1))
 2369 0086 87BD      		out 0x27,r24
 2370               	.L187:
 457:main.c        ****   if (rpm < 3600) {OCR0A--;}
 2371               		.loc 4 457 3 is_stmt 1 view .LVU758
 2372               		.loc 4 457 6 is_stmt 0 view .LVU759
 2373 0088 8091 0000 		lds r24,rpm
 2374 008c 9091 0000 		lds r25,rpm+1
 2375 0090 8031      		cpi r24,16
 2376 0092 9E40      		sbci r25,14
 2377 0094 00F4      		brsh .L185
 2378               		.loc 4 457 20 is_stmt 1 discriminator 1 view .LVU760
 2379 0096 87B5      		in r24,0x27
 2380               		.loc 4 457 25 is_stmt 0 discriminator 1 view .LVU761
 2381 0098 8150      		subi r24,lo8(-(-1))
 2382 009a 87BD      		out 0x27,r24
 2383               	.L185:
 458:main.c        ****   }
 459:main.c        ****   }
 460:main.c        **** 
 461:main.c        ****   if (changeled)  {
 2384               		.loc 4 461 3 is_stmt 1 view .LVU762
 2385               		.loc 4 461 6 is_stmt 0 view .LVU763
 2386 009c 8091 0000 		lds r24,changeled
 2387 00a0 8823      		tst r24
 2388 00a2 01F0      		breq .L188
 462:main.c        ****       ws2812_setleds(led,1);
 2389               		.loc 4 462 7 is_stmt 1 view .LVU764
 2390 00a4 61E0      		ldi r22,lo8(1)
 2391 00a6 70E0      		ldi r23,0
 2392 00a8 80E0      		ldi r24,lo8(led)
 2393 00aa 90E0      		ldi r25,hi8(led)
 2394 00ac 0E94 0000 		call ws2812_setleds
 2395               	.LVL95:
 463:main.c        ****       changeled = 0;
 2396               		.loc 4 463 7 view .LVU765
 2397               		.loc 4 463 17 is_stmt 0 view .LVU766
 2398 00b0 1092 0000 		sts changeled,__zero_reg__
 2399               	.L188:
 464:main.c        ****                      }
 465:main.c        **** 
 466:main.c        ****   if (0 <= newbllevel && newbllevel < 32) {
 2400               		.loc 4 466 3 is_stmt 1 view .LVU767
 2401               		.loc 4 466 23 is_stmt 0 view .LVU768
 2402 00b4 9091 0000 		lds r25,newbllevel
 2403               		.loc 4 466 6 view .LVU769
 2404 00b8 9032      		cpi r25,lo8(32)
 2405 00ba 00F4      		brsh .L190
 467:main.c        ****   if (newbllevel < bllevel) {                // smooth backlight level change in steps
 2406               		.loc 4 467 3 is_stmt 1 view .LVU770
 2407               		.loc 4 467 18 is_stmt 0 view .LVU771
 2408 00bc 8091 0000 		lds r24,bllevel
 2409               		.loc 4 467 6 view .LVU772
 2410 00c0 9817      		cp r25,r24
 2411 00c2 00F4      		brsh .L191
 468:main.c        **** 
 469:main.c        ****       bllevel--;
 2412               		.loc 4 469 7 is_stmt 1 view .LVU773
 2413               		.loc 4 469 14 is_stmt 0 view .LVU774
 2414 00c4 8150      		subi r24,lo8(-(-1))
 2415 00c6 8093 0000 		sts bllevel,r24
 470:main.c        ****       writebl(0b01011000);   writebl(0b00011111 & bllevel);
 2416               		.loc 4 470 7 is_stmt 1 view .LVU775
 2417 00ca 88E5      		ldi r24,lo8(88)
 2418 00cc 0E94 0000 		call writebl
 2419               	.LVL96:
 2420               		.loc 4 470 30 view .LVU776
 2421 00d0 8091 0000 		lds r24,bllevel
 2422 00d4 8F71      		andi r24,lo8(31)
 2423 00d6 0E94 0000 		call writebl
 2424               	.LVL97:
 2425               	.L191:
 471:main.c        **** 	  }
 472:main.c        **** 
 473:main.c        ****      if (newbllevel > bllevel) {
 2426               		.loc 4 473 6 view .LVU777
 2427               		.loc 4 473 21 is_stmt 0 view .LVU778
 2428 00da 8091 0000 		lds r24,bllevel
 2429               		.loc 4 473 9 view .LVU779
 2430 00de 9091 0000 		lds r25,newbllevel
 2431 00e2 8917      		cp r24,r25
 2432 00e4 00F4      		brsh .L190
 474:main.c        **** 
 475:main.c        **** 	  bllevel++;
 2433               		.loc 4 475 4 is_stmt 1 view .LVU780
 2434               		.loc 4 475 11 is_stmt 0 view .LVU781
 2435 00e6 8F5F      		subi r24,lo8(-(1))
 2436 00e8 8093 0000 		sts bllevel,r24
 476:main.c        **** 	   writebl(0b01011000);   writebl(0b00011111 & bllevel);
 2437               		.loc 4 476 5 is_stmt 1 view .LVU782
 2438 00ec 88E5      		ldi r24,lo8(88)
 2439 00ee 0E94 0000 		call writebl
 2440               	.LVL98:
 2441               		.loc 4 476 28 view .LVU783
 2442 00f2 8091 0000 		lds r24,bllevel
 2443 00f6 8F71      		andi r24,lo8(31)
 2444 00f8 0E94 0000 		call writebl
 2445               	.LVL99:
 2446               	.L190:
 477:main.c        **** 
 478:main.c        **** 	  }}
 479:main.c        **** 
 480:main.c        ****   if (adcselect < 10) {adcselect++;} else {adcselect = 0;}
 2447               		.loc 4 480 3 view .LVU784
 2448               		.loc 4 480 6 is_stmt 0 view .LVU785
 2449 00fc 1A30      		cpi r17,lo8(10)
 2450 00fe 00F4      		brsh .L193
 2451               		.loc 4 480 24 is_stmt 1 discriminator 1 view .LVU786
 2452               		.loc 4 480 33 is_stmt 0 discriminator 1 view .LVU787
 2453 0100 1F5F      		subi r17,lo8(-(1))
 2454               	.LVL100:
 481:main.c        ****   
 482:main.c        ****   switch(adcselect)
 2455               		.loc 4 482 3 is_stmt 1 discriminator 1 view .LVU788
 2456 0102 EFEF      		ldi r30,lo8(-1)
 2457 0104 E10F      		add r30,r17
 2458 0106 EA30      		cpi r30,lo8(10)
 2459 0108 00F0      		brlo .+2
 2460 010a 00C0      		rjmp .L194
 2461 010c F0E0      		ldi r31,0
 2462 010e E050      		subi r30,lo8(-(gs(.L196)))
 2463 0110 F040      		sbci r31,hi8(-(gs(.L196)))
 2464 0112 0C94 0000 		jmp __tablejump2__
 2465               		.section	.jumptables.gcc.main,"a",@progbits
 2466               		.p2align	1
 2467               	.L196:
 2468 0000 0000      		.word gs(.L202)
 2469 0002 0000      		.word gs(.L201)
 2470 0004 0000      		.word gs(.L194)
 2471 0006 0000      		.word gs(.L200)
 2472 0008 0000      		.word gs(.L199)
 2473 000a 0000      		.word gs(.L194)
 2474 000c 0000      		.word gs(.L198)
 2475 000e 0000      		.word gs(.L197)
 2476 0010 0000      		.word gs(.L194)
 2477 0012 0000      		.word gs(.L195)
 2478               		.section	.text.startup
 2479               	.L193:
 2480               	.LVL101:
 483:main.c        ****   {
 484:main.c        ****    case 0: a0 = readAna(7);  break;
 2481               		.loc 4 484 12 view .LVU789
 2482               		.loc 4 484 17 is_stmt 0 view .LVU790
 2483 0116 87E0      		ldi r24,lo8(7)
 2484 0118 0E94 0000 		call readAna
 2485               	.LVL102:
 2486               		.loc 4 484 15 view .LVU791
 2487 011c 9093 0000 		sts a0+1,r25
 2488 0120 8093 0000 		sts a0,r24
 2489               		.loc 4 484 30 is_stmt 1 view .LVU792
 2490               		.loc 4 484 4 is_stmt 0 view .LVU793
 2491 0124 10E0      		ldi r17,0
 2492 0126 00C0      		rjmp .L181
 2493               	.LVL103:
 2494               	.L202:
 485:main.c        ****    case 1: a1 = readAna(6);  break;
 2495               		.loc 4 485 12 is_stmt 1 view .LVU794
 2496               		.loc 4 485 17 is_stmt 0 view .LVU795
 2497 0128 86E0      		ldi r24,lo8(6)
 2498 012a 0E94 0000 		call readAna
 2499               	.LVL104:
 2500               		.loc 4 485 15 view .LVU796
 2501 012e 9093 0000 		sts a1+1,r25
 2502 0132 8093 0000 		sts a1,r24
 2503               		.loc 4 485 30 is_stmt 1 view .LVU797
 2504               		.loc 4 485 4 is_stmt 0 view .LVU798
 2505 0136 00C0      		rjmp .L181
 2506               	.L201:
 486:main.c        ****    case 2: a2 = readAna(5);  break;
 2507               		.loc 4 486 12 is_stmt 1 view .LVU799
 2508               		.loc 4 486 17 is_stmt 0 view .LVU800
 2509 0138 85E0      		ldi r24,lo8(5)
 2510 013a 0E94 0000 		call readAna
 2511               	.LVL105:
 2512               		.loc 4 486 15 view .LVU801
 2513 013e 9093 0000 		sts a2+1,r25
 2514 0142 8093 0000 		sts a2,r24
 2515               		.loc 4 486 30 is_stmt 1 view .LVU802
 2516               		.loc 4 486 4 is_stmt 0 view .LVU803
 2517 0146 00C0      		rjmp .L181
 2518               	.L200:
 487:main.c        ****    case 4: a3 = readAna(4);  break; 
 2519               		.loc 4 487 12 is_stmt 1 view .LVU804
 2520               		.loc 4 487 17 is_stmt 0 view .LVU805
 2521 0148 84E0      		ldi r24,lo8(4)
 2522 014a 0E94 0000 		call readAna
 2523               	.LVL106:
 2524               		.loc 4 487 15 view .LVU806
 2525 014e 9093 0000 		sts a3+1,r25
 2526 0152 8093 0000 		sts a3,r24
 2527               		.loc 4 487 30 is_stmt 1 view .LVU807
 2528               		.loc 4 487 4 is_stmt 0 view .LVU808
 2529 0156 00C0      		rjmp .L181
 2530               	.L199:
 488:main.c        ****    case 5: a4 = readAna(1);  break; 
 2531               		.loc 4 488 12 is_stmt 1 view .LVU809
 2532               		.loc 4 488 17 is_stmt 0 view .LVU810
 2533 0158 81E0      		ldi r24,lo8(1)
 2534 015a 0E94 0000 		call readAna
 2535               	.LVL107:
 2536               		.loc 4 488 15 view .LVU811
 2537 015e 9093 0000 		sts a4+1,r25
 2538 0162 8093 0000 		sts a4,r24
 2539               		.loc 4 488 30 is_stmt 1 view .LVU812
 2540               		.loc 4 488 4 is_stmt 0 view .LVU813
 2541 0166 00C0      		rjmp .L181
 2542               	.L198:
 489:main.c        ****    case 7: a5 = readAna(0);  break;
 2543               		.loc 4 489 12 is_stmt 1 view .LVU814
 2544               		.loc 4 489 17 is_stmt 0 view .LVU815
 2545 0168 80E0      		ldi r24,0
 2546 016a 0E94 0000 		call readAna
 2547               	.LVL108:
 2548               		.loc 4 489 15 view .LVU816
 2549 016e 9093 0000 		sts a5+1,r25
 2550 0172 8093 0000 		sts a5,r24
 2551               		.loc 4 489 30 is_stmt 1 view .LVU817
 2552               		.loc 4 489 4 is_stmt 0 view .LVU818
 2553 0176 00C0      		rjmp .L181
 2554               	.L197:
 490:main.c        ****    case 8: vcc = readVcc();  break;
 2555               		.loc 4 490 12 is_stmt 1 view .LVU819
 2556               		.loc 4 490 18 is_stmt 0 view .LVU820
 2557 0178 0E94 0000 		call readVcc
 2558               	.LVL109:
 2559               		.loc 4 490 16 view .LVU821
 2560 017c 9093 0000 		sts vcc+1,r25
 2561 0180 8093 0000 		sts vcc,r24
 2562               		.loc 4 490 30 is_stmt 1 view .LVU822
 2563               		.loc 4 490 4 is_stmt 0 view .LVU823
 2564 0184 00C0      		rjmp .L181
 2565               	.L195:
 491:main.c        ****    case 10: temp = GetTemp();   break;
 2566               		.loc 4 491 13 is_stmt 1 view .LVU824
 2567               		.loc 4 491 20 is_stmt 0 view .LVU825
 2568 0186 0E94 0000 		call GetTemp
 2569               	.LVL110:
 2570               		.loc 4 491 18 view .LVU826
 2571 018a 9093 0000 		sts temp+1,r25
 2572 018e 8093 0000 		sts temp,r24
 2573               		.loc 4 491 33 is_stmt 1 view .LVU827
 2574               		.loc 4 491 4 is_stmt 0 view .LVU828
 2575 0192 00C0      		rjmp .L181
 2576               	.L194:
 492:main.c        **** 
 493:main.c        ****  
 494:main.c        ****    default: {a7 = readAna(10);  //read A7 more frequently 
 2577               		.loc 4 494 14 is_stmt 1 view .LVU829
 2578               		.loc 4 494 19 is_stmt 0 view .LVU830
 2579 0194 8AE0      		ldi r24,lo8(10)
 2580 0196 0E94 0000 		call readAna
 2581               	.LVL111:
 2582 019a 9C01      		movw r18,r24
 2583               		.loc 4 494 17 view .LVU831
 2584 019c 9093 0000 		sts a7+1,r25
 2585 01a0 8093 0000 		sts a7,r24
 495:main.c        ****            if (a7 > a7max) a7max = a7;
 2586               		.loc 4 495 12 is_stmt 1 view .LVU832
 2587               		.loc 4 495 15 is_stmt 0 view .LVU833
 2588 01a4 8091 0000 		lds r24,a7max
 2589 01a8 9091 0000 		lds r25,a7max+1
 2590 01ac 8217      		cp r24,r18
 2591 01ae 9307      		cpc r25,r19
 2592 01b0 00F4      		brsh .L204
 2593               		.loc 4 495 28 is_stmt 1 discriminator 1 view .LVU834
 2594               		.loc 4 495 34 is_stmt 0 discriminator 1 view .LVU835
 2595 01b2 3093 0000 		sts a7max+1,r19
 2596 01b6 2093 0000 		sts a7max,r18
 2597               	.L204:
 496:main.c        ****            if (a7 < a7min) a7min = a7;
 2598               		.loc 4 496 12 is_stmt 1 view .LVU836
 2599               		.loc 4 496 15 is_stmt 0 view .LVU837
 2600 01ba 8091 0000 		lds r24,a7min
 2601 01be 9091 0000 		lds r25,a7min+1
 2602 01c2 2817      		cp r18,r24
 2603 01c4 3907      		cpc r19,r25
 2604 01c6 00F4      		brsh .L205
 2605               		.loc 4 496 28 is_stmt 1 discriminator 1 view .LVU838
 2606               		.loc 4 496 34 is_stmt 0 discriminator 1 view .LVU839
 2607 01c8 3093 0000 		sts a7min+1,r19
 2608 01cc 2093 0000 		sts a7min,r18
 2609               	.L205:
 497:main.c        ****            a7count++;
 2610               		.loc 4 497 12 is_stmt 1 view .LVU840
 2611               		.loc 4 497 19 is_stmt 0 view .LVU841
 2612 01d0 8091 0000 		lds r24,a7count
 2613 01d4 8F5F      		subi r24,lo8(-(1))
 2614 01d6 8093 0000 		sts a7count,r24
 498:main.c        ****            if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max
 2615               		.loc 4 498 12 is_stmt 1 view .LVU842
 2616               		.loc 4 498 15 is_stmt 0 view .LVU843
 2617 01da 8D33      		cpi r24,lo8(61)
 2618 01dc 00F4      		brsh .+2
 2619 01de 00C0      		rjmp .L181
 2620               		.loc 4 498 31 is_stmt 1 discriminator 1 view .LVU844
 2621               		.loc 4 498 46 is_stmt 0 discriminator 1 view .LVU845
 2622 01e0 2091 0000 		lds r18,a7max
 2623 01e4 3091 0000 		lds r19,a7max+1
 2624               		.loc 4 498 56 discriminator 1 view .LVU846
 2625 01e8 8091 0000 		lds r24,a7min
 2626 01ec 9091 0000 		lds r25,a7min+1
 2627 01f0 820F      		add r24,r18
 2628 01f2 931F      		adc r25,r19
 2629               		.loc 4 498 65 discriminator 1 view .LVU847
 2630 01f4 9695      		lsr r25
 2631 01f6 8795      		ror r24
 2632               		.loc 4 498 46 discriminator 1 view .LVU848
 2633 01f8 281B      		sub r18,r24
 2634 01fa 390B      		sbc r19,r25
 2635               		.loc 4 498 71 discriminator 1 view .LVU849
 2636 01fc C901      		movw r24,r18
 2637 01fe B0E0      		ldi r27,0
 2638 0200 A0E0      		ldi r26,0
 2639 0202 8983      		std Y+1,r24
 2640 0204 9A83      		std Y+2,r25
 2641 0206 AB83      		std Y+3,r26
 2642 0208 BC83      		std Y+4,r27
 2643 020a B901      		movw r22,r18
 2644 020c CD01      		movw r24,r26
 2645 020e 0E94 0000 		call __floatunsisf
 2646               	.LVL112:
 2647 0212 24EF      		ldi r18,lo8(-12)
 2648 0214 3DEF      		ldi r19,lo8(-3)
 2649 0216 44E3      		ldi r20,lo8(52)
 2650 0218 5FE3      		ldi r21,lo8(63)
 2651 021a 6983      		std Y+1,r22
 2652 021c 7A83      		std Y+2,r23
 2653 021e 8B83      		std Y+3,r24
 2654 0220 9C83      		std Y+4,r25
 2655 0222 6981      		ldd r22,Y+1
 2656 0224 7A81      		ldd r23,Y+2
 2657 0226 8B81      		ldd r24,Y+3
 2658 0228 9C81      		ldd r25,Y+4
 2659 022a 0E94 0000 		call __mulsf3
 2660               	.LVL113:
 2661               		.loc 4 498 37 discriminator 1 view .LVU850
 2662 022e 6983      		std Y+1,r22
 2663 0230 7A83      		std Y+2,r23
 2664 0232 8B83      		std Y+3,r24
 2665 0234 9C83      		std Y+4,r25
 2666 0236 6981      		ldd r22,Y+1
 2667 0238 7A81      		ldd r23,Y+2
 2668 023a 8B81      		ldd r24,Y+3
 2669 023c 9C81      		ldd r25,Y+4
 2670 023e 0E94 0000 		call __fixunssfsi
 2671               	.LVL114:
 2672 0242 7093 0000 		sts a7avg+1,r23
 2673 0246 6093 0000 		sts a7avg,r22
 2674               		.loc 4 498 81 is_stmt 1 discriminator 1 view .LVU851
 2675               		.loc 4 498 87 is_stmt 0 discriminator 1 view .LVU852
 2676 024a A0E0      		ldi r26,0
 2677 024c B4E0      		ldi r27,lo8(4)
 2678 024e B093 0000 		sts a7min+1,r27
 2679 0252 A093 0000 		sts a7min,r26
 2680               		.loc 4 498 95 is_stmt 1 discriminator 1 view .LVU853
 2681               		.loc 4 498 101 is_stmt 0 discriminator 1 view .LVU854
 2682 0256 1092 0000 		sts a7max+1,__zero_reg__
 2683 025a 1092 0000 		sts a7max,__zero_reg__
 2684               		.loc 4 498 106 is_stmt 1 discriminator 1 view .LVU855
 2685               		.loc 4 498 114 is_stmt 0 discriminator 1 view .LVU856
 2686 025e 1092 0000 		sts a7count,__zero_reg__
 2687 0262 00C0      		rjmp .L181
 2688               		.cfi_endproc
 2689               	.LFE33:
 2691               	.global	commands2
 2692               		.data
 2695               	commands2:
 2696 0000 1100      		.word	17
 2697 0002 0000      		.word	0
 2698 0004 0100      		.word	1
 2699 0006 0000      		.word	0
 2700 0008 C100      		.word	193
 2701 000a A801      		.word	424
 2702 000c B101      		.word	433
 2703 000e 4501      		.word	325
 2704 0010 0401      		.word	260
 2705 0012 C500      		.word	197
 2706 0014 8001      		.word	384
 2707 0016 6C01      		.word	364
 2708 0018 C600      		.word	198
 2709 001a BD01      		.word	445
 2710 001c 8401      		.word	388
 2711 001e C700      		.word	199
 2712 0020 BD01      		.word	445
 2713 0022 8401      		.word	388
 2714 0024 BD00      		.word	189
 2715 0026 0201      		.word	258
 2716 0028 1100      		.word	17
 2717 002a 0000      		.word	0
 2718 002c F200      		.word	242
 2719 002e 0001      		.word	256
 2720 0030 0001      		.word	256
 2721 0032 8201      		.word	386
 2722 0034 2600      		.word	38
 2723 0036 0801      		.word	264
 2724 0038 E000      		.word	224
 2725 003a 0001      		.word	256
 2726 003c 0401      		.word	260
 2727 003e 0801      		.word	264
 2728 0040 0B01      		.word	267
 2729 0042 0C01      		.word	268
 2730 0044 1101      		.word	273
 2731 0046 0D01      		.word	269
 2732 0048 0E01      		.word	270
 2733 004a 0001      		.word	256
 2734 004c 0401      		.word	260
 2735 004e 0801      		.word	264
 2736 0050 1301      		.word	275
 2737 0052 1401      		.word	276
 2738 0054 2F01      		.word	303
 2739 0056 2901      		.word	297
 2740 0058 2401      		.word	292
 2741 005a E100      		.word	225
 2742 005c 0001      		.word	256
 2743 005e 0401      		.word	260
 2744 0060 0801      		.word	264
 2745 0062 0B01      		.word	267
 2746 0064 0C01      		.word	268
 2747 0066 1101      		.word	273
 2748 0068 0D01      		.word	269
 2749 006a 0E01      		.word	270
 2750 006c 0001      		.word	256
 2751 006e 0401      		.word	260
 2752 0070 0801      		.word	264
 2753 0072 1301      		.word	275
 2754 0074 1401      		.word	276
 2755 0076 2F01      		.word	303
 2756 0078 2901      		.word	297
 2757 007a 2401      		.word	292
 2758 007c 2600      		.word	38
 2759 007e 0801      		.word	264
 2760 0080 FD00      		.word	253
 2761 0082 0001      		.word	256
 2762 0084 0801      		.word	264
 2763 0086 2900      		.word	41
 2764               	.global	commands
 2767               	commands:
 2768 0088 8000      		.word	128
 2769 008a F801      		.word	504
 2770 008c 4602      		.word	582
 2771 008e 0503      		.word	773
 2772 0090 4004      		.word	1088
 2773 0092 4005      		.word	1344
 2774 0094 4006      		.word	1600
 2775 0096 4007      		.word	1856
 2776 0098 4008      		.word	2112
 2777 009a 4009      		.word	2368
 2778 009c 030A      		.word	2563
 2779               	.global	fanlevel
 2782               	fanlevel:
 2783 009e FE        		.byte	-2
 2784               	.global	i2cbuffer
 2785               		.section .bss
 2788               	i2cbuffer:
 2789 0000 0000      		.zero	2
 2790               		.comm	isrtimer,2,1
 2791               		.comm	fanspin,2,1
 2792               		.comm	rpm,2,1
 2793               		.comm	temp,2,1
 2794               		.comm	vcc,2,1
 2795               		.comm	a7min,2,1
 2796               		.comm	a7max,2,1
 2797               		.comm	a7avg,2,1
 2798               		.comm	a7,2,1
 2799               		.comm	a5,2,1
 2800               		.comm	a4,2,1
 2801               		.comm	a3,2,1
 2802               		.comm	a2,2,1
 2803               		.comm	a1,2,1
 2804               		.comm	a0,2,1
 2805               	.global	i2cerror
 2808               	i2cerror:
 2809 0002 00        		.zero	1
 2810               		.comm	crc,1,1
 2811               		.comm	changeled,1,1
 2812               	.global	newbllevel
 2813               		.data
 2816               	newbllevel:
 2817 009f 1F        		.byte	31
 2818               	.global	bllevel
 2821               	bllevel:
 2822 00a0 1F        		.byte	31
 2823               		.comm	count,1,1
 2824               	.global	a7count
 2825               		.section .bss
 2828               	a7count:
 2829 0003 00        		.zero	1
 2830               		.comm	buffer_address,1,1
 2831               		.comm	twdrbuffer,1,1
 2832               	.global	commandbyte
 2833               		.data
 2836               	commandbyte:
 2837 00a1 FF        		.byte	-1
 2838               		.comm	led,3,1
 2839               		.text
 2840               	.Letext0:
 2841               		.file 7 "/usr/avr/include/stdint.h"
 2842               		.file 8 "light_ws2812.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccc5NISE.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccc5NISE.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccc5NISE.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccc5NISE.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccc5NISE.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccc5NISE.s:11     .text:0000000000000000 _crc8_ccitt_update
     /tmp/ccc5NISE.s:46     .text:0000000000000012 ws2812_sendarray_mask
     /tmp/ccc5NISE.s:122    .text:0000000000000042 loop88
     /tmp/ccc5NISE.s:155    .text:000000000000006e ws2812_setleds_pin
     /tmp/ccc5NISE.s:204    .text:000000000000008a ws2812_setleds
     /tmp/ccc5NISE.s:223    .text:0000000000000090 ws2812_sendarray
     /tmp/ccc5NISE.s:242    .text:0000000000000096 writebl
     /tmp/ccc5NISE.s:444    .text:0000000000000110 initbl
     /tmp/ccc5NISE.s:558    .text:0000000000000146 write
     /tmp/ccc5NISE.s:683    .text:000000000000019e setup_lcd
     /tmp/ccc5NISE.s:2767   .data:0000000000000088 commands
     /tmp/ccc5NISE.s:2695   .data:0000000000000000 commands2
     /tmp/ccc5NISE.s:786    .text:00000000000001ec readAna
     /tmp/ccc5NISE.s:901    .text:0000000000000256 readVcc
     /tmp/ccc5NISE.s:999    .text:00000000000002c2 GetTemp
     /tmp/ccc5NISE.s:1088   .text:000000000000031c freeRam
     /tmp/ccc5NISE.s:1140   .text:000000000000034a I2C_init
                            *COM*:0000000000000001 buffer_address
     /tmp/ccc5NISE.s:1177   .text:0000000000000360 __vector_9
                            *ABS*:0000000000000002 __gcc_isr.n_pushed.001
                            *COM*:0000000000000002 fanspin
     /tmp/ccc5NISE.s:1219   .text:000000000000038a __vector_23
                            *ABS*:0000000000000002 __gcc_isr.n_pushed.002
                            *COM*:0000000000000002 isrtimer
     /tmp/ccc5NISE.s:1250   .text:00000000000003ae __vector_36
     /tmp/ccc5NISE.s:2836   .data:00000000000000a1 commandbyte
                            *COM*:0000000000000001 crc
     /tmp/ccc5NISE.s:2808   .bss:0000000000000002 i2cerror
                            *COM*:0000000000000002 a0
     /tmp/ccc5NISE.s:2788   .bss:0000000000000000 i2cbuffer
                            *COM*:0000000000000001 twdrbuffer
                            *COM*:0000000000000002 a1
                            *COM*:0000000000000002 a2
                            *COM*:0000000000000002 a3
                            *COM*:0000000000000002 a4
                            *COM*:0000000000000002 a5
                            *COM*:0000000000000002 a7
                            *COM*:0000000000000002 rpm
                            *COM*:0000000000000002 vcc
                            *COM*:0000000000000002 temp
                            *COM*:0000000000000002 a7avg
     /tmp/ccc5NISE.s:2816   .data:000000000000009f newbllevel
     /tmp/ccc5NISE.s:2782   .data:000000000000009e fanlevel
                            *COM*:0000000000000003 led
                            *COM*:0000000000000001 changeled
     /tmp/ccc5NISE.s:2821   .data:00000000000000a0 bllevel
     /tmp/ccc5NISE.s:2066   .text:000000000000073e setup
     /tmp/ccc5NISE.s:2259   .text.startup:0000000000000000 main
                            *COM*:0000000000000002 a7max
                            *COM*:0000000000000002 a7min
     /tmp/ccc5NISE.s:2828   .bss:0000000000000003 a7count
                            *COM*:0000000000000001 count

UNDEFINED SYMBOLS
__divmodsi4
__brkval
__heap_start
__tablejump2__
__floatunsisf
__mulsf3
__fixunssfsi
__do_copy_data
__do_clear_bss
